---
layout: translation
title: Pro Git 4.8 Git サーバー Gitolite
---
<h2 id='gitolite'>Gitolite</h2>

<p>注意: Progit のこのセクションの最新版は、常に <a href='http://github.com/sitaramc/gitolite/blob/pu/doc/progit-article.mkd'>gitolite のドキュメント</a> として公開しています。筆者としては、このセクションさえ読めば gitolite をインストールできるよう正確に記述しているつもりです。しかし、完全な状態ではなく、gitolite に付属する大量のドキュメントに取って代わるものというわけでもありません。</p>

<p>Git は法人の環境でもよく使われるようになってきました。それにつれて、アクセス制御に関する要望もいくつか出てきました。Gitolite は、最初はそのような要望ににこたえるために作られたものでしたが、オープンソースの世界でも便利に使えることがわかりました。Fedora Project では、パッケージ管理リポジトリ (なんと 10,000 以上もある!) のアクセス制御に gitolite を使っています。おそらく gitolite の使用例としては最大規模のものでしょう。</p>

<p>Gitolite は、単なるリポジトリ単位の権限付与だけではなくリポジトリ内のブランチやタグ単位で権限を付与することができます。つまり、特定の人 (あるいはグループ) にだけ特定の &#8220;refs&#8221; (ブランチあるいはタグ) に対するプッシュ権限を与えて他の人には許可しないといったことができるのです。</p>

<h3 id='id89'>インストール</h3>

<p>Gitolite のインストールは非常に簡単で、豊富な付属ドキュメントを読まなくてもインストールできます。必要なものは、何らかの Unix 系サーバのアカウントです。各種の Linux や Solaris 10 でテストされています。root アクセス権は不要です。git や perl、そして openssh 互換の ssh サーバは既にインストールされているものとします。以下の例では、<code>gitserver</code> というホストにあるアカウント <code>gitolite</code> を使います。</p>

<p>Gitolite は、いわゆる &#8220;サーバー&#8221; ソフトウェアとしては少し変わっています。アクセスは ssh 経由で行うので、サーバー上のすべての userid が &#8220;gitolite host&#8221; となり得ます。その結果、ソフトウェアそのものを &#8220;インストール&#8221; してから、ユーザーを &#8220;gitolite host&#8221; として設定することになります。</p>

<p>Gitolite には 4 通りのインストール方法があります。Fedora や Debian を使っている人は、RPM あるいは DEB を使ってインストールすることができます。root アクセス権を持っている人は手動でインストールできます。これらの方法でインストールした場合は、システム上のすべてのユーザーを &#8220;gitolite host&#8221; にできます。</p>

<p>root アクセス権のない人は、自分のユーザーIDでインストールします。最後の方法として、gitolite のインストールは <em>ワークステーション上の</em> bash シェルで実行することもできます (msysgit に付属する bash でもだいじょうぶです)。</p>

<p>ここでは、最後の方法について説明します。その他のインストール方法についてはドキュメントを参照してください。</p>

<p>まず最初に公開鍵を使ってサーバにアクセスできるようにし、パスワードプロンプトなしにサーバにログインできるようにします。Linux では次の手順が使えますが、他の OS では手動で同じことをしなければならないかもしれません。鍵ペアは、すでに <code>ssh-keygen</code> で生成済みであるものとします。</p>

<pre><code>$ ssh-copy-id -i ~/.ssh/id_rsa gitolite@gitserver</code></pre>

<p>これを実行すると gitolite アカウントのパスワードを聞かれ、それから公開鍵によるアクセスを設定します。インストールスクリプトを実行するにはこれが <strong>必須</strong> なので、パスワードプロンプトなしにコマンドが実行できることを確認しておきましょう。</p>

<pre><code>$ ssh gitolite@gitserver pwd
/home/gitolite</code></pre>

<p>次に、プロジェクトのメインサイトから Gitolite をクローンし、&#8221;easy install&#8221; スクリプトを実行します (三番目の引数は、gitolite-admin リポジトリ上で使われるあなたの名前です)。</p>

<pre><code>$ git clone git://github.com/sitaramc/gitolite
$ cd gitolite/src
$ ./gl-easy-install -q gitolite gitserver sitaram</code></pre>

<p>これで完了です! Gitolite はサーバにインストールされ、<code>gitolite-admin</code> という新しいリポジトリがあなたのワークステーションのホームディレクトリにできあがりました。gitolite の設定を管理するには、このリポジトリに変更を加えてプッシュします。</p>

<p>最後のコマンドは、かなりの量の出力があります。読んでみるとおもしろいでしょう。また、最初にこれを実行したときには新しい鍵ペアが作られます。このとき、パスフレーズを指定しなければなりません。パスフレーズをなしにするときは単に enter キーを押します。なぜまた別の鍵ペアが必要なのか、そしてそれをどのように使うのかについては、Gitolite の付属ドキュメント &#8220;ssh troubleshooting&#8221; に説明があります。</p>

<p><code>gitolite-admin</code> および <code>testing</code> という名前のリポジトリが、サーバー上にデフォルトで作成されます。これらのいずれかをローカルにクローンしたい場合は、(gitolite アカウントに <em>authorized_keys</em> での SSH コンソールアクセスができるアカウントから) このようにします。</p>

<pre><code>$ git clone gitolite:gitolite-admin
$ git clone gitolite:testing</code></pre>

<p>同じリポジトリをその他のアカウントからクローンする場合は、このようになります。</p>

<pre><code>$ git clone gitolite@servername:gitolite-admin
$ git clone gitolite@servername:testing</code></pre>

<h3 id='id90'>インストールのカスタマイズ</h3>

<p>デフォルトのインストールは素早く済ませられ、たいていの人にとってはこれで十分でしょう。しかし、必要に応じてインストール方法をカスタマイズすることもできます。引数 <code>-q</code> を省略すると、冗長モードのインストールとなり、各段階で何がインストールされるのかについて詳しい情報が表示されるようになります。冗長モードでインストールすると、サーバ側のパラメータを変更することもできます。たとえば実際のリポジトリの場所などです。パラメータを変更するには、サーバが使用する &#8220;rc&#8221; ファイルを編集します。この &#8220;rc&#8221; ファイルには大量にコメントが書かれているので、必要に応じて簡単に書き換えることができるでしょう。このファイルには、gitolite の高度な機能の有効/無効を切り替えるような設定項目も多く含まれています。</p>

<h3 id='id91'>設定ファイルおよびアクセス制御ルール</h3>

<p>インストールが終わったら、<code>gitolite-admin</code> リポジトリ (HOME ディレクトリにあります) に移動して中をのぞいてみましょう。</p>

<pre><code>$ cd ~/gitolite-admin/
$ ls
conf/  keydir/
$ find conf keydir -type f
conf/gitolite.conf
keydir/sitaram.pub
$ cat conf/gitolite.conf
#gitolite conf
# please see conf/example.conf for details on syntax and features

repo gitolite-admin
    RW+                 = sitaram

repo testing
    RW+                 = @all</code></pre>

<p>&#8220;sitaram&#8221; (先ほどの <code>gl-easy-install</code> コマンドで、最後の引数に指定したユーザです) が、<code>gitolite-admin</code> リポジトリおよび同名の公開鍵ファイルへの読み書き権限を持っていることに注目しましょう。</p>

<p>gitolite の設定ファイルの構文は <code>conf/example.conf</code> には詳しく書かれているので、ここでは大事なところに絞って説明します。</p>

<p>ユーザやリポジトリをグループにまとめることもできます。グループ名は単なるマクロのようなものです。グループを定義する際には、それがユーザであるかプロジェクトであるかは無関係です。実際にその「マクロ」を <em>使う</em> 段階になって初めてそれらを区別することになります。</p>

<pre><code>@oss_repos      = linux perl rakudo git gitolite
@secret_repos   = fenestra pear

@admins         = scott     # Adams, not Chacon, sorry :)
@interns        = ashok     # get the spelling right, Scott!
@engineers      = sitaram dilbert wally alice
@staff          = @admins @engineers @interns</code></pre>

<p>パーミッションは、&#8221;ref&#8221; レベルで設定することができます。次の例では、インターン (@interns) は &#8220;int&#8221; ブランチにしかプッシュできないように設定しています。エンジニア (@engineers) は名前が &#8220;eng-&#8221; で始まるすべてのブランチにプッシュでき、また &#8220;rc&#8221; のあとに一桁の数字が続く名前のタグにもプッシュできます。また、管理者 (@admins) はすべての ref に対してあらゆることができます。</p>

<pre><code>repo @oss_repos
    RW  int$                = @interns
    RW  eng-                = @engineers
    RW  refs/tags/rc[0-9]   = @engineers
    RW+                     = @admins</code></pre>

<p><code>RW</code> や <code>RW+</code> の後に書かれている式は正規表現 (regex) で、これにマッチする refname (ref) が対象となります。なので、これに &#8220;refex&#8221; と名付けました! もちろん、refex はこの例で示したよりずっと強力なものです。perl の正規表現になじめない人は、あまりやりすぎないようにしましょう。</p>

<p>また、すでにお気づきかもしれませんが、<code>refs/</code> で始まらない refex を指定すると、Gitolite はその先頭に <code>refs/heads/</code> がついているものとみなします。これは構文上の利便性を意識したものです。</p>

<p>設定ファイルの構文の中でも重要なのは、ひとつのリポジトリに対するルールをすべてひとまとめにしなくてもよいということです。共通の設定をひとまとめにして上の例のように <code>oss_repos</code> に対してルールを設定し、その後で個々の場合について個別のルールを追加していくこともできます。</p>

<pre><code>repo gitolite
    RW+                     = sitaram</code></pre>

<p>このルールは、<code>gitolite</code> リポジトリのルール群に追加されます。</p>

<p>で、実際のアクセス制御ルールはどのように書けばいいの? と思われたことでしょう。簡単に説明します。</p>

<p>gitolite のアクセス制御には二段階のレベルがあります。まず最初はリポジトリレベルのアクセス制御です。あるリポジトリへの読み込み (書き込み) アクセス権を持っているということは、そのリポジトリの <em>すべての</em> ref に対する読み込み (書き込み) 権限を持っていることを意味します。</p>

<p>もうひとつのレベルは &#8220;書き込み&#8221; アクセス権だけを制御するものですが、リポジトリ内のブランチやタグ単位で設定できます。ユーザ名、試みられるアクセス (<code>W</code> あるいは <code>+</code>)、そして更新される refname が既知となります。アクセスルールのチェックは、設定ファイルに書かれている順に行われ、この組み合わせにマッチ (単なる文字列マッチではなく正規表現によるマッチであることに注意しましょう) するものを探していきます。マッチするものが見つかったら、プッシュが成功します。マッチしなかった場合は、アクセスが拒否されます。</p>

<h3 id='_'>&#8220;拒否&#8221; ルールによる高度なアクセス制御</h3>

<p>これまでに見てきた権限は <code>R</code>、<code>RW</code> あるいは <code>RW+</code> だけでした。しかし、gitolite にはそれ以外の権限もあります。それが <code>-</code> で、&#8221;禁止&#8221; をあらわすものです。これを使えばより強力なアクセス制御ができるようになりますが、少し設定は複雑になります。マッチしなければアクセスを拒否するというだけでなく、ルールを書く順番もからんでくることになるからです。</p>

<p>上の例で、エンジニアは master と integ <em>以外</em> のすべてのブランチを巻き戻せるように設定しようとすると、次のようになります。</p>

<pre><code>    RW  master integ    = @engineers
    -   master integ    = @engineers
    RW+                 = @engineers</code></pre>

<p>この場合も上から順にルールを適用し、最初にマッチしたアクセス権をあてはめます。何もマッチしなければアクセスは拒否されます。master や integ に対する巻き戻し以外のプッシュは、最初のルールにマッチするので許可されます。これらのブランチに対する巻き戻しのプッシュは最初のルールにマッチしません。そこで二番目のルールに移動し、この時点で拒否されます。master と integ 以外への (巻き戻しを含む) 任意のプッシュは最初の二つのルールのいずれにもマッチしないので、三番目のルールが適用されます。</p>

<h3 id='id92'>ファイル単位でのプッシュの制限</h3>

<p>変更をプッシュすることのできるブランチを制限するだけでなく、変更できるファイルを制限することも可能です。たとえば、Makefile (あるいはその他のプログラム) などは誰もが変更できるというものではないでしょう。このファイルはさまざまなものに依存しており、変更によっては壊れてしまうことがあるかもしれないからです。そんな場合は次のように設定します。</p>

<pre><code>repo foo
    RW                  =   @junior_devs @senior_devs

    RW  NAME/           =   @senior_devs
    -   NAME/Makefile   =   @junior_devs
    RW  NAME/           =   @junior_devs</code></pre>

<p>この強力な機能については <code>conf/example.conf</code> に説明があります。</p>

<h3 id='id93'>個人ブランチ</h3>

<p>Gitolite には &#8220;個人ブランチ&#8221; (&#8220;個人的なブランチ用の名前空間&#8221; と言ったほうがいいでしょうか) という機能があります。これは、法人の環境では非常に便利なものです。</p>

<p>git の世界では、いわゆる「プルリクエスト」によるコードのやりとりが頻繁に発生します。しかし法人の環境では、権限のない人によるアクセスは厳禁です。開発者のワークステーションにはそんな権限はありません。そこで、まず一度中央サーバにプッシュして、そこからプルしてもらうよう誰かにお願いすることになります。</p>

<p>これを中央管理型の VCS でやろうとすると、同じ名前のブランチが乱造されることになってしまいます。また、これらのアクセス権限を設定するのは管理者にとって面倒な作業です。</p>

<p>Gitolite では、各開発者に対して &#8220;personal&#8221; あるいは &#8220;scratch&#8221; といった名前空間プレフィックス (たとえば <code>refs/personal/&lt;devname&gt;/*</code>) を定義します。詳細は、<code>doc/3-faq-tips-etc.mkd</code> の &#8220;personal branches&#8221; を参照ください。</p>

<h3 id='_'>&#8220;ワイルドカード&#8221; リポジトリ</h3>

<p>Gitolite では、ワイルドカード (実際のところは perl の正規表現です) を使ってリポジトリを指定することができます。たとえば <code>assignments/s[0-9][0-9]/a[0-9][0-9]</code> のようにします。これは非常に強力な機能で、使うには rc ファイルに <code>$GL_WILDREPOS = 1;</code> と設定しなければなりません。この機能を使うと、新たな権限モード (&#8221;C&#8221;) が用意されます。これは、ワイルドカードにマッチするリポジトリの作成を許可するモードです。新たに作成したリポジトリの所有者は自動的にそのユーザに設定され、他のユーザに R あるいは RW の権限を付与できるようになります。この機能の説明は <code>doc/4-wildcard-repositories.mkd</code> にあります。</p>

<h3 id='id94'>その他の機能</h3>

<p>最後にその他の機能の例を紹介しましょう。これらについての詳しい説明は、ドキュメントの &#8220;faqs, tips, etc&#8221; にあります。</p>

<p><strong>ログ記録</strong>: Gitolite は、成功したアクセスをすべてログに記録します。巻き戻し権限 (<code>RW+</code>) を与えているときに、誰かが &#8220;master&#8221; を吹っ飛ばしてしまったとしましょう。そんなときにはログファイルが救世主となります。ログを見れば、問題を起こした SHA をすぐに発見できるでしょう。</p>

<p><strong>通常の PATH 以外にインストールした git</strong>: gitolite の非常に便利な機能のひとつは、通常の <code>$PATH</code> 以外にインストールされた git もサポートしているという点です (これは思っているほど珍しいことではありません。法人の環境やホスティング環境ではシステム全体への影響を及ぼすインストールが禁じられているところもあり、そんな場合は自分のディレクトリの配下にインストールすることになるからです)。通常なら、標準以外の場所にインストールされた git バイナリを何らかの方法でクライアント側の git に認識させなければなりませんが、gitolite があれば単に冗長モードのインストールで &#8220;rc&#8221; ファイルに <code>$GIT_PATH</code> を設定するだけです。クライアント側の変更は不要です :-)</p>

<p><strong>アクセス権の報告</strong>: もうひとつの便利な機能は、サーバに ssh で接続したときに起こります。gitolite はあなたがアクセスするリポジトリとどのようなアクセスができるかを表示します。たとえばこんな感じです。</p>

<pre><code>    hello sitaram, the gitolite version here is v1.5.4-19-ga3397d4
    the gitolite config gives you the following access:
         R     anu-wsd
         R     entrans
         R  W  git-notes
         R  W  gitolite
         R  W  gitolite-admin
         R     indic_web_input
         R     shreelipi_converter</code></pre>

<p><strong>委譲</strong>: 大規模な環境では、特定のリポジトリのグループに対する責任を委譲して個別に管理させることもできます。こうすれば主管理者の負荷が軽減され、主管理者がボトルネックとなることも少なくなります。この機能については、<code>doc/</code> ディレクトリの中に個別のファイルで説明されています。</p>

<p><strong>Gitweb のサポート</strong>: Gitolite は gitweb を何通りかの方法でサポートしています。まず、どのリポジトリを gitweb 上で見せるかを設定することができます。また、gitweb 用の &#8220;owner&#8221; と &#8220;description&#8221; を gitolite の設定ファイルに書くことができます。Gitweb には HTTP 認証に基づいたアクセス制御の機能もありますが、gitolite が生成する &#8220;コンパイル済み&#8221; の設定ファイルを使えば gitweb と gitolite で共通の (読み込み) アクセス制御ルールを適用することができます。</p>

<p><strong>ミラーリング</strong>: Gitolite は、複数のミラーを保守したり、プライマリサーバーが落ちたときに簡単にミラーに切り替えたりすることができます。</p>

<div id='nav'>
<a href='ch4-7.html'>prev</a> | <a href='ch4-9.html'>next</a>
</div>