---
layout: translation
title: Pro Git 5.3 Git での分散作業 プロジェクトの運営
---
<h2 id='id112'>プロジェクトの運営</h2>

<p>プロジェクトに貢献する方法だけでなく、プロジェクトを運営する方法についても知っておくといいでしょう。たとえば <code>format-patch</code> を使ってメールで送られてきたパッチを処理する方法や、別のリポジトリのリモートブランチでの変更を統合する方法などです。本流のリポジトリを保守するにせよパッチの検証や適用を手伝うにせよ、どうすれば貢献者たちにとってわかりやすくなるかを知っておくべきでしょう。</p>

<h3 id='id113'>トピックブランチでの作業</h3>

<p>新しい機能を組み込もうと考えている場合は、トピックブランチを作ることをおすすめします。トピックブランチとは、新しく作業を始めるときに一時的に作るブランチのことです。そうすれば、そのパッチだけを個別にいじることができ、もしうまくいかなかったとしてもすぐに元の状態に戻すことができます。ブランチの名前は、今からやろうとしている作業の内容にあわせたシンプルな名前にしておきます。たとえば <code>ruby_client</code> などといったものです。そうすれば、しばらく時間をおいた後でそれを廃棄することになったときに、内容を思い出しやすくなります。Git プロジェクトのメンテナは、ブランチ名に名前空間を使うことが多いようです。たとえば <code>sc/ruby_client</code> のようになり、ここでの <code>sc</code> はその作業をしてくれた人の名前を短縮したものとなります。自分の master ブランチをもとにしたブランチを作成する方法は、このようになります。</p>

<pre><code>$ git branch sc/ruby_client master</code></pre>

<p>作成してすぐそのブランチに切り替えたい場合は、<code>checkout -b</code> を使います。</p>

<pre><code>$ git checkout -b sc/ruby_client master</code></pre>

<p>受け取った作業はこのトピックブランチですすめ、長期ブランチに統合するかどうかを判断することになります。</p>

<h3 id='id114'>メールで受け取ったパッチの適用</h3>

<p>あなたのプロジェクトへのパッチをメールで受け取った場合は、まずそれをトピックブランチに適用して中身を検証します。メールで届いたパッチを適用するには <code>git apply</code> と <code>git am</code> の二通りの方法があります。</p>

<h4 id='apply_'>apply でのパッチの適用</h4>

<p><code>git diff</code> あるいは Unix の <code>diff</code> コマンドで作ったパッチを受け取ったときは、<code>git apply</code> コマンドを使ってパッチを適用します。パッチが <code>/tmp/patch-ruby-client.patch</code> にあるとすると、このようにすればパッチを適用できます。</p>

<pre><code>$ git apply /tmp/patch-ruby-client.patch</code></pre>

<p>これは、作業ディレクトリ内のファイルを変更します。<code>patch -p1</code> コマンドでパッチをあてるのとほぼ同じなのですが、それ以上に「これでもか」というほどのこだわりを持ってパッチを適用するので fuzzy マッチになる可能性が少なくなります。また、<code>git diff</code> 形式ではファイルの追加・削除やファイル名の変更も扱うことができますが、<code>patch</code> コマンドにはそれはできません。そして最後に、<code>git apply</code> は「全部適用するか、あるいは一切適用しないか」というモデルを採用しています。一方 <code>patch</code> コマンドの場合は、途中までパッチがあたった中途半端な状態になって困ることがあります。<code>git apply</code> のほうが、全体的に <code>patch</code> よりもこだわりを持った処理を行うのです。<code>git apply</code> コマンドはコミットを作成するわけではありません。実行した後で、その変更をステージしてコミットする必要があります。</p>

<p>git apply を使って、そのパッチをきちんと適用できるかどうかを事前に確かめることができます。パッチをチェックするには <code>git apply --check</code> を実行します。</p>

<pre><code>$ git apply --check 0001-seeing-if-this-helps-the-gem.patch 
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply</code></pre>

<p>何も出力されなければ、そのパッチはうまく適用できるということです。このコマンドは、チェックに失敗した場合にゼロ以外の値を返して終了します。スクリプト内でチェックしたい場合などにはこの返り値を使用します。</p>

<h4 id='am_'>am でのパッチの適用</h4>

<p>コードを提供してくれた人が Git のユーザーで、<code>format-patch</code> コマンドを使ってパッチを送ってくれたとしましょう。この場合、あなたの作業はより簡単になります。パッチの中に、作者の情報やコミットメッセージも含まれているからです。「パッチを作るときには、できるだけ <code>diff</code> ではなく <code>format-patch</code> を使ってね」とお願いしてみるのもいいでしょう。昔ながらの形式のパッチが届いたときだけは <code>git apply</code> を使わなければならなくなります。</p>

<p><code>format-patch</code> で作ったパッチを適用するには <code>git am</code> を使います。技術的なお話をすると、<code>git am</code> は mbox ファイルを読み込む仕組みになっています。mbox はシンプルなプレーンテキスト形式で、一通あるいは複数のメールのメッセージをひとつのテキストファイルにまとめるためのものです。中身はこのようになります。</p>

<pre><code>From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20</code></pre>

<p>先ほどのセクションでごらんいただいたように、format-patch コマンドの出力結果もこれと同じ形式で始まっていますね。これは、mbox 形式のメールフォーマットとしても正しいものです。git send-email を正しく使ったパッチが送られてきた場合、受け取ったメールを mbox 形式で保存して git am コマンドでそのファイルを指定すると、すべてのパッチの適用が始まります。複数のメールをまとめてひとつの mbox に保存できるメールソフトを使っていれば、送られてきたパッチをひとつのファイルにまとめて git am で一度に適用することもできます。</p>

<p>しかし、<code>format-patch</code> で作ったパッチがチケットシステム (あるいはそれに類する何か) にアップロードされたような場合は、まずそのファイルをローカルに保存して、それを <code>git am</code> に渡すことになります。</p>

<pre><code>$ git am 0001-limit-log-function.patch 
Applying: add limit to log function</code></pre>

<p>どんなパッチを適用したのかが表示され、コミットも自動的に作られます。作者の情報はメールの <code>From</code> ヘッダと <code>Date</code> ヘッダから取得し、コミットメッセージは <code>Subject</code> とメールの本文 (パッチより前の部分) から取得します。たとえば、先ほどごらんいただいた mbox の例にあるパッチを適用した場合は次のようなコミットとなります。</p>

<pre><code>$ git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith &lt;jessica@example.com&gt;
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon &lt;schacon@gmail.com&gt;
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   add limit to log function

   Limit log functionality to the first 20</code></pre>

<p><code>Commit</code> には、そのパッチを適用した人と適用した日時が表示されます。<code>Author</code> には、そのパッチを実際に作成した人と作成した日時が表示されます。</p>

<p>しかし、パッチが常にうまく適用できるとは限りません。パッチを作成したときの状態と現在のメインブランチとが大きくかけ離れてしまっていたり、そのパッチが別の (まだ適用していない) パッチに依存していたりなどといったことがあり得るでしょう。そんな場合は <code>git am</code> は失敗し、次にどうするかを聞かれます。</p>

<pre><code>$ git am 0001-seeing-if-this-helps-the-gem.patch 
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Patch failed at 0001.
When you have resolved this problem run &quot;git am --resolved&quot;.
If you would prefer to skip this patch, instead run &quot;git am --skip&quot;.
To restore the original branch and stop patching run &quot;git am --abort&quot;.</code></pre>

<p>このコマンドは、何か問題が発生したファイルについて衝突マークを書き込みます。これは、マージやリベースに失敗したときに書き込まれるのとよく似たものです。問題を解決する方法も同じです。まずはファイルを編集して衝突を解決し、新しいファイルをステージし、<code>git am --resolved</code> を実行して次のパッチに進みます。</p>

<pre><code>$ (ファイルを編集する)
$ git add ticgit.gemspec 
$ git am --resolved
Applying: seeing if this helps the gem</code></pre>

<p>Git にもうちょっと賢く働いてもらって衝突を回避したい場合は、<code>-3</code> オプションを使用します。これは、Git で三方向のマージを行うオプションです。このオプションはデフォルトでは有効になっていません。適用するパッチの元になっているコミットがあなたのリポジトリ上のものでない場合に正しく動作しないからです。パッチの元になっているコミットが手元にある場合は、<code>-3</code> オプションを使うと、衝突しているパッチをうまく適用できます。</p>

<pre><code>$ git am -3 0001-seeing-if-this-helps-the-gem.patch 
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.</code></pre>

<p>ここでは、既に適用済みのパッチを適用してみました。<code>-3</code> オプションがなければ、衝突が発生していたことでしょう。</p>

<p>たくさんのパッチが含まれる mbox からパッチを適用するときには、<code>am</code> コマンドを対話モードで実行することもできます。パッチが見つかるたびに処理を止め、それを適用するかどうかの確認を求められます。</p>

<pre><code>$ git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all </code></pre>

<p>これは、「大量にあるパッチについて、内容をまず一通り確認したい」「既に適用済みのパッチは適用しないようにしたい」などの場合に便利です。</p>

<p>トピックブランチ上でそのトピックに関するすべてのパッチの適用を済ませてコミットすれば、次はそれを長期ブランチに統合するかどうか (そしてどのように統合するか) を考えることになります。</p>

<h3 id='id115'>リモートブランチのチェックアウト</h3>

<p>自前のリポジトリを持つ Git ユーザーが自分のリポジトリに変更をプッシュし、そのリポジトリの URL とリモートブランチ名だけをあなたにメールで連絡してきた場合のことを考えてみましょう。そのリポジトリをリモートとして登録し、それをローカルにマージすることになります。</p>

<p>Jessica から「すばらしい新機能を作ったので、私のリポジトリの <code>ruby-client</code> ブランチを見てください」といったメールが来たとします。これを手元でテストするには、リモートとしてこのリポジトリを追加し、ローカルにブランチをチェックアウトします。</p>

<pre><code>$ git remote add jessica git://github.com/jessica/myproject.git
$ git fetch jessica
$ git checkout -b rubyclient jessica/ruby-client</code></pre>

<p>「この前のとは違う、別のすばらしい機能を作ったの!」と別のブランチを伝えられた場合は、すでにリモートの設定が済んでいるので単にそのブランチを取得してチェックアウトするだけで確認できます。</p>

<p>この方法は、誰かと継続的に共同作業を進めていく際に便利です。ちょっとしたパッチをたまに提供してくれるだけの人の場合は、パッチをメールで受け取るようにしたほうが時間の節約になるでしょう。全員に自前のサーバーを用意させて、たまに送られてくるパッチを取得するためだけに定期的にリモートの追加と削除を行うなどというのは時間の無駄です。ほんの数件のパッチを提供してくれる人たちを含めて数百ものリモートを管理することなど、きっとあなたはお望みではないでしょう。しかし、スクリプトやホスティングサービスを使えばこの手の作業は楽になります。つまり、どのような方式をとるかは、あなたや他のメンバーがどのような方式で開発を進めるかによって決まります。</p>

<p>この方式のもうひとつの利点は、コミットの履歴も同時に取得できるということです。マージの際に問題が起こることもあるでしょうが、そんな場合にも相手の作業が自分側のどの地点に基づくものなのかを知ることができます。適切に三方向のマージが行われるので、<code>-3</code> を指定したときに「このパッチの基点となるコミットにアクセスできればいいなぁ」と祈る必要はありません。</p>

<p>継続的に共同作業を続けるわけではないけれど、それでもこの方式でパッチを取得したいという場合は、リモートリポジトリの URL を <code>git pull</code> コマンドで指定することもできます。これは一度きりのプルに使うものであり、リモートを参照する URL は保存されません。</p>

<pre><code>$ git pull git://github.com/onetimeguy/project.git
From git://github.com/onetimeguy/project
 * branch            HEAD       -&gt; FETCH_HEAD
Merge made by recursive.</code></pre>

<h3 id='id116'>何が変わるのかの把握</h3>

<p>トピックブランチの中に、提供してもらった作業が含まれた状態になりました。次に何をすればいいのか考えてみましょう。このセクションでは、これまでに扱ったいくつかのコマンドを復習します。それらを使って、もしこの変更をメインブランチにマージしたらいったい何が起こるのかを調べていきましょう。</p>

<p>トピックブランチのコミットのうち、master ブランチに存在しないコミットの内容をひとつひとつレビューできれば便利でしょう。master ブランチに含まれるコミットを除外するには、ブランチ名の前に <code>--not</code> オプションを指定します。たとえば、誰かから受け取った二つのパッチを適用するために <code>contrib</code> というブランチを作成したとすると、</p>

<pre><code>$ git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Oct 24 09:53:59 2008 -0700

    seeing if this helps the gem

commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Mon Oct 22 19:38:36 2008 -0700

    updated the gemspec to hopefully work better</code></pre>

<p>このようなコマンドを実行すればそれぞれのコミットの内容を確認できます。<code>git log</code> に <code>-p</code> オプションを渡せば、コミットの後に diff を表示させることもできます。これも以前に説明しましたね。</p>

<p>このトピックブランチを別のブランチにマージしたときに何が起こるのかを完全な diff で知りたい場合は、ちょっとした裏技を使わないと正しい結果が得られません。おそらく「こんなコマンドを実行するだけじゃないの?」と考えておられることでしょう。</p>

<pre><code>$ git diff master</code></pre>

<p>このコマンドで表示される diff は、誤解を招きかねないものです。トピックブランチを切った時点からさらに <code>master</code> ブランチが先に進んでいたとすると、これは少し奇妙に見える結果を返します。というのも、Git は現在のトピックブランチの最新のコミットのスナップショットと <code>master</code> ブランチの最新のコミットのスナップショットを直接比較するからです。トピックブランチを切った後に <code>master</code> ブランチ上であるファイルに行を追加したとすると、スナップショットを比較した結果は「トピックブランチでその行を削除しようとしている」状態になります。</p>

<p><code>master</code> がトピックブランチの直系の先祖である場合は、これは特に問題とはなりません。しかし二つの歴史が分岐している場合には、diff の結果は「トピックブランチで新しく追加したすべての内容を追加し、<code>master</code> ブランチにしかないものはすべて削除する」というものになります。</p>

<p>本当に知りたいのはトピックブランチで変更された内容、つまりこのブランチを master にマージしたときに master に加わる変更です。これを知るには、Git に「トピックブランチの最新のコミット」と「トピックブランチと master ブランチの直近の共通の先祖」とを比較させます。</p>

<p>共通の先祖を見つけだしてそこからの diff を取得するには、このようにします。</p>

<pre><code>$ git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
$ git diff 36c7db </code></pre>

<p>しかし、これでは不便です。そこで Git には、同じことをより手短にやるための手段としてトリプルドット構文が用意されています。<code>diff</code> コマンドを実行するときにピリオドを三つ打った後に別のブランチを指定すると、「現在いるブランチの最新のコミット」と「指定した二つのブランチの共通の先祖」とを比較するようになります。</p>

<pre><code>$ git diff master...contrib</code></pre>

<p>このコマンドは、master との共通の先祖から分岐した現在のトピックブランチで変更された内容のみを表示します。この構文は、覚えやすいので非常に便利です。</p>

<h3 id='id117'>提供された作業の取り込み</h3>

<p>トピックブランチでの作業をメインブランチに取り込む準備ができたら、どのように取り込むかを考えることになります。さらに、プロジェクトを運営していくにあたっての全体的な作業の流れはどのようにしたらいいでしょうか? さまざまな方法がありますが、ここではそのうちのいくつかを紹介します。</p>

<h4 id='id118'>マージのワークフロー</h4>

<p>シンプルなワークフローのひとつとして、作業を自分の <code>master</code> ブランチに取り込むことを考えます。ここでは、<code>master</code> ブランチで安定版のコードを管理しているものとします。トピックブランチでの作業が一段落したら (あるいは誰かから受け取ったパッチをトピックブランチ上で検証し終えたら)、それを master ブランチにマージしてからトピックブランチを削除し、作業を進めることになります。<code>ruby_client</code> および <code>php_client</code> の二つのブランチを持つ図 5-19 のようなリポジトリでまず <code>ruby_client</code> をマージしてから <code>php_client</code> もマージすると、歴史は図 5-20 のようになります。</p>

<p><center><img src="/figures/ch5/18333fig0519-tn.png"></center><br/> 図 5-19. いくつかのトピックブランチを含む履歴</p>

<p><center><img src="/figures/ch5/18333fig0520-tn.png"></center><br/> 図 5-20. トピックブランチをマージした後の状態</p>

<p>これがおそらく一番シンプルなワークフローでしょうが、大規模なリポジトリやプロジェクトで作業をしていると問題が発生することもあります。</p>

<p>多人数で開発していたり大規模なプロジェクトに参加していたりする場合は、二段階以上のマージサイクルを使うこともあるでしょう。ここでは、長期間運用するブランチが <code>master</code> と <code>develop</code> のふたつあるものとします。<code>master</code> が更新されるのは安定版がリリースされるときだけで、新しいコードはずべて <code>develop</code> ブランチに統合されるという流れです。これらのブランチは、両方とも定期的に公開リポジトリにプッシュすることになります。新しいトピックブランチをマージする準備ができたら (図 5-21)、それを <code>develop</code> にマージします (図 5-22)。そしてリリースタグを打つときに、<code>master</code> を現在の <code>develop</code> ブランチが指す位置に進めます (図 5-23)。</p>

<p><center><img src="/figures/ch5/18333fig0521-tn.png"></center><br/> 図 5-21. トピックブランチのマージ前</p>

<p><center><img src="/figures/ch5/18333fig0522-tn.png"></center><br/> 図 5-22. トピックブランチのマージ後</p>

<p><center><img src="/figures/ch5/18333fig0523-tn.png"></center><br/> 図 5-23. トピックブランチのリリース後</p>

<p>他の人があなたのプロジェクトをクローンするときには、master をチェックアウトすれば最新の安定版をビルドすることができ、その後の更新を追いかけるのも容易にできるようになります。一方 develop をチェックアウトすれば、さらに最先端の状態を取得することができます。この考え方を推し進めると、統合用のブランチを用意してすべての作業をいったんそこにマージするようにもできます。統合ブランチ上のコードが安定してテストを通過すれば、それを develop ブランチにマージします。そしてそれが安定していることが確認できたら master ブランチを先に進めるということになります。</p>

<h4 id='id119'>大規模マージのワークフロー</h4>

<p>Git 開発プロジェクトには、常時稼働するブランチが四つあります。<code>master</code>、<code>next</code>、そして新しい作業用の <code>pu</code> (proposed updates) とメンテナンスバックポート用の <code>maint</code> です。新しいコードを受け取ったメンテナは、まず自分のリポジトリのトピックブランチにそれを格納します。先ほど説明したのと同じ方式です (図 5-24 を参照ください)。そしてその内容を検証し、安全に取り込める状態かさらなる作業が必要かを見極めます。だいじょうぶだと判断したらそれを <code>next</code> にマージします。このブランチをプッシュすれば、すべてのメンバーがそれを試せるようになります。</p>

<p><center><img src="/figures/ch5/18333fig0524-tn.png"></center><br/> 図 5-24. 複数のトピックブランチの並行管理</p>

<p>さらに作業が必要なトピックについては、<code>pu</code> にマージします。完全に安定していると判断されたトピックについては改めて <code>master</code> にマージされ、<code>next</code> にあるトピックのうちまだ <code>master</code> に入っていないものを再構築します。つまり、<code>master</code> はほぼ常に前に進み、<code>next</code> は時々リベースされ、<code>pu</code> はそれ以上の頻度でリベースされることになります (図 5-25 を参照ください)。</p>

<p><center><img src="/figures/ch5/18333fig0525-tn.png"></center><br/> 図 5-25. 常時稼働する統合用ブランチへのトピックブランチのマージ</p>

<p>最終的に <code>master</code> にマージされたトピックブランチは、リポジトリから削除します。Git 開発プロジェクトでは <code>maint</code> ブランチも管理しています。これは最新のリリースからフォークしたもので、メンテナンスリリースに必要なバックポート用のパッチを管理します。つまり、Git のリポジトリをクローンするとあなたは四つのブランチをチェックアウトすることができるということです。これらのブランチはどれも異なる開発段階を表し、「どこまで最先端を追いかけたいか」「どのように Git プロジェクトに貢献したいか」によって使い分けることになります。メンテナ側では、新たな貢献を受け入れるためのワークフローが整っています。</p>

<h4 id='id120'>リベースとチェリーピックのワークフロー</h4>

<p>受け取った作業を master ブランチにマージするのではなく、リベースやチェリーピックを使って master ブランチの先端につなげていく方法を好むメンテナもいます。そのほうがほぼ直線的な歴史を保てるからです。トピックブランチでの作業を終えて統合できる状態になったと判断したら、そのブランチで rebase コマンドを実行し、その変更を現在の master (あるいは <code>develop</code> などの) ブランチの先端につなげます。うまくいけば、<code>master</code> ブランチをそのまま前に進めてることでプロジェクトの歴史を直線的に進めることができます。</p>

<p>あるブランチの作業を別のブランチに移すための手段として、他にチェリーピック (つまみぐい) という方法があります。Git におけるチェリーピックとは、コミット単位でのリベースのようなものです。あるコミットによって変更された内容をパッチとして受け取り、それを現在のブランチに再適用します。トピックブランチでいくつかコミットしたうちのひとつだけを統合したい場合、あるいはトピックブランチで一回だけコミットしたけれどそれをリベースではなくチェリーピックで取り込みたい場合などにこの方法を使用します。図 5-26 のようなプロジェクトを例にとって考えましょう。</p>

<p><center><img src="/figures/ch5/18333fig0526-tn.png"></center><br/> 図 5-26. チェリーピック前の歴史</p>

<p>コミット <code>e43a6</code> を master ブランチに取り込むには、次のようにします。</p>

<pre><code>$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
Finished one cherry-pick.
[master]: created a0a41a9: &quot;More friendly message when locking the index fails.&quot;
 3 files changed, 17 insertions(+), 3 deletions(-)</code></pre>

<p>これは <code>e43a6</code> と同じ内容の変更を施しますが、コミットの SHA-1 値は新しくなります。適用した日時が異なるからです。これで、歴史は図 5-27 のように変わりました。</p>

<p><center><img src="/figures/ch5/18333fig0527-tn.png"></center><br/> 図 5-27. トピックブランチのコミットをチェリーピックした後の歴史</p>

<p>あとは、このトピックブランチを削除すれば取り込みたくない変更を消してしまうことができます。</p>

<h3 id='id121'>リリース用のタグ付け</h3>

<p>いよいよリリースする時がきました。おそらく、後からいつでもこのリリースを取得できるようにタグを打っておくことになるでしょう。新しいタグを打つ方法は第 2 章で説明しました。タグにメンテナの署名を入れておきたい場合は、このようにします。</p>

<pre><code>$ git tag -s v1.5 -m &#39;my signed 1.5 tag&#39;
You need a passphrase to unlock the secret key for
user: &quot;Scott Chacon &lt;schacon@gmail.com&gt;&quot;
1024-bit DSA key, ID F721C45A, created 2009-02-09</code></pre>

<p>タグに署名した場合、署名に使用した PGP 鍵ペアの公開鍵をどのようにして配布するかが問題になるかもしれません。Git 開発プロジェクトのメンテナ達がこの問題をどのように解決したかというと、自分たちの公開鍵を blob としてリポジトリに含め、それを直接指すタグを追加することにしました。この方法を使うには、まずどの鍵を使うかを決めるために <code>gpg --list-keys</code> を実行します。</p>

<pre><code>$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon &lt;schacon@gmail.com&gt;
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]</code></pre>

<p>鍵を直接 Git データベースにインポートするには、鍵をエクスポートしてそれをパイプで <code>git hash-object</code> に渡します。これは、鍵の中身を新しい blob として Git に書き込み、その blob の SHA-1 を返します。</p>

<pre><code>$ gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>

<p>鍵の中身を Git に取り込めたので、この鍵を直接指定するタグを作成できるようになりました。<code>hash-object</code> コマンドで知った SHA-1 値を指定すればいいのです。</p>

<pre><code>$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>

<p><code>git push --tags</code> を実行すると、<code>maintainer-pgp-pub</code> タグをみんなと共有できるようになります。誰かがタグを検証したい場合は、あなたの PGP 鍵が入った blob をデータベースから直接プルで取得し、それを PGP にインポートすればいいのです。</p>

<pre><code>$ git show maintainer-pgp-pub | gpg --import</code></pre>

<p>この鍵をインポートした人は、あなたが署名したすべてのタグを検証できるようになります。タグのメッセージに検証手順の説明を含めておけば、<code>git show &lt;tag&gt;</code> でエンドユーザー向けに詳しい検証手順を示すことができます。</p>

<h3 id='id122'>ビルド番号の生成</h3>

<p>Git では、コミットごとに &#8216;v123&#8217; のような単調な番号を振っていくことはありません。もし特定のコミットに対して人間がわかりやすい名前がほしければ、そのコミットに対して <code>git describe</code> を実行します。Git は、そのコミットに最も近いタグの名前とそのタグからのコミット数、そしてそのコミットの SHA-1 値の一部を使った名前を作成します。</p>

<pre><code>$ git describe master
v1.6.2-rc1-20-g8c5b85c</code></pre>

<p>これで、スナップショットやビルドを公開するときにわかりやすい名前をつけられるようになります。実際、Git そのもののソースコードを Git リポジトリからクローンしてビルドすると、<code>git --version</code> が返す結果はこの形式になります。タグが打たれているコミットを直接指定した場合は、タグの名前が返されます。</p>

<p><code>git describe</code> コマンドは注釈付きのタグ (<code>-a</code> あるいは <code>-s</code> フラグをつけて作成したタグ) を使います。したがって、<code>git describe</code> を使うならリリースタグは注釈付きのタグとしなければなりません。そうすれば、describe したときにコミットの名前を適切につけることができます。この文字列を checkout コマンドや show コマンドでの対象の指定に使うこともできますが、これは末尾にある SHA-1 値の省略形に依存しているので将来にわたってずっと使えるとは限りません。たとえば Linux カーネルは、最近 SHA-1 オブジェクトの一意性を確認するための文字数を 8 文字から 10 文字に変更しました。そのため、古い <code>git describe</code> の出力での名前はもはや使えません。</p>

<h3 id='id123'>リリースの準備</h3>

<p>実際にリリースするにあたって行うであろうことのひとつに、最新のスナップショットのアーカイブを作るという作業があります。Git を使っていないというかわいそうな人たちにもコードを提供するために。その際に使用するコマンドは <code>git archive</code> です。</p>

<pre><code>$ git archive master --prefix=&#39;project/&#39; | gzip &gt; `git describe master`.tar.gz
$ ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz</code></pre>

<p>tarball を開けば、プロジェクトのディレクトリの下に最新のスナップショットが得られます。まったく同じ方法で zip アーカイブを作成することもできます。この場合は <code>git archive</code> で <code>--format=zip</code> オプションを指定します。</p>

<pre><code>$ git archive master --prefix=&#39;project/&#39; --format=zip &gt; `git describe master`.zip</code></pre>

<p>これで、あなたのプロジェクトのリリース用にすてきな tarball と zip アーカイブができあがりました。これをウェブサイトにアップロードするなりメールで送ってあげるなりしましょう。</p>

<h3 id='id124'>短いログ</h3>

<p>そろそろメーリングリストにメールを送り、プロジェクトに何が起こったのかをみんなに知らせてあげましょう。前回のリリースから何が変わったのかの変更履歴を手軽に取得するには <code>git shortlog</code> コマンドを使います。これは、指定した範囲のすべてのコミットのまとめを出力します。たとえば、直近のリリースの名前が v1.0.1 だった場合は、次のようにすると前回のリリース以降のすべてのコミットの概要が得られます。</p>

<pre><code>$ git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (8):
      Add support for annotated tags to Grit::Tag
      Add packed-refs annotated tag support.
      Add Grit::Commit#to_patch
      Update version and History.txt
      Remove stray `puts`
      Make ls_tree ignore nils

Tom Preston-Werner (4):
      fix dates in history
      dynamic version method
      Version bump to 1.0.2
      Regenerated gemspec for version 1.0.2</code></pre>

<p>v1.0.1 以降のすべてのコミットの概要が、作者別にまとめて得られました。これをメーリングリストに投稿するといいでしょう。</p>

<div id='nav'>
<a href='ch5-2.html'>prev</a> | <a href='ch5-4.html'>next</a>
</div>