---
layout: translation
title: Pro Git 3.4 Les branches avec Git Travailler avec les branches
---
<h2 id='travailler_avec_les_branches'>Travailler avec les branches</h2>

<p>Après avoir acquis les bases pour brancher et fusionner, que pouvons-nous ou devons-nous en faire ? Ce chapitre traite des différents styles de développement que cette gestion de branche légère permet de mettre en place, pour vous aider à décider d&#8217;en incorporer une dans votre cycle de développement.</p>

<h3 id='branches_au_long_cours'>Branches au long cours</h3>

<p>Comme Git utilise une fusion à 3 branches, fusionner une branche dans une autre plusieurs fois sur une longue période est généralement facile. Cela signifie que vous pouvez travailler sur plusieurs branches ouvertes en permanence pendant plusieurs étapes de votre cycle de développement ; vous pouvez fusionner régulièrement certaines dans d&#8217;autres.</p>

<p>De nombreux développeurs utilisent Git avec une méthode qui utilise cette approche, telle que n&#8217;avoir que du code entièrement stable et testé dans la branche <code>master</code>, voire du code qui a été ou sera publié. Ils ont une autre branche en parallèle appelée develop qui, lorsqu&#8217;elle devient stable, peut être fusionnée dans <code>master</code>. Cette branche est utilisée pour tirer des branches spécifiques (branches avec une faible durée de vie, telles que notre branche <code>prob53</code>) quand elles sont prêtes, s&#8217;assurer qu&#8217;elles passent tous les tests et n&#8217;introduisent pas de bugs.</p>

<p>En réalité, nous parlons de pointeurs qui se déplacent le long des lignes des commits réalisés. Les branches stables sont plus en profondeur dans la ligne de l&#8217;historique des commits tandis que les branches des derniers développements sont plus en hauteur dans l&#8217;historique (voir figure 3-18).</p>

<p><center><img src="/figures/ch3/18333fig0318-tn.png"></center><br/> Figure 3-18. Les branches les plus stables sont généralement plus bas dans l&#8217;historique des commits.</p>

<p>C&#8217;est généralement plus simple d&#8217;y penser en terme de silos de tâches, où un ensemble de commits évolue vers un silo plus stable quand il a été complètement testé (voir figure 3-19).</p>

<p><center><img src="/figures/ch3/18333fig0319-tn.png"></center><br/> Figure 3-19. Représentation des branches comme des silos.</p>

<p>Vous pouvez reproduire ce schéma sur plusieurs niveaux de stabilité. Des projets plus gros ont aussi une branche <code>proposed</code> ou <code>pu</code> (proposed updates) qui permet d&#8217;intégrer des branches qui ne sont pas encore prêtes pour la prochaine version ou pour <code>master</code>. L&#8217;idée reste que les branches évoluent à différents niveaux de stabilité ; quand elles atteignent un niveau plus stable, elles peuvent être fusionnées dans la branche de stabilité supérieure. Une fois encore, les branches au long cours ne sont pas nécessaires, mais s&#8217;avèrent souvent utiles, spécialement dans le cadre de projets gros ou complexes.</p>

<h3 id='les_branches_de_sujet'>Les branches de sujet</h3>

<p>Les branches de sujet sont tout de même utiles quelle que soit la taille du projet. Une branche de sujet est une branche de courte durée de vie créée et utilisée pour une fonctionnalité ou une tâche particulière. C&#8217;est une manière d&#8217;opérer que vous n&#8217;avez vraisemblablement jamais utilisée avec un autre VCS parce qu&#8217;il est généralement trop lourd de créer et fusionner des branches. Mais dans Git, créer, développer, fusionner et effacer des branches plusieurs fois par jour est monnaie courante.</p>

<p>Vous l&#8217;avez remarqué dans la section précédent avec les branches <code>prob53</code> et <code>correctif</code> que vous avez créées. Vous avez réalisé quelques validations sur elles et vous les avez effacées juste après les avoir fusionnées dans votre branche principale. Cette technique vous permet de basculer de contexte complètement et immédiatement. Il est beaucoup plus simple de réaliser des revues de code parce que votre travail est isolé dans des silos où toutes les modifications sont liées au sujet . Vous pouvez entreposer vos modifications ici pendant des minutes, des jours ou des mois, puis les fusionner quand elles sont prêtes, indépendamment de l&#8217;ordre dans lequel elles ont été créées ou de développées.</p>

<p>Supposons un exemple où pendant un travail (sur <code>master</code>), vous branchiez pour un problème (<code>prob91</code>), travaillez un peu dessus, vous branchiez une seconde branche pour essayer de trouver une autre manière de le résoudre (<code>prob91v2</code>), vous retourniez sur la branche <code>master</code> pour y travailler pendant un moment pour finalement brancher sur un dernière branche (<code>ideeidiote</code>) pour laquelle vous n&#8217;êtes pas sûr que ce soit une bonne idée. Votre historique de commit pourrait ressembler à la figure 3-20.</p>

<p><center><img src="/figures/ch3/18333fig0320-tn.png"></center><br/> Figure 3-20. Votre historique de commit avec de multiples branches de sujet.</p>

<p>Maintenant, supposons que vous décidiez que vous préférez la seconde solution pour le problème (<code>prob91v2</code>) et que vous ayez montré la branche <code>ideeidiote</code> à vos collègues qui vous ont dit qu&#8217;elle était géniale. Vous pouvez jeter la branche <code>prob91</code> originale (en effaçant les commits C5 et C6) et fusionner les deux autres. Votre historique ressemble à présent à la figure 3-21.</p>

<p><center><img src="/figures/ch3/18333fig0321-tn.png"></center><br/> Figure 3-21. Votre historique après la fusion de <code>ideeidiote</code> et <code>prob91v2</code>.</p>

<p>Souvenez-vous que lors de la réalisation de ces actions, toutes ces branches sont complètement locales. Lorsque vous branchez et fusionnez, tout est réalisé dans votre dépôt Git. Aucune communication avec un serveur n&#8217;a lieu.</p>

<div id='nav'>
<a href='ch3-3.html'>prev</a> | <a href='ch3-5.html'>next</a>
</div>