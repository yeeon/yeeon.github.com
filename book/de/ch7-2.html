---
layout: translation
title: Pro Git 7.2 Customizing Git Git Konfiguration
---
<h2 id='git_konfiguration'>Git Konfiguration</h2>

<p>Wie Du in Kapitel 1 kurz gesehen hast, kann man die Konfiguration von Git mit dem Befehl <code>git config</code> steuern. Eine Deiner ersten Aktionen war es, Deinen Namen und Deine e-mail Adresse anzugeben:</p>

<p>As you briefly saw in the Chapter 1, you can specify Git configuration settings with the <code>git config</code> command. One of the first things you did was set up your name and e-mail address:</p>

<pre><code>$ git config --global user.name &quot;John Doe&quot;
$ git config --global user.email johndoe@example.com</code></pre>

<p>Jetzt wirst Du einige weitere, interessantere Optionen lernen, die Du genauso benutzen kannst, um Git Deiner Arbeitsumgebung anzupassen.</p>

<p>Now you’ll learn a few of the more interesting options that you can set in this manner to customize your Git usage.</p>

<p>In Kapitel 1 hast Du bereits einige einfache Konfigurationsdetails von Git kennengelernt, aber ich möchte sie hier noch einmal schnell wiederholen. Git benutzt eine Reihe von Konfigurationsdateien, um nicht-Standard Verhalten zu kontrollieren, an dem Du interessiert sein könntest. Der erste Ort, an dem Git danach sucht ist in der Datei <code>/etc/gitconfig</code>. Diese Datei enthält Werte fuer alle Benutzer des Systems und alle ihre Repositories. Wenn Du <code>git config</code> mit der Option <code>--system</code> benutzt, liest und schreibt Git speziell in dieser Datei.</p>

<p>You saw some simple Git configuration details in the first chapter, but I’ll go over them again quickly here. Git uses a series of configuration files to determine non-default behavior that you may want. The first place Git looks for these values is in an <code>/etc/gitconfig</code> file, which contains values for every user on the system and all of their repositories. If you pass the option <code>--system</code> to <code>git config</code>, it reads and writes from this file specifically.</p>

<p>Als nächstes sucht Git in der benutzerspezifischen Datei <code>~/.gitconfig</code> nach Kofigurationsdaten. Damit Git diese Date zum Lesen und Schreiben nutzt, kannst Du die Option <code>--global</code> benutzen.</p>

<p>The next place Git looks is the <code>~/.gitconfig</code> file, which is specific to each user. You can make Git read and write to this file by passing the <code>--global</code> option.</p>

<p>Als letztes sucht Git in der Konfigurationsdatei im Git Verzeichnis (<code>.git/config</code>) des aktuell benutzten Repositories nach Konfigurationsdaten. Diese Daten sind dann speziell fuer dieses Repository gueltig. Jede der erwähnten Ebenen ueberschreibt die vorhergehende, das heisst also das zum Beispiel die Konfiguration aus <code>.git/config</code> Vorrang vor derjenigen aus <code>/etc/gitconfig</code> hat. Du kannst alle Konfigurationen auch surch manuelles Editieren dieser Dateien mit der korrekten Syntax vornehmen, aber in der Regel ist es einfacher den Befehl <code>git config</code> zu benutzen.</p>

<p>Finally, Git looks for configuration values in the config file in the Git directory (<code>.git/config</code>) of whatever repository you’re currently using. These values are specific to that single repository. Each level overwrites values in the previous level, so values in <code>.git/config</code> trump those in <code>/etc/gitconfig</code>, for instance. You can also set these values by manually editing the file and inserting the correct syntax, but it’s generally easier to run the <code>git config</code> command.</p>

<h3 id='basic_client_configuration'>Basic Client Configuration</h3>

<h3 id='grundlegende_client_konfiguration'>Grundlegende Client Konfiguration</h3>

<p>Die von Git verwendeten Konfigurationsoptionen teilen sich in zwei Kategorien: den Client und den Server. Der Grossteil der Optionen beziehen sich auf den Client — zur Konfiguration Deines persönlichen Arbeitsflusses. Auch wenn es eine grosse Menge an Optionen gibt werde ich nur die wenigen besprechen, die sehr gebräuchlich sind oder die Deine Arbeitsweise bedeutend beeinflussen können. Viele Optionen sind nur fuer Spezialfälle nuetzlich, die ich hier nicht auffuehren werde. Falls Du eine Liste aller Optionen sehen willst, fuehre den folgenden Befehl aus</p>

<p>The configuration options recognized by Git fall into two categories: client side and server side. The majority of the options are client side—configuring your personal working preferences. Although tons of options are available, I’ll only cover the few that either are commonly used or can significantly affect your workflow. Many options are useful only in edge cases that I won’t go over here. If you want to see a list of all the options your version of Git recognizes, you can run</p>

<pre><code>$ git config --help</code></pre>

<p>Die Hilfeseite zu <code>git config</code> listet alle möglichen Optionen sehr detailiert auf.</p>

<p>The manual page for <code>git config</code> lists all the available options in quite a bit of detail.</p>

<h4 id='coreeditor'>core.editor</h4>

<p>In der Grundeinstellung benutzt Git Deinen Standard Texteditor oder greift auf den Vi Editor zurueck, um Deine Commit und Tag Nachrichten zu editieren. Um einen andern Editor als Standard einzurichten kannst Du die Option <code>core.editor</code> benutzen:</p>

<p>By default, Git uses whatever you’ve set as your default text editor or else falls back to the Vi editor to create and edit your commit and tag messages. To change that default to something else, you can use the <code>core.editor</code> setting:</p>

<pre><code>$ git config --global core.editor emacs</code></pre>

<p>Hiermit wird Git nun immer unabhängig von Deinem Standard Shell-Editor Emacs starten, um Nachrichten zu editieren.</p>

<p>Now, no matter what is set as your default shell editor variable, Git will fire up Emacs to edit messages.</p>

<h4 id='committemplate'>commit.template</h4>

<p>Wenn Du diese Einstellung auf einen Pfad zu einer Datei auf Deinem System einstellst, wird Git diese Datei als Standard-Nachricht fuer Deine Commits verwenden. Nehmen wir zum Beispiel an, Du hättest eine Vorlage unter dem Namen <code>$HOME/.gitmessage.txt</code> erstellst, die aussieht wie folgt:</p>

<p>If you set this to the path of a file on your system, Git will use that file as the default message when you commit. For instance, suppose you create a template file at <code>$HOME/.gitmessage.txt</code> that looks like this:</p>

<pre><code>subject line

what happened

[ticket: X]</code></pre>

<p>Damit Git nun diese Datei als Standard-Nachricht benutzt, die in Deinem Editor erscheint, wenn Du <code>git commit</code> aufrufst, richte die Option <code>commit.template</code> ein:</p>

<p>To tell Git to use it as the default message that appears in your editor when you run <code>git commit</code>, set the <code>commit.template</code> configuration value:</p>

<pre><code>$ git config --global commit.template $HOME/.gitmessage.txt
$ git commit</code></pre>

<p>Wenn Du dann das nächste Mal ein Commit ausfuehrst, wird Dein Editor mit etwas ähnlichem wie dieser Nachricht starten: Then, your editor will open to something like this for your placeholder commit message when you commit:</p>

<pre><code>subject line

what happened

[ticket: X]
# Please enter the commit message for your changes. Lines starting
# with &#39;#&#39; will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
# modified:   lib/test.rb
#
~
~
&quot;.git/COMMIT_EDITMSG&quot; 14L, 297C</code></pre>

<p>Falls Du eine Richtlinie fuer Commit Nachrichten hast, erhöht es die Chance, dass diese Richtlinie auch eingehalten wird, wenn Du dazu eine Vorlage erstellst und Git so konfigurierst, dass sie als Standard geladen wird.</p>

<p>If you have a commit-message policy in place, then putting a template for that policy on your system and configuring Git to use it by default can help increase the chance of that policy being followed regularly.</p>

<h4 id='corepager'>core.pager</h4>

<p>Die Einstellung <code>core.pager</code> legt fest, welche Anwendung zur Seitenanzeige benutzt wird, wenn Git Text ausgib, wie zum Beispiel bei <code>log</code> und <code>diff</code>. Du kannst es zum Beispiel auf <code>more</code> einstellen oder eine andere Seitenznzeige Deiner Wahl (der Standard ist <code>less</code>), oder Du kannst es mittels eines leeren Strings ganz ausschalten:</p>

<p>The core.pager setting determines what pager is used when Git pages output such as <code>log</code> and <code>diff</code>. You can set it to <code>more</code> or to your favorite pager (by default, it’s <code>less</code>), or you can turn it off by setting it to a blank string:</p>

<pre><code>$ git config --global core.pager &#39;&#39;</code></pre>

<p>Wenn Du dies ausfuehrst wird Git immer die komplette Ausgabe aller Befehle anzeigen, egal wie lang sie ist.</p>

<p>If you run that, Git will page the entire output of all commands, no matter how long they are.</p>

<h4 id='usersigningkey'>user.signingkey</h4>

<p>Falls Du signierte annotierte Tags erstellst (wie in Kapitel 2 diskutiert) so macht es die Arbeit leichter, wenn Du Deinen GPG Signier-Schluessel als Konfiguration einstellst. Du kannst Deine Schluessel ID wie folgt festlegen:</p>

<p>If you’re making signed annotated tags (as discussed in Chapter 2), setting your GPG signing key as a configuration setting makes things easier. Set your key ID like so:</p>

<pre><code>$ git config --global user.signingkey &lt;gpg-key-id&gt;</code></pre>

<p>Jetzt kannst Du Tags signieren, ohne Deinen Schluessel bei jedem <code>git tag</code> angeben zu muessen:</p>

<p>Now, you can sign tags without having to specify your key every time with the <code>git tag</code> command:</p>

<pre><code>$ git tag -s &lt;tag-name&gt;</code></pre>

<h4 id='coreexcludesfile'>core.excludesfile</h4>

<p>Du kannst Muster in der <code>.gitignore</code> Datei Deines Projektes einrichten, damit Git passende Dateien ignoriert und nicht als nicht-verfolgte Dateien ansieht oder versucht, sie zu Stagen, wenn Du fuer sie ein <code>git add</code> ausfuehrst, wie in Kapitel 2 besprochen. Falls Du jedoch eine andere Datei ausserhalb des Projektes hast, die diese Werte enthält, oder zusätzliche Muster definiert, dann kannst Du Git mit der Option <code>core.excludesfile</code> mitteilen, wo diese Datei zu finden ist. Stelle hier einfach den Pfad zu einer Datei ein, die Einträge enthält, welche denen in <code>.gitignore</code> entsprechen.</p>

<p>You can put patterns in your project’s <code>.gitignore</code> file to have Git not see them as untracked files or try to stage them when you run <code>git add</code> on them, as discussed in Chapter 2. However, if you want another file outside of your project to hold those values or have extra values, you can tell Git where that file is with the <code>core.excludesfile</code> setting. Simply set it to the path of a file that has content similar to what a <code>.gitignore</code> file would have.</p>

<h4 id='helpautocorrect'>help.autocorrect</h4>

<p>Diese Option ist nur in Git 1.6.1 und neueren Versionen verfuegbar. Wenn Du in Git 1.6 einen Befehl falsch schreibst, bekommst Du eine Meldung wie diese:</p>

<p>This option is available only in Git 1.6.1 and later. If you mistype a command in Git 1.6, it shows you something like this:</p>

<pre><code>$ git com
git: &#39;com&#39; is not a git-command. See &#39;git --help&#39;.

Did you mean this?
     commit</code></pre>

<p>Wenn Du auf 1 setzt wird Git den vorgeschlagenen Befehl automatisch ausfuehren, falls es in dieser Situation die einzige passende Alternative ist.</p>

<p>If you set <code>help.autocorrect</code> to 1, Git will automatically run the command if it has only one match under this scenario.</p>

<h3 id='colors_in_git'>Colors in Git</h3>

<p>Git kann fuer die Textanzeige im Terminal Farben benuutzen, die Dir helfen können, die Ausgabe schnell und einfach zu Ueberfliegen. Mit einer Anzahl Optionen kannst Du die Farben an Deine Vorlieben anpassen.</p>

<p>Git can color its output to your terminal, which can help you visually parse the output quickly and easily. A number of options can help you set the coloring to your preference.</p>

<h4 id='colorui'>color.ui</h4>

<p>Wenn Du Git entsprechend anweist, wird es den Grossteil der Ausgaben automatisch farblich darstellen. Du kannst sehr detailiert einstellen, wofuer Git Farben verwendet und welche; aber um alle Standard Terminalfarben zu aktivieren, setze <code>color.ui</code> auf &#8216;true&#8217;:</p>

<p>Git automatically colors most of its output if you ask it to. You can get very specific about what you want colored and how; but to turn on all the default terminal coloring, set <code>color.ui</code> to true:</p>

<pre><code>$ git config --global color.ui true</code></pre>

<p>Wenn dieser Wert gesetzt wurde benutzt Git fuer seine Ausgaben Farben, sofern diese zu einem Terminal geleitet werden. Weitere mögliche Einstellungen sind &#8216;false&#8217;, wodurch alle Farben deaktiviert werden, sowie &#8216;always&#8217;, wodurch Farben immer aktiviert sind, slebst wenn Du Git Befehle in eine Datei umleitest oder ueber eine Pipe zu einem anderen Befehl umleitest. Diese Option wurde in Git 1.5.5 hinzugefuegt. Solltest Du eine ältere Git Version benutzen, so musst Du alle Farbeinstellungen einzeln vornehmen.</p>

<p>When that value is set, Git colors its output if the output goes to a terminal. Other possible settings are false, which never colors the output, and always, which sets colors all the time, even if you’re redirecting Git commands to a file or piping them to another command. This setting was added in Git version 1.5.5; if you have an older version, you’ll have to specify all the color settings individually.</p>

<p>Du wirst selten die Einstellung <code>color.ui = always</code> benötigen. In den meisten Situationen in denen Du Farben in Deiner umgeleiteten Ausgabe haben willst, kannst Du stattdessen die Option <code>--color</code> auf der Kommandozeile benutzen, um Git anzuweisen die Farbkodierung fuer die Ausgabe zu verwenden. Die Einstellung sollte fast immer das sein, was Du benutzen willst.</p>

<p>You’ll rarely want <code>color.ui = always</code>. In most scenarios, if you want color codes in your redirected output, you can instead pass a <code>--color</code> flag to the Git command to force it to use color codes. The <code>color.ui = true</code> setting is almost always what you’ll want to use.</p>

<h4 id='id5'><code>color.*</code></h4>

<p>Falls Du im Detail kontrollieren willst welche Befehle wie gefärbt werden, oder wenn Du eine ältere Version benutzt, dann stellt Git Verb-spezifische Farbeinstellungen zur Verfuegung. Jede dieser Optionen kann auf <code>true</code>, <code>false</code>, oder <code>always</code> eingestellt werden:</p>

<p>If you want to be more specific about which commands are colored and how, or you have an older version, Git provides verb-specific coloring settings. Each of these can be set to <code>true</code>, <code>false</code>, or <code>always</code>:</p>

<pre><code>color.branch
color.diff
color.interactive
color.status</code></pre>

<p>Jede von diesen hat zusätzliche Unteroptionen, die Du benutzen kannst, um spezifische Farben fuer Telie der Ausgabe einzustellen, falls Du jede Farbe zu ueberschreiben. Um zum Beispiel die Meta Informationen in Deiner Diff Ausgabe mit blauem Text auf schwarzem Hintergrund in Fettschrift darstellen willst, kannst Du folgenden Befehl ausfuehren:</p>

<p>In addition, each of these has subsettings you can use to set specific colors for parts of the output, if you want to override each color. For example, to set the meta information in your diff output to blue foreground, black background, and bold text, you can run</p>

<pre><code>$ git config --global color.diff.meta “blue black bold”</code></pre>

<p>Du kannst als Farben jeden der folgenden Werte verwenden: <code>normal</code>, <code>black</code>, <code>red</code>, <code>green</code>, <code>yellow</code>, <code>blue</code>, <code>magenta</code>, <code>cyan</code>, oder <code>white</code>. Falls Du ein Attribute wie Fettschrift im vorigen Beispiel willst kannst Du aus <code>bold</code>, <code>dim</code>, <code>ul</code>, <code>blink</code>, und <code>reverse</code> auswählen.</p>

<p>You can set the color to any of the following values: normal, black, red, green, yellow, blue, magenta, cyan, or white. If you want an attribute like bold in the previous example, you can choose from bold, dim, ul, blink, and reverse.</p>

<p>Auf der Manpage zu <code>git config</code> findest Du eine Liste aller Unteroptionen, die Du konfigurieren kannst, falls Du das tun möchtest. See the <code>git config</code> manpage for all the subsettings you can configure, if you want to do that.</p>

<h3 id='external_merge_and_diff_tools'>External Merge and Diff Tools</h3>

<p>Git besitzt zwar eine interne Implementierung von diff, das Du bisher benutzt hast, aber Du kannst stattdessen auch eine externe Anwendung benutzen. Du kannst auch ein grafisches Merge Werkzeug zur Auflösung von Konflikten benutzen, statt diese manuell zu lösen. Ich werde demonstrieren, wie man das visuelle Merge Tool von Perforce (P4Merge) installiert, um Diffs und Merges zu bearbeiten. Ich habe P4Merge gewählt, da es ein freies und nettes grafisches Werkzeug ist.</p>

<p>Although Git has an internal implementation of diff, which is what you’ve been using, you can set up an external tool instead. You can also set up a graphical merge conflict–resolution tool instead of having to resolve conflicts manually. I’ll demonstrate setting up the Perforce Visual Merge Tool (P4Merge) to do your diffs and merge resolutions, because it’s a nice graphical tool and it’s free.</p>

<p>Falls Du dies testen willst, sollte es kein Problem sein, da P4Merge auf allen ueblichen Plattformen arbeitet. Ich werde Pfadnamen benutzen, die auf Mac und Linux Systemen funktionieren; fuer Windows musst Du <code>/usr/local/bin</code> durch einen Pfad ersetzen, der in der Umgebungsvariablen <code>PATH</code> gelistet ist.</p>

<p>If you want to try this out, P4Merge works on all major platforms, so you should be able to do so. I’ll use path names in the examples that work on Mac and Linux systems; for Windows, you’ll have to change <code>/usr/local/bin</code> to an executable path in your environment.</p>

<p>Du kannst P4Merge hier herunterladen:</p>

<p>You can download P4Merge here:</p>

<pre><code>http://www.perforce.com/perforce/downloads/component.html</code></pre>

<p>Als erstes solltes Du einige Wrapper (????) Skripten erstellen, um Deine Befehle auszufuehren. Ich benutze den Mac Pfad fuer die ausfuehrbare Datei; auf anderen Systemen ist dies der Ort, an dem die <code>p4merge</code> Binärdatei installiert ist. Erstelle ein Skript namens <code>extMerge</code>, das die Binärdatei mit allen angegebenen Argumenten aufruft:</p>

<p>To begin, you’ll set up external wrapper scripts to run your commands. I’ll use the Mac path for the executable; in other systems, it will be where your <code>p4merge</code> binary is installed. Set up a merge wrapper script named <code>extMerge</code> that calls your binary with all the arguments provided:</p>

<pre><code>$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/p4merge.app/Contents/MacOS/p4merge $*</code></pre>

<p>Der Diff Wrapper (????) stellt sicher, dass es mit sieben Parametern aufgerufen wird und gibt dann zwei davon an das Merge Skript weiter. Standardmässig uebergibt Git die folgenden Argumente an das diff Programm:</p>

<p>The diff wrapper checks to make sure seven arguments are provided and passes two of them to your merge script. By default, Git passes the following arguments to the diff program:</p>

<pre><code>path old-file old-hex old-mode new-file new-hex new-mode</code></pre>

<p>Da Du nur die Parameter <code>old-file</code> und <code>new-file</code> benötigst, wirst Du das Wrapper Skript benutzen, um nur die notwendigen weiterzugeben.</p>

<p>Because you only want the <code>old-file</code> and <code>new-file</code> arguments, you use the wrapper script to pass the ones you need.</p>

<pre><code>$ cat /usr/local/bin/extDiff 
#!/bin/sh
[ $# -eq 7 ] &amp;&amp; /usr/local/bin/extMerge &quot;$2&quot; &quot;$5&quot;</code></pre>

<p>Du musst ausserdem sicherstellen, dass die Skripten ausfuehrbar sind:</p>

<p>You also need to make sure these tools are executable:</p>

<pre><code>$ sudo chmod +x /usr/local/bin/extMerge 
$ sudo chmod +x /usr/local/bin/extDiff</code></pre>

<p>Jetzt kannst Du Git so konfigurieren, dass es deine persönlichen Merge und Diff Werkzeuge benutzt. Dazu sind einige angepasste Einstellungen nötig: <code>merge.tool</code>, um Git zu sagen welche Merge Strategie es nutzen soll, <code>mergetool.*.cmd</code>, um festzulegen, wie der Befehl auszufuehren ist, <code>mergetool.trustExitCode</code>, damit Git weiss ob der Antwortcode des Programms eine erfolgreiche Merge Auflösung anzeigt oder nicht, und <code>diff.external</code>, um einzustellen welches Diff Kommando Git benutzen soll. Also kannst Du entweder vier Konfigrationsbefehle ausfuehren</p>

<p>Now you can set up your config file to use your custom merge resolution and diff tools. This takes a number of custom settings: <code>merge.tool</code> to tell Git what strategy to use, <code>mergetool.*.cmd</code> to specify how to run the command, <code>mergetool.trustExitCode</code> to tell Git if the exit code of that program indicates a successful merge resolution or not, and <code>diff.external</code> to tell Git what command to run for diffs. So, you can either run four config commands</p>

<pre><code>$ git config --global merge.tool extMerge
$ git config --global mergetool.extMerge.cmd \
    &#39;extMerge &quot;$BASE&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot; &quot;$MERGED&quot;&#39;
$ git config --global mergetool.trustExitCode false
$ git config --global diff.external extDiff</code></pre>

<p>oder Du editierst Deine <code>~/.gitconfig</code> Datei und fuegst dort folgende Zeilen hinzu:</p>

<p>or you can edit your <code>~/.gitconfig</code> file to add these lines:</p>

<pre><code>[merge]
  tool = extMerge
[mergetool &quot;extMerge&quot;]
  cmd = extMerge &quot;$BASE&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot; &quot;$MERGED&quot;
  trustExitCode = false
[diff]
  external = extDiff</code></pre>

<p>Wenn all dies eingestellt ist und Du Diff Befehle wie diesen ausfuehrst:</p>

<p>After all this is set, if you run diff commands such as this:</p>

<pre><code>$ git diff 32d1776b1^ 32d1776b1</code></pre>

<p>wird Git statt einer Diff Ausgabe auf der Kommandozeile P4Merge starten, was ähnlich aussehen wird wie Abbildung 7-1.</p>

<p>Instead of getting the diff output on the command line, Git fires up P4Merge, which looks something like Figure 7-1.</p>

<p><center><img src="/figures/ch7/18333fig0701-tn.png"></center><br/> Figure 7-1. P4Merge.</p>

<p>Wenn Du versuchst zwei Branches zu Mergen und darauffolgende Merge Konflikte hast, kannst Du den Befehl <code>git mergetool</code> ausfuehren; das startet P4Merge und erlaubt Dir, die Konflikte mit dem GUI Werkzeug aufzulösen.</p>

<p>If you try to merge two branches and subsequently have merge conflicts, you can run the command <code>git mergetool</code>; it starts P4Merge to let you resolve the conflicts through that GUI tool.</p>

<p>Das Angenehme an diesem Wrapper Ansatz ist, dass Du Deine Diff und Merge Werkzeuge sehr leicht ändern kannst. Wenn Du zum Beispiel Deine <code>extDiff</code> und <code>extMerge</code> Programme ändern möchtest, um stattdessen KDiff3 zu benutzen, musst Du lediglich Dein <code>extMerge</code> Datei ändern:</p>

<p>The nice thing about this wrapper setup is that you can change your diff and merge tools easily. For example, to change your <code>extDiff</code> and <code>extMerge</code> tools to run the KDiff3 tool instead, all you have to do is edit your <code>extMerge</code> file:</p>

<pre><code>$ cat /usr/local/bin/extMerge
#!/bin/sh	
/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*</code></pre>

<p>Nun wird Git KDiff3 zur Anzeige von Diffs und zur Auflösung von Merge Konflikten verwenden.</p>

<p>Now, Git will use the KDiff3 tool for diff viewing and merge conflict resolution.</p>

<p>Git hat Voreinstellungen, um einige andere Merge-Auflösungswerkzeuge zu verwenden, ohne dass Du die Kommando Konfiguration einstellen musst. Du kannst Dein Merge Werkzeug auf kdiff3, opendiff, tkdiff, meld, xxdiff, emerge, vimdiff, oder gvimdiff einstellen. Wenn Du zum Beispiel nicht daran interessiert bist KDiff3 fuer Diffs zu verwenden, sondern nur zur Auflösung von Merge Konflikten, dann kannst Du den folgenden Befehl ausfuehren, wenn sich kdiff3 im Pfad befindet</p>

<p>Git comes preset to use a number of other merge-resolution tools without your having to set up the cmd configuration. You can set your merge tool to kdiff3, opendiff, tkdiff, meld, xxdiff, emerge, vimdiff, or gvimdiff. If you’re not interested in using KDiff3 for diff but rather want to use it just for merge resolution, and the kdiff3 command is in your path, then you can run</p>

<pre><code>$ git config --global merge.tool kdiff3</code></pre>

<p>Wenn Du diesen Befehl ausfuehrst statt die <code>extMerge</code> und <code>extDiff</code> Dateien zu erstellen, dann wird Git KDiff3 fuer Merge Auflösungen verwenden, und das normale Git Diff Werkzeug fuer Diffs.</p>

<p>If you run this instead of setting up the <code>extMerge</code> and <code>extDiff</code> files, Git will use KDiff3 for merge resolution and the normal Git diff tool for diffs.</p>

<h3 id='formatting_and_whitespace'>Formatting and Whitespace</h3>

<h3 id='formatierung_und_fuellzeichen'>Formatierung und Fuellzeichen</h3>

<p>Formatierungen und Fuellzeichen &#8211; also Tabulatorzeichen, Leerzeichen und Steuerzeichen fuer Zeilenwechsel (LF) und Zeilen- oder Wagenruecklauf (CR) &#8211; fuehren zu einigen der frustrierendsten und subtilsten Probleme denen viele Entwickler begegnen, wenn sie mit anderen zusammenarbeiten, speziell ueber Plattformgrenzen hinweg. Es kann sehr leicht passieren, dass bei Patches oder anderer gemeinsamer Arbeit kaum merklich Fuellzeichen hinzugefuegt werden, sei es weil ein Entwickler sie unnwissentlich einfuegt, oder weil ein Windows Programmierer bei plattformuebergreifenden Projekten einen Zeilenruecklauf am Zeilenende von Dateien anfuegt. Git hat einige Konfigurationseinstellungen die bei diesen Problemen helfen.</p>

<p>Formatting and whitespace issues are some of the more frustrating and subtle problems that many developers encounter when collaborating, especially cross-platform. It’s very easy for patches or other collaborated work to introduce subtle whitespace changes because editors silently introduce them or Windows programmers add carriage returns at the end of lines they touch in cross-platform projects. Git has a few configuration options to help with these issues.</p>

<h4 id='coreautocrlf'>core.autocrlf</h4>

<p>Falls Du unter Windows programmierst oder ein anderes System benutzt und mit anderen zusammenarbeitest, die unter Windows programmieren, wirst Du sehr wahrscheinlich irgendwann dem Problem der Zeilenenden begegnen. Dies liegt daran, dass Windows sowohl ein CR-Zeichen als auch ein LF-Zeichen zum Signalisieren einer neuen Zeile in einer Datei benutzt, während Mac und Linux nur ein LF-Zeichen benutzen. Dies ist eine kleine aber extrem störende Tatsache beim Arbeiten ueber Plattformgrenzen hinweg.</p>

<p>If you’re programming on Windows or using another system but working with people who are programming on Windows, you’ll probably run into line-ending issues at some point. This is because Windows uses both a carriage-return character and a linefeed character for newlines in its files, whereas Mac and Linux systems use only the linefeed character. This is a subtle but incredibly annoying fact of cross-platform work.</p>

<p>Git kann dies vermeiden, indem es CR-LF Zeichen am Zeilenende automatisch zu LF konvertiert, wenn Du ein Commit machst, und umgekehrt wenn es bei einem Checkout Code mit Deinem lokalen Dateisystem synchronisiert. Du kannst diese Funktionalität mittels der Option <code>core.autocrlf</code> aktivieren. Falls Du auf einem Windows System arbeitest, setze sie auf <code>true</code> — dies konvertiert LF Zeichen zu CRLF Zeichen, wenn Du Code mit einem Checkout synchronisierst:</p>

<p>Git can handle this by auto-converting CRLF line endings into LF when you commit, and vice versa when it checks out code onto your filesystem. You can turn on this functionality with the <code>core.autocrlf</code> setting. If you’re on a Windows machine, set it to <code>true</code> — this converts LF endings into CRLF when you check out code:</p>

<pre><code>$ git config --global core.autocrlf true</code></pre>

<p>Falls Du auf einem Linux oder Mac System arbeitest, das LF Zeilenenden benutzt, dann soll Git keine Dateien automatisch konvertieren, wenn sie per Checkout vom Server kommen; wenn allerdings versehentlich eine Datei mit CR-LF Zeichen auf Dein System gelangt, dann möchtest Du vielleicht, dass Git es fuer Dich repariert. Du kannst Git anweisen CR-LF automatisch in LF Zeichen umzuwandeln, wenn Du ein Commit machst, aber nicht in der anderen Richtung, indem Du <code>core.autocrlf</code> auf input setzt:</p>

<p>If you’re on a Linux or Mac system that uses LF line endings, then you don’t want Git to automatically convert them when you check out files; however, if a file with CRLF endings accidentally gets introduced, then you may want Git to fix it. You can tell Git to convert CRLF to LF on commit but not the other way around by setting <code>core.autocrlf</code> to input:</p>

<pre><code>$ git config --global core.autocrlf input</code></pre>

<p>Mit dieser Einstellung solltest Du CR-LF Zeilenenden bei Dateien haben, die auf Windows synchronisiert wurden, und mit LF Zeilenenden auf Mac und Linux Sytemen und im Repository.</p>

<p>This setup should leave you with CRLF endings in Windows checkouts but LF endings on Mac and Linux systems and in the repository.</p>

<p>Falls Du ein Windows Programmierer bist, mit einem Projekt, dass nur unter Windows entwickelt wird, dann kannst Du diese Funktionalität deaktivieren, so dass die CR Zeilenenden im Repository gespeichert werden. Dazu setzt Du diese Option auf <code>false</code>:</p>

<p>If you’re a Windows programmer doing a Windows-only project, then you can turn off this functionality, recording the carriage returns in the repository by setting the config value to <code>false</code>:</p>

<pre><code>$ git config --global core.autocrlf false</code></pre>

<h4 id='corewhitespace'>core.whitespace</h4>

<p>Git ist so voreingestellt, dass es einige Leerzeichen Probleme erkennen und beheben kann. Es kann nach vier vorrangigen Problemen mit Leerzeichen suchen — Zwei davon sind standardmässig aktiviert und kann deaktiviert werden, und zwei sind inaktiv, können aber aktiviert werden.</p>

<p>Git comes preset to detect and fix some whitespace issues. It can look for four primary whitespace issues — two are enabled by default and can be turned off, and two aren’t enabled by default but can be activated.</p>

<p>Die zwei standardmässig aktiven Optionen sind <code>trailing-space</code>, das nach Leerzeichen am Ende einer Zeile sucht, und <code>space-before-tab</code>, das nach Leerzeichen vor Tabulatoren am Anfang einer Zeile sucht.</p>

<p>The two that are turned on by default are <code>trailing-space</code>, which looks for spaces at the end of a line, and <code>space-before-tab</code>, which looks for spaces before tabs at the beginning of a line.</p>

<p>Die beiden aktivierbaren, aber normalerweise deaktivierten Optionen sind <code>indent-with-non-tab</code>, dass nach Zeilen sucht, die mit acht oder mehr Leerzeichen anstelle von Tabulatoren beginnt, und <code>cr-at-eol</code>, wodurch Git angewiesen wird, dass CR Zeichen am Zeilenende in Ordnung sind.</p>

<p>The two that are disabled by default but can be turned on are <code>indent-with-non-tab</code>, which looks for lines that begin with eight or more spaces instead of tabs, and <code>cr-at-eol</code>, which tells Git that carriage returns at the end of lines are OK.</p>

<p>Du kannst Git mitteilen welche dieser Optionen es aktivieren soll, indem Du <code>core.whitespace</code> auf die Werte setzt, durch Kommas getrennt, die Du an- oder abgeschaltet haben möchtest. Du kannst Optionen deaktivieren, indem Du sie entweder aus der Parameterliste weglässt, oder ihnen ein <code>-</code> Zeichen voranstellst. Wenn Du zum Beispiel alle Optionen ausser <code>cr-at-eol</code> aktivieren willst, kannst Du folgendes ausfuehren:</p>

<p>You can tell Git which of these you want enabled by setting <code>core.whitespace</code> to the values you want on or off, separated by commas. You can disable settings by either leaving them out of the setting string or prepending a <code>-</code> in front of the value. For example, if you want all but <code>cr-at-eol</code> to be set, you can do this:</p>

<pre><code>$ git config --global core.whitespace \
    trailing-space,space-before-tab,indent-with-non-tab</code></pre>

<p>Git wird diese möglichen Problemstellen erkennen, wenn Du einen <code>git diff</code> Befehl ausfuehrst, und es wird versuchen, sie farblich hervorzuheben, damit Du sie vor einem Commit beheben kannst. Git wird diese Einstellungen auch benutzen, um Dir zu helfen, wenn Du mit <code>git apply</code> Patches anwendest. Wenn Du Patches ausfuehrst kannst Du Git anweisen eine Warnung auszugeben, falls es beim Patchen die spezifizierten Leerzeichenprobleme erkennt:</p>

<p>Git will detect these issues when you run a <code>git diff</code> command and try to color them so you can possibly fix them before you commit. It will also use these values to help you when you apply patches with <code>git apply</code>. When you’re applying patches, you can ask Git to warn you if it’s applying patches with the specified whitespace issues:</p>

<pre><code>$ git apply --whitespace=warn &lt;patch&gt;</code></pre>

<p>Oder Du kannst Git versuchen lassen, diese Probleme automatisch zu beheben, bevor es den Patch anwendet:</p>

<p>Or you can have Git try to automatically fix the issue before applying the patch:</p>

<pre><code>$ git apply --whitespace=fix &lt;patch&gt;</code></pre>

<p>Diese Optionen sind auch fuer den Rebase Befehl gueltig. Falls Du einen Commit gemacht hast, der problematische Leerzeichen enthält, aber Du die Änderungen noch nicht auf den Server gepusht hast, kannst Du ein <code>rebase</code> mit dem Parameter <code>--whitespace=fix</code> ausfuehren, damit Git automatisch die Leerzeichenfehler behebt, wenn es dir Patches aktualisiert.</p>

<p>These options apply to the git rebase option as well. If you’ve committed whitespace issues but haven’t yet pushed upstream, you can run a <code>rebase</code> with the <code>--whitespace=fix</code> option to have Git automatically fix whitespace issues as it’s rewriting the patches.</p>

<h3 id='server_configuration'>Server Configuration</h3>

<p>Es gibt nicht annähernd so viele Konfigurationsmöglichkeiten fuer die Server Seite von Git, aber es gibt dabei einige interessante, die Du in Betracht ziehen solltest.</p>

<p>Not nearly as many configuration options are available for the server side of Git, but there are a few interesting ones you may want to take note of.</p>

<h4 id='receivefsckobjects'>receive.fsckObjects</h4>

<p>Standardmässig prueft Git nicht alle Objekte auf Konsistenz, die es durch einen Push erhält. Auch wenn Git sicherstellen kann, dass jedes Objekt dessen SHA-1 Checksumme entspricht und auf gueltige Objekte verweist, so wird dies nicht als Standard bei jedem Push ausgefuehrt. Dies ist eine sehr kostspielige Operation und kann bei jedem Push eine Menge Zeit kosten, abhängig von der Grösse des Repositories oder des Pushes. Wenn Du die Objektkonsistenz bei jedem Push durch Git pruefen lassen willst, so kannst Du das erzwingen, indem Du <code>receive.fsckObjects</code> auf &#8216;true&#8217; setzt:</p>

<p>By default, Git doesn’t check for consistency all the objects it receives during a push. Although Git can check to make sure each object still matches its SHA-1 checksum and points to valid objects, it doesn’t do that by default on every push. This is a relatively expensive operation and may add a lot of time to each push, depending on the size of the repository or the push. If you want Git to check object consistency on every push, you can force it to do so by setting <code>receive.fsckObjects</code> to true:</p>

<pre><code>$ git config --system receive.fsckObjects true</code></pre>

<p>Jetzt wird Git die Integrität Deines Repositories jedesmal pruefen, bevor ein Push akzeptiert wird, um sicherzustellen, dass kein Client korrupte Daten einspeist.</p>

<p>Now, Git will check the integrity of your repository before each push is accepted to make sure faulty clients aren’t introducing corrupt data.</p>

<h4 id='receivedenynonfastforwards'>receive.denyNonFastForwards</h4>

<p>Falls Du auf Commits, die Du bereits hochgeladen hast, ein Rebase anwendest, und dann erneut einen Push mit ihnen versuchst, wird Dir dies verwehrt. Genauso verhält es sich, wenn Du versuchst ein Commit auf einen entfernten Server zu pushen, wenn der Commit nicht mit dem uebereinstimmt, auf den der entfernte Server momentan verweist. Ueblicherweise ist das eine gute Richtlinie; aber im Falle des Rebase könnte es sein, dass Du weisst, was Du tust. Dann kannst Du die Aktualisierung des entfernten Branches erzwingen, indem Du einen <code>-f</code> Parameter zu dem Push Kommando hinzufuegst.</p>

<p>If you rebase commits that you’ve already pushed and then try to push again, or otherwise try to push a commit to a remote branch that doesn’t contain the commit that the remote branch currently points to, you’ll be denied. This is generally good policy; but in the case of the rebase, you may determine that you know what you’re doing and can force-update the remote branch with a <code>-f</code> flag to your push command.</p>

<p>Um die Möglichkeit des erzwungenen Updates von entfernten Branches auf Referenzen, die nicht <code>fast-forward</code> Status haben, zu deaktivieren, setze <code>receive.denyNonFastForwards</code> auf &#8216;true&#8217;:</p>

<p>To disable the ability to force-update remote branches to non-fast-forward references, set <code>receive.denyNonFastForwards</code>:</p>

<pre><code>$ git config --system receive.denyNonFastForwards true</code></pre>

<p>Eine andere Möglichkeit ist die Einrichtung von serverseitigen Empfangsschnittstellen, die ich etwas später beschreiben werde. Dieser Ansatz erlaubt noch komplexere Dinge wie zum Beispiel Nicht-<code>fast-forward</code> Referenzen nur bestimmten Benutzergruppen zu verweigern.</p>

<p>The other way you can do this is via server-side receive hooks, which I’ll cover in a bit. That approach lets you do more complex things like deny non-fast-forwards to a certain subset of users.</p>

<h4 id='receivedenydeletes'>receive.denyDeletes</h4>

<p>Eine Möglichkeit fuer den Benutzer <code>denyNonFastForwards</code> zu umgehen, ist es den Branch zu löschen und dann mit der neuen Referenz erneut zu pushen. In neueren Versionsn von Git (ab Version 1.6.1) kannst Du <code>receive.denyDeletes</code> auf &#8216;true&#8217; setzen:</p>

<p>One of the workarounds to the <code>denyNonFastForwards</code> policy is for the user to delete the branch and then push it back up with the new reference. In newer versions of Git (beginning with version 1.6.1), you can set <code>receive.denyDeletes</code> to true:</p>

<pre><code>$ git config --system receive.denyDeletes true</code></pre>

<p>Dies verbietet grundsätzlich das Löschen eines Branches oder einer Marke (Tag) — kein Benutzer hat dann dazu die Erlaubnis. Um einen entfernten Branch zu löschen musst Du die ref Dateien manuell vom Server entfernen. Es gibt aber auch noch ein paar interessantere Möglichkeiten dies auf Benutzerbasis ueber ACLs zu tun, wie Du am Ende dieses Kapitels lernen wirst.</p>

<p>This denies branch and tag deletion over a push across the board — no user can do it. To remove remote branches, you must remove the ref files from the server manually. There are also more interesting ways to do this on a per-user basis via ACLs, as you’ll learn at the end of this chapter.</p>

<div id='nav'>
<a href='ch7-1.html'>prev</a> | <a href='ch7-3.html'>next</a>
</div>