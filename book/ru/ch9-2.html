---
layout: translation
title: Pro Git 9.2 Git изнутри Объекты в Git
---
<h2 id='__git'>Объекты в Git</h2>

<p>Git — контентно-адресуемая файловая система. Здорово. Но что это означает? А означает это, что в своей основе Git — простое хранилище ключ-значение. Можно добавить туда любое содержимое, в ответ будет выдан ключ, по которому это содержимое можно извлечь. Для примера, можно воспользоваться служебной командой <code>hash-object</code>, которая добавляет данные в каталог <code>.git</code> и возвращает ключ. Для начала создадим новый Git-репозиторий и убедимся, что каталог <code>objects</code> пуст:</p>

<pre><code>$ mkdir test
$ cd test
$ git init
Initialized empty Git repository in /tmp/test/.git/
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
$ find .git/objects -type f
$</code></pre>

<p>Git проинициализировал каталог <code>objects</code> и создал в нём подкаталоги <code>pack</code> и <code>info</code>, пока без файлов. Теперь добавим кое-какое текстовое содержимое в базу Git&#8217;а:</p>

<pre><code>$ echo &#39;test content&#39; | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>

<p>Ключ <code>-w</code> команды <code>hash-object</code> указывает, что объект необходимо сохранить, иначе команда просто выведет ключ и всё. Флаг <code>--stdin</code> указывает, что данные необходимо считать со стандартного ввода, в противном случае <code>hash-object</code> ожидает имя файла. Вывод команды — 40-символьная контрольная сумма. Это хеш SHA-1 — контрольная сумма содержимого и заголовка, который будет рассмотрен позднее. Теперь можно увидеть, в каком виде будут сохранены ваши данные:</p>

<pre><code>$ find .git/objects -type f 
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>

<p>В каталоге <code>objects</code> появился файл. Это и есть начальное внутреннее представление данных в Git — один файл на единицу хранения с именем, являющимся контрольной суммой содержимого и заголовка. Первые два символа SHA определяют подкаталог файла, остальные 38 — собственно, имя.</p>

<p>Получить обратно содержимое объекта можно командой <code>cat-file</code>. Это своеобразный швейцарский армейский нож для проверки объектов в Git. Ключ <code>-p</code> означает автоматическое определение типа содержимого и вывод содержимого на печать в удобном виде:</p>

<pre><code>$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content</code></pre>

<p>Теперь вы умеете добавлять данные в Git и извлекать их обратно. То же самое можно делать и с файлами. Рассмотрим пример. Наиболее простой контроль версий файла можно осуществить, создав его и сохранив в базе:</p>

<pre><code>$ echo &#39;version 1&#39; &gt; test.txt
$ git hash-object -w test.txt 
83baae61804e65cc73a7201a7252750c76066a30</code></pre>

<p>Теперь изменим файл и сохраним его в базе ещё раз:</p>

<pre><code>$ echo &#39;version 2&#39; &gt; test.txt
$ git hash-object -w test.txt 
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</code></pre>

<p>Теперь в базе содержатся две версии файла test.txt, а также самый первый сохранённый объект:</p>

<pre><code>$ find .git/objects -type f 
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>

<p>Теперь можно откатить файл к его первой версии:</p>

<pre><code>$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt 
$ cat test.txt 
version 1</code></pre>

<p>или второй:</p>

<pre><code>$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt 
$ cat test.txt 
version 2</code></pre>

<p>Однако запоминать хеш для каждой версии неудобно, к тому же теряется само имя файла, сохраняется лишь содержимое. Объекты такого типа называют блобами (англ. binary large object). Имея SHA-1 объекта, можно попросить Git показать нам его тип с помощью команды <code>cat-file -t</code>:</p>

<pre><code>$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob</code></pre>

<h3 id='id235'>Объекты-деревья</h3>

<p>Рассмотрим другой тип объектов Git — деревья. Они решают проблему хранения имён файлов, а также позволяют хранить группы файлов вместе. Система хранения данных Git подобна файловым системам UNIX в упрощённом виде. Содержимое хранится в объектах-деревьях и блобах, дерево соответствует записи каталога в ФС, а блоб более или менее соответствует inode или содержимому файла. Объект-дерево может содержать одну и более записей, каждая из которых представляет собой набор из SHA-1 хеша, соответствующего блобу или поддереву, режима доступа к файлу, типа и имени файла. Например, в проекте simplegit дерево на момент написания выглядит так:</p>

<pre><code>$ git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</code></pre>

<p>Запись <code>master^{tree}</code> означает объект-дерево, на который указывает последний коммит ветки <code>master</code>. Заметьте, что подкаталог <code>lib</code> — не блоб, а указатель на другое дерево:</p>

<pre><code>$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</code></pre>

<p>Схематически, данные, которые хранятся в Git, выглядят примерно так, как это изображено на рисунке 9-1.</p>

<p><center><img src="/figures/ch9/18333fig0901-tn.png"></center><br/> Рисунок 9-1. Упрощённая модель данных Git.</p>

<p>Вручную можно создавать не только блобы, но и деревья. Git обычно создаёт дерево исходя из состояния индекса и затем сохраняет соответствующий объект-дерево. Поэтому для создания объекта-дерева необходимо проиндексировать какие-нибудь файлы. Для создания индекса из одной записи — первой версии файла text.txt, воспользуемся командой <code>update-index</code>. Данная команда может искусственно добавить более раннюю версию test.txt в новый индекс. Необходимо передать опции <code>--add</code>, т.к. файл ещё не существует в индексе (да и самого индекса ещё нет), и <code>--cacheinfo</code>, т.к. добавляемого файла нет в рабочем каталоге, но он есть в базе данных. Также необходимо передать режим доступа, хеш и имя файла:</p>

<pre><code>$ git update-index --add --cacheinfo 100644 \
  83baae61804e65cc73a7201a7252750c76066a30 test.txt</code></pre>

<p>В данном случае режим доступа — <code>100644</code>, что означает обычный файл. Другие возможные варианты: <code>100755</code> — исполняемый файл, <code>120000</code> — символическая ссылка. Режимы доступа в Git сделаны по аналогии с режимами доступа в UNIX, но они гораздо менее гибки: данные три режима — единственные доступные для файлов (блобов) в Git (хотя существуют и другие режимы используемые для каталогов и подмодулей).</p>

<p>Теперь можно воспользоваться командой <code>write-tree</code> для сохранения индекса в объект-дерево. Здесь опция <code>-w</code> не требуется — вызов <code>write-tree</code> автоматически создаст объект-дерево по состоянию индекса, если такого дерева ещё не существует:</p>

<pre><code>$ git write-tree
d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt</code></pre>

<p>Также можно проверить, что мы действительно создали объект-дерево:</p>

<pre><code>$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
tree</code></pre>

<p>Создадим новое дерево со второй версией файла test.txt и ещё одним файлом:</p>

<pre><code>$ echo &#39;new file&#39; &gt; new.txt
$ git update-index test.txt 
$ git update-index --add new.txt </code></pre>

<p>Теперь в индексе содержится новая версия файла test.txt и новый файл new.txt. Запишем это дерево (сохранив состояние индекса в объект-дерево) и посмотрим, что из этого получилось:</p>

<pre><code>$ git write-tree
0155eb4229851634a0f03eb265b69f5a2d56f341
$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</code></pre>

<p>Заметьте, что в данном дереве находятся записи для обоих файлов, а также, что хеш файла test.txt это хеш &#8220;второй версии&#8221; этого файла (<code>1f7a7a</code>). Для интереса, добавим первое дерево как подкаталог для текущего. Зачитать дерево в индекс можно командой <code>read-tree</code>. В нашем случае, чтобы прочитать уже существующее дерево в индекс и сделать его поддеревом, необходимо использовать опцию <code>--prefix</code>:</p>

<pre><code>$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git write-tree
3c4e9cd789d88d8d89c1073707c3585e41b0e614
$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</code></pre>

<p>Если бы вы создали рабочий каталог, соответствующий только что созданному дереву, вы бы получили два файла в корне и подкаталог <code>bak</code> со старой версией файла test.txt. Данные, которые хранит Git для такой структуры, представлены на рисунке 9-2.</p>

<p><center><img src="/figures/ch9/18333fig0902-tn.png"></center><br/> Рисунок 9-2. Структура данных Git для текущего дерева.</p>

<h3 id='id236'>Объекты-коммиты</h3>

<p>У нас есть три дерева, соответствующих разным состояниям проекта, но предыдущая проблема с необходимостью запоминать все три значения SHA-1, чтобы иметь возможность восстановить какое-либо из этих состояний, ещё не решена. К тому же у нас нет никакой информации о том, кто, когда и почему сохранил их. Такие данные — основная информация, которая хранится в объекте-коммите.</p>

<p>Для создания объекта-коммита необходимо вызвать <code>commit-tree</code> и задать SHA-1 нужного дерева и, если необходимо, родительские объекты-коммиты. Для начала создадим коммит для самого первого дерева:</p>

<pre><code>$ echo &#39;first commit&#39; | git commit-tree d8329f
fdf4fc3344e67ab068f836878b6c4951e3b15f3d</code></pre>

<p>Просмотреть вновь созданный объект-коммит можно командой <code>cat-file</code>:</p>

<pre><code>$ git cat-file -p fdf4fc3
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700

first commit</code></pre>

<p>Формат объекта-коммита прост: в нём указано дерево верхнего уровня, соответствующее состоянию проекта на некоторый момент; имя автора и коммитера берутся из полей конфигурации <code>user.name</code> и <code>user.email</code>; также добавляется текущая временная метка, пустая строка и затем сообщение коммита.</p>

<p>Далее, создадим ещё два объекта-коммита, каждый из которых будет ссылаться на предыдущий коммит:</p>

<pre><code>$ echo &#39;second commit&#39; | git commit-tree 0155eb -p fdf4fc3
cac0cab538b970a37ea1e769cbbde608743bc96d
$ echo &#39;third commit&#39;  | git commit-tree 3c4e9c -p cac0cab
1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>

<p>Каждый из трёх объектов-коммитов указывает на одно из состояний проекта. Может показаться странным, но теперь у нас есть полноценная Git-история, которую можно посмотреть командой <code>git log</code>, указав хеш последнего коммита:</p>

<pre><code>$ git log --stat 1a410e
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:15:24 2009 -0700

    third commit

 bak/test.txt |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

commit cac0cab538b970a37ea1e769cbbde608743bc96d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:14:29 2009 -0700

    second commit

 new.txt  |    1 +
 test.txt |    2 +-
 2 files changed, 2 insertions(+), 1 deletions(-)

commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:09:34 2009 -0700

    first commit

 test.txt |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>

<p>Поразительно. Мы только что выполнили низкоуровневые операции для построения истории без использования высокоуровневых интерфейсов. По существу, именно это делает Git, когда выполняются команды <code>git add</code> и <code>git commit</code> — сохраняет блобы для изменённых файлов, обновляет индекс, записывает объекты-деревья и коммит-объекты, ссылающиеся на объекты-деревья верхнего уровня и предшествующие коммиты. Эти три основных вида объектов в Git: блоб, дерево и коммит — сначала сохраняются как отдельные файлы в каталоге <code>.git/objects</code>. Вот все объекты, которые сейчас лежат в каталоге с примером (в комментариях написано чему объекты соответствует):</p>

<pre><code>$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # &#39;test content&#39;
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</code></pre>

<p>Если пройти по всем внутренним ссылкам, получится граф объектов такой, как на рисунке 9-3.</p>

<p><center><img src="/figures/ch9/18333fig0903-tn.png"></center><br/> Рисунок 9-3. Все объекты в репозитории Git.</p>

<h3 id='_'>Хранение объектов</h3>

<p>Ранее я упоминал, что заголовок сохраняется вместе с содержимым. Давайте посмотрим, как сохраняются объекты Git на диске. Мы рассмотрим сохранение блоб-объекта, в данном случае это будет строка &#8220;есть проблемы, шеф?&#8221;. Пример будет выполнен на языке Ruby. Для запуска интерактивного интерпретатора воспользуйтесь командой <code>irb</code>:</p>

<pre><code>$ irb
&gt;&gt; content = &quot;есть проблемы, шеф?&quot;
=&gt; &quot;есть проблемы, шеф?&quot;</code></pre>

<p>Git создаёт заголовок, начинающийся с типа объекта, в данном случае это блоб. Далее добавляется пробел, размер содержимого и в конце нулевой байт:</p>

<pre><code>&gt;&gt; header = &quot;blob #{content.length}\0&quot;
=&gt; &quot;blob 34\000&quot;</code></pre>

<p>Git дописывает содержимое после заголовка и вычисляет SHA-1 сумму для полученного результата. В Ruby значение SHA-1 для строки можно получить, подключив соответствующую библиотеку командой <code>require</code> и затем воспользовавшись вызовом <code>Digest::SHA1.hexdigest()</code>:</p>

<pre><code>&gt;&gt; store = header + content
=&gt; &quot;blob 34\000\320\225\321\201\321\202\321\214 \320\277\321\200\320\276\320\261\320\273\320\265\320\274\321\213, \321\210\320\265\321\204?&quot;
&gt;&gt; require &#39;digest/sha1&#39;
=&gt; true
&gt;&gt; sha1 = Digest::SHA1.hexdigest(store)
=&gt; &quot;d8a734f44240bdf766c8df342664fde23d421d64&quot;</code></pre>

<p>Git сжимает новые данные при помощи zlib, что решается в Ruby соответствующей библиотекой. Сперва, необходимо подключить её, а после вызвать <code>Zlib::Deflate.deflate()</code> с данными в качестве параметра:</p>

<pre><code>&gt;&gt; require &#39;zlib&#39;
=&gt; true
&gt;&gt; zlib_content = Zlib::Deflate.deflate(store)
=&gt; &quot;x\234\001*\000\325\377blob 34\000\320\225\321\201\321\202\321\214 \320\277\321\200\320\276\320\261\320\273\320\265\320\274\321\213, \321\210\320\265\321\204?\3453\030S&quot;</code></pre>

<p>После этого, запишем сжатую zlib&#8217;ом строку в объект на диск. Определим путь к файлу, который будет записан (первые два символа хеша используются в качестве названия подкаталога, оставшиеся 38 — в качестве имени файла в этом каталоге). В Ruby для этой задачи можно использовать функцию <code>FileUtils.mkdir_p()</code> для создания подкаталога, если он не существует. Далее, откроем файл вызовом <code>File.open()</code> и запишем наши сжатые данные вызовом <code>write()</code> для полученного файлового дескриптора:</p>

<pre><code>&gt;&gt; path = &#39;.git/objects/&#39; + sha1[0,2] + &#39;/&#39; + sha1[2,38]
=&gt; &quot;.git/objects/d8/a734f44240bdf766c8df342664fde23d421d64&quot;
&gt;&gt; require &#39;fileutils&#39;
=&gt; true
&gt;&gt; FileUtils.mkdir_p(File.dirname(path))
=&gt; &quot;.git/objects/bd&quot;
&gt;&gt; File.open(path, &#39;w&#39;) { |f| f.write zlib_content }
=&gt; 32</code></pre>

<p>Вот и всё, мы создали корректный объект-блоб для Git. Все другие объекты создаются аналогично, меняется только запись о типе в заголовке (blob, commit, tree). Стоит добавить, что хотя в блобе может храниться почти любое содержимое, содержимое объектов-деревьев и объектов-коммитов записывается в очень строгом формате.</p>

<div id='nav'>
<a href='ch9-1.html'>prev</a> | <a href='ch9-3.html'>next</a>
</div>