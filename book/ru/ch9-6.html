---
layout: translation
title: Pro Git 9.6 Git изнутри Протоколы передачи
---
<h2 id='_'>Протоколы передачи</h2>

<p>Git может передавать данные между репозиториями одним из двух основных способов: через HTTP или через &#8220;умные&#8221; протоколы для транспортов <code>file://</code>, <code>ssh://</code> и <code>git://</code>. В данном разделе мы кратко рассмотрим как эти два протокола работают.</p>

<h3 id='_'>Тупой протокол</h3>

<p>Git-транспорт работающий по HTTP часто называют &#8220;тупым&#8221; протоколом, потому что для его работы во время передачи данных не требуется исполнения никакого Git-специфичного кода на стороне сервера. Процесс извлечения данных представляет собой последовательность GET-запросов, клиент обращается к стандартной структуре каталогов Git. Давайте рассмотрим процесс получения данных по HTTP на примере библиотеки simplegit:</p>

<pre><code>$ git clone http://github.com/schacon/simplegit-progit.git</code></pre>

<p>Первое действие, выполняемое данной командой — загрузка файла <code>info/refs</code>. Данный файл записывается командой <code>update-server-info</code>, поэтому для использования HTTP-транспорта необходимо запускать эту команду в <code>post-receive</code> хуке:</p>

<pre><code>=&gt; GET info/refs
ca82a6dff817ec66f44342007202690a93763949     refs/heads/master</code></pre>

<p>Теперь у нас имеется список удалённых веток и их хеши. Далее, нам надо посмотреть куда ссылается HEAD, чтобы знать на какую версию переключиться после завершения работы команды.</p>

<pre><code>=&gt; GET HEAD
ref: refs/heads/master</code></pre>

<p>Нам надо переключиться на ветку <code>master</code> после завершения процесса. На данном этапе можно начать обход дерева. Начальной точкой является объект-коммит <code>ca82a6</code>, о чём мы узнали из файла <code>info/refs</code>, и мы начинаем с его загрузки:</p>

<pre><code>=&gt; GET objects/ca/82a6dff817ec66f44342007202690a93763949
(179 bytes of binary data)</code></pre>

<p>Объект получен, он был в рыхлом формате на сервере, и мы получили его по HTTP используя статический GET-запрос. Теперь можно его разархивировать, отрезать заголовок и посмотреть на его содержимое:</p>

<pre><code>$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700

changed the version number</code></pre>

<p>Далее, необходимо загрузить ещё два объекта: <code>cfda3b</code> — объект-дерево, который обозначен как содержимое только что загруженного коммита, и <code>085bb3</code> — родительский коммит:</p>

<pre><code>=&gt; GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
(179 bytes of data)</code></pre>

<p>Так, мы получили следующий объект-коммит. Прихватим и наш объект-дерево:</p>

<pre><code>=&gt; GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
(404 - Not Found)</code></pre>

<p>Ой! Похоже, этого объекта-дерева нет на сервере в рыхлом формате, поэтому мы получили ответ 404. У этого могут быть разные причины: объект в другом репозитории, или в упакованном файле текущего репозитория. Сперва Git проверяет список альтернативных репозиториев:</p>

<pre><code>=&gt; GET objects/info/http-alternates
(empty file)</code></pre>

<p>Если бы этот запрос вернул нам список альтернативных URL, Git обратился по ним в поиске &#8220;рыхлых&#8221; и pack-файлов — это такой механизм, позволяющий не дублировать данные проектам, являющимися форками друг для друга. Так как в данном случае альтернативных адресов нет, объект должен быть в pack-файле. Для того, чтобы узнать, какие упакованные файлы есть на сервере, необходимо загрузить файл со списком pack-файлов: <code>objects/info/packs</code> (который также генерируется <code>update-server-info</code>):</p>

<pre><code>=&gt; GET objects/info/packs
P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack</code></pre>

<p>На сервере имеется только один pack-файл, поэтому объект точно там, но необходимо проверить индексный файл, чтобы в этом убедиться. Если бы на сервере было несколько pack-файлов, загрузив сначала индексы, мы смогли бы определить в каком именно pack-файле находится нужный нам объект:</p>

<pre><code>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
(4k of binary data)</code></pre>

<p>Теперь, когда мы получили индекс упакованного файла, можно проверить, тут ли наш объект. Это возможно благодаря тому, что в индексе хранятся SHA-1 объектов содержащихся в pack-файле, а также их смещения. Необходимый объект там присутствует, так что продолжим и получим весь pack-файл:</p>

<pre><code>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
(13k of binary data)</code></pre>

<p>Итак, мы получили наш объект-дерево, можно продолжить обход списка коммитов. Все они лежат внутри упакованного файла, который мы только что скачали, так что снова обращаться к серверу не надо. Git извлекает рабочую копию ветки <code>master</code>, на которую ссылается HEAD.</p>

<p>Полный вывод этого процесса выглядит так:</p>

<pre><code>$ git clone http://github.com/schacon/simplegit-progit.git
Initialized empty Git repository in /private/tmp/simplegit-progit/.git/
got ca82a6dff817ec66f44342007202690a93763949
walk ca82a6dff817ec66f44342007202690a93763949
got 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Getting alternates list for http://github.com/schacon/simplegit-progit.git
Getting pack list for http://github.com/schacon/simplegit-progit.git
Getting index for pack 816a9b2334da9953e530f27bcac22082a9f5b835
Getting pack 816a9b2334da9953e530f27bcac22082a9f5b835
 which contains cfda3bf379e4f8dba8717dee55aab78aef7f4daf
walk 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
walk a11bef06a3f659402fe7563abf99ad00de2209e6</code></pre>

<h3 id='_'>Умный протокол</h3>

<p>Методика работы HTTP проста, но неэффективна, поэтому чаще используются &#8220;умные&#8221; протоколы. Эти протоколы обслуживаются процессом на стороне сервера, который учитывает особенности работы Git — он считывает локальные данные, выясняет что есть и чего не хватает на клиенте и генерирует для него соответствующие данные. Существует два набора процессов передачи данных: процессы для загрузки данных и процессы для скачивания.</p>

<h4 id='_'>Загрузка данных</h4>

<p>Для загрузки данных на удалённый сервер используются процессы <code>send-pack</code> и <code>receive-pack</code>. Процесс <code>send-pack</code> запускается на стороне клиента и подключается к <code>receive-pack</code> на стороне сервера.</p>

<p>Например, выполняется команда <code>git push origin master</code> и <code>origin</code> определён как URL использующий протокол SSH. Git запускает процесс <code>send-pack</code>, который устанавливает соединение с сервером по протоколу SSH. Он пытается запустить команду на удалённом сервере через вызов команды ssh, который выглядит следующим образом:</p>

<pre><code>$ ssh -x git@github.com &quot;git-receive-pack &#39;schacon/simplegit-progit.git&#39;&quot;
005bca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status delete-refs
003e085bb3bcb608e1e84b2432f8ecbe6306e7e7 refs/heads/topic
0000</code></pre>

<p>Команда <code>git-receive-pack</code> тут же посылает в ответ по одной строке на каждую из имеющихся в наличии ссылок — в данном случае только ветку <code>master</code> и её SHA. Первая строка также содержит список возможностей сервера (здесь это <code>report-status</code> и <code>delete-refs</code>).</p>

<p>Каждая строка начинается с 4-байтового шестнадцатеричного значения, содержащего длину оставшейся строки. Первая строка начинается с 005b, это 91 в 16-ричном виде, значит в этой строке ещё 91 байт. Следующая строка начинается с 003e, что означает 62, то есть надо прочитать 62 байта. Далее следует строка 0000, которая означает, что сервер закончил листинг своих ссылок.</p>

<p>Теперь, когда процесс <code>send-pack</code> выяснил состояние сервера, он определяет коммиты, которые есть локально, но которых нет на сервере. Для каждой ссылки, которая будет обновлена текущей командой <code>push</code>, процесс <code>send-pack</code> передаёт процессу <code>receive-pack</code> эти данные. Например, если мы обновляем ветку <code>master</code>, и добавляем ветку <code>experiment</code>, ответ <code>send-pack</code> будет выглядеть следующим образом:</p>

<pre><code>0085ca82a6dff817ec66f44342007202690a93763949  15027957951b64cf874c3557a0f3547bd83b3ff6 refs/heads/master report-status
00670000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d refs/heads/experiment
0000</code></pre>

<p>Значение SHA-1 из одних нулей означает, что раньше здесь ничего не было — так получилось из-за того, что мы добавили новую ссылку <code>experiment</code>. Если бы мы удаляли ссылку, было бы на оборот: одни нули были бы справа.</p>

<p>Git отправляет строку для каждой ссылки, для которой производится обновление. В строке содержится старый хеш, новый хеш и имя обновляемой ссылки. Первая строка также содержит возможности клиента. Далее, клиент загружает упакованный файл со всеми объектами, которых ещё нет на сервере. В конце, сервер отвечает статусным сообщением сообщающем об успехе (или ошибке):</p>

<pre><code>000Aunpack ok</code></pre>

<h4 id='_'>Скачивание данных</h4>

<p>Если выполняется скачивание данных, используются процессы <code>fetch-pack</code> и <code>upload-pack</code>. Клиент запускает процесс <code>fetch-pack</code>, который подключающийся к процессу <code>upload-pack</code> на удалённой машине для определения, какие данные будут переданы.</p>

<p>Существуют разные способы запуска <code>upload-pack</code> на удалённом репозитории. Можно запустить его по SSH так же, как и <code>receive-pack</code>. Ещё можно вызвать процесс через Git-демон, по умолчанию принимающий соединения на порте 9418. Процесс <code>fetch-pack</code> после подключения отправляет демону данные примерно следующего вида:</p>

<pre><code>003fgit-upload-pack schacon/simplegit-progit.git\0host=myserver.com\0</code></pre>

<p>Начальные 4 байта задают размер последующих данных, далее следует команда, которую следует запустить, завершаемая нулевым байтом, а потом имя сервера и последний нулевой байт. Git-демон проверяет возможность выполнения команды, а также, что репозиторий существует и имеет необходимые права доступа. Если всё хорошо, демон запускает процесс <code>upload-pack</code> и передаёт запрос ему.</p>

<p>Если извлечение данных производится по SSH, <code>fetch-pack</code> выполняет другие действия:</p>

<pre><code>$ ssh -x git@github.com &quot;git-upload-pack &#39;schacon/simplegit-progit.git&#39;&quot;</code></pre>

<p>В обоих случаях, после того как <code>fetch-pack</code> подключится, <code>upload-pack</code> передаст обратно следующее:</p>

<pre><code>0088ca82a6dff817ec66f44342007202690a93763949 HEAD\0multi_ack thin-pack \
  side-band side-band-64k ofs-delta shallow no-progress include-tag
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
003e085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 refs/heads/topic
0000</code></pre>

<p>Это очень похоже на ответ <code>receive-pack</code>, но только возможности другие. В добавок <code>upload-pack</code> отсылает обратно ссылку HEAD, чтобы клиент понимал, на какую ветку переключиться, если выполняется клонирование.</p>

<p>На данном этапе процесс <code>fetch-pack</code> смотрит на объекты, имеющиеся в наличии и для недостающих объектов отвечает словом &#8220;want&#8221; и за ним SHA объекта. Для уже имеющихся объектов процесс отправляет их хеши со словом &#8220;have&#8221;. В конце списка он пишет &#8220;done&#8221;, и это даёт понять процессу <code>upload-pack</code>, что пора начинать отправлять упакованный файл с необходимыми данными:</p>

<pre><code>0054want ca82a6dff817ec66f44342007202690a93763949 ofs-delta
0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
0000
0009done</code></pre>

<p>Это самый основной случай передачи данных. В более сложных случаях, клиент поддерживает функции <code>multi_ack</code> или <code>side-band</code>, но этот пример иллюстрирует основные взаимодействия используемые процессами умного протокола.</p>

<div id='nav'>
<a href='ch9-5.html'>prev</a> | <a href='ch9-7.html'>next</a>
</div>