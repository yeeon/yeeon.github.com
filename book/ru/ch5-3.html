---
layout: translation
title: Pro Git 5.3 Распределённый Git Сопровождение проекта
---
<h2 id='_'>Сопровождение проекта</h2>

<p>В дополнение к тому, как эффективно работать над проектом, вам, наверняка, необходимо также знать, как самому поддерживать проект. Сопровождение проекта может заключаться в принятии и применении патчей, сгенерированных с помощью &#8216;format-patch&#8217; и отправленных вам по почте, или в интеграции изменений из веток тех репозиториев, которые вы добавили в качестве удалённых (remotes) для вашего проекта. Неважно, поддерживаете ли вы эталонный репозиторий проекта или хотите помочь с проверкой и утверждением патчей, вам необходимо выработать метод приёма наработок, который будет наиболее понятным для других участников и не будет изменяться в течение длительного срока.</p>

<h3 id='___'>Работа с тематическими ветками</h3>

<p>Если вы решаете, интегрировать ли новые наработки, как правило, неплохо было бы опробовать их в какой-нибудь временной тематической ветке, специально созданной для их тестирования. Так будет легче подправить отдельные патчи или забросить их до лучших времён, если что-то не работает. Если вы дадите ветке простое имя, основанное на теме содержащейся в ней работы, например, <code>ruby_client</code>, или как-нибудь так же наглядно, то вы сможете легко вспомнить, для чего эта ветка, если вам вдруг придётся отложить работу с ней и вернуться к ней позднее. В проекте Git мейнтейнер, как правило, создаёт ветки с добавлением пространства имён — к примеру, &#8216;sc/ruby_client&#8217;, где &#8216;sc&#8217; — это сокращённое имя автора, приславшего свою работу. Как вы уже знаете, создать ветку, основанную на вашей ветке <code>master</code>, можно следующим образом:</p>

<pre><code>$ git branch sc/ruby_client master</code></pre>

<p>Или, если вы хотите сразу переключиться на создаваемую ветку, можно воспользоваться командой <code>checkout -b</code>:</p>

<pre><code>$ git checkout -b sc/ruby_client master</code></pre>

<p>Теперь вы готовы к тому, чтобы принять изменения в данную тематическую ветку и определить, хотите ли вы влить их в свои стабильные ветки или нет.</p>

<h3 id='____'>Применение патчей, отправленных по почте</h3>

<p>Если вы получили по электронной почте патч, который вам нужно интегрировать в свой проект, вам необходимо применить патч в тематической ветке, чтобы его оценить. Есть два способа применения отправленных по почте патчей: с помощью команды <code>git apply</code> или команды <code>git am</code>.</p>

<h4 id='_____apply'>Применение патчей с помощью команды apply</h4>

<p>Если вы получили чей-то патч, сгенерированный с помощью команды <code>git diff</code> или Unix-команды <code>diff</code>, вы можете применить его при помощи команды <code>git apply</code>. Полагая, что вы сохранили патч в <code>/tmp/patch-ruby-client.patch</code>, вы можете применить его следующим образом:</p>

<pre><code>$ git apply /tmp/patch-ruby-client.patch</code></pre>

<p>Эта команда внесёт изменения в файлы в рабочем каталоге. Она практически идентична выполнению команды <code>patch -p1</code> для применения патча, хотя она более параноидальна и допускает меньше нечётких совпадений, чем <code>patch</code>. К тому же она способна справиться с добавлением, удалением и переименованием файлов, описанными в формате <code>git diff</code>, чего команда <code>patch</code> сделать не сможет. И, наконец, <code>git apply</code> реализует модель &#8220;применить всё или ничего&#8221;, тогда как <code>patch</code> позволяет частично применять патч-файлы, оставляя ваш рабочий каталог в странном и непонятном состоянии. Команда <code>git apply</code> в целом гораздо более параноидальна, чем <code>patch</code>. Она не создаст для вас коммит — после выполнения команды вы должны вручную проиндексировать внесённые изменения и сделать коммит.</p>

<p>Кроме того, вы можете использоваться <code>git apply</code>, чтобы узнать, чисто ли накладывается патч, ещё до того, как вы будете применять его на самом деле — для этого выполните <code>git apply --check</code>, указав нужный патч:</p>

<pre><code>$ git apply --check 0001-seeing-if-this-helps-the-gem.patch 
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply</code></pre>

<p>Если никакого вывода нет, то патч должен наложиться без ошибок. Если проверка прошла неудачно, то команда завершится с ненулевым статусом, так что вы можете использовать её при написании сценариев.</p>

<h4 id='_____am'>Применение патчей с помощью команды am</h4>

<p>Если разработчик является достаточно хорошим пользователем Git&#8217;а и применил команду <code>format-patch</code> для создания своего патча, то ваша задача становится проще, так как такой патч содержит информацию об авторе и сообщение коммита. По возможности поощряйте участников проекта на использование команды <code>format-patch</code> вместо <code>diff</code> при генерировании патчей для вас. Команду <code>git apply</code> стоит использовать, только если нет другого выхода, и патчи уже созданы при помощи <code>diff</code>.</p>

<p>Чтобы применить патч, созданный при помощи <code>format-patch</code>, используйте команду <code>git am</code>. С технической точки зрения, <code>git am</code> читает mbox-файл, который является простым текстовым форматом для хранения одного или нескольких электронных писем в одном текстовом файле. Он выглядит примерно следующим образом:</p>

<pre><code>From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20</code></pre>

<p>Это начало вывода команды <code>format-patch</code>, который мы уже видели в предыдущем разделе. Это одновременно и правильный mbox формат для e-mail. Если кто-то прислал вам по почте патч, правильно воспользовавшись для этого командой <code>git send-email</code>, и вы сохранили это сообщение в mbox-формате, тогда вы можете указать этот mbox-файл команде <code>git am</code> — в результате команда начнёт применять все патчи, которые найдёт. Если вы пользуетесь почтовым клиентом, способным сохранять несколько электронных писем в один mbox-файл, то можете сохранить всю серию патчей в один файл и затем использовать команду <code>git am</code> для применения всех патчей сразу.</p>

<p>Однако, если кто-нибудь загрузил патч, созданный через <code>format-patch</code>, в тикет-систему или что-либо подобное, вы можете сохранить файл локально и затем передать его команде <code>git am</code>, чтобы его наложить:</p>

<pre><code>$ git am 0001-limit-log-function.patch 
Applying: add limit to log function</code></pre>

<p>Как видите, патч был применён без ошибок, и за вас автоматически был создан новый коммит. Информация об авторе берётся из полей <code>From</code> и <code>Date</code> письма, а сообщение коммита извлекается из поля <code>Subject</code> и тела (до начала самого патча) электронного письма. Например, если применить патч из mbox-файла приведённого выше примера, то созданный для него коммит будет выглядеть следующим образом:</p>

<pre><code>$ git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith &lt;jessica@example.com&gt;
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon &lt;schacon@gmail.com&gt;
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   add limit to log function

   Limit log functionality to the first 20</code></pre>

<p>В поле <code>Commit</code> указан человек, применивший патч, а в <code>CommitDate</code> — время его применения. Информация <code>Author</code> определяет человека, создавшего патч изначально, и время его создания.</p>

<p>Однако возможна ситуация, когда патч не наложится без ошибок. Возможно, ваша основная ветка слишком далеко ушла вперёд относительно той, на которой патч был основан, или этот патч зависит от другого патча, который вы ещё не применили. В этом случае выполнение команды <code>git am</code> будет приостановлено, а у вас спросят, что вы хотите сделать:</p>

<pre><code>$ git am 0001-seeing-if-this-helps-the-gem.patch 
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Patch failed at 0001.
When you have resolved this problem run &quot;git am --resolved&quot;.
If you would prefer to skip this patch, instead run &quot;git am --skip&quot;.
To restore the original branch and stop patching run &quot;git am --abort&quot;.</code></pre>

<p>Эта команда выставляет отметки о конфликтах в каждый файл, с которым возникают проблемы, точно так же, как это происходит при операции слияния или перемещения с конфликтами. И разрешается данная ситуация тем же способом — отредактируйте файл, чтобы разрешить конфликт, добавьте новый файл в индекс, а затем выполните команду <code>git am --resolved</code>, чтобы перейти к следующему патчу:</p>

<pre><code>$ (исправление файла)
$ git add ticgit.gemspec 
$ git am --resolved
Applying: seeing if this helps the gem</code></pre>

<p>Если вы хотите, чтобы Git постарался разрешить конфликт более умно, воспользуйтесь опцией <code>-3</code>, при использовании которой Git попытается выполнить трёхходовую операцию слияния. Эта опция не включена по умолчанию, так как она не работает в случае, если коммита, на котором был основан патч, нет в вашем репозитории. Если этот коммит всё же у вас есть — в случае когда патч был основан на публичном коммите — то опция <code>-3</code>, как правило, гораздо умнее в наложении конфликтных патчей:</p>

<pre><code>$ git am -3 0001-seeing-if-this-helps-the-gem.patch 
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.</code></pre>

<p>В этом случае я пытался применить патч, который я уже применил. Без опции <code>-3</code> это привело бы к конфликту.</p>

<p>При применении серии патчей из mbox-файла, вы также можете запустить команду <code>am</code> в интерактивном режиме — в этом случае команда останавливается на каждом найденном патче и спрашивает вас, хотите ли вы его применить:</p>

<pre><code>$ git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all </code></pre>

<p>Это удобно, если у вас накопилось множество патчей, так как вы сможете сначала просмотреть патч, если вы забыли, что он из себя представляет, или отказаться применять патч, если он уже применён.</p>

<p>После того как вы примените все патчи по интересующей вас теме и сделаете для них коммиты в своей ветке, вы можете принять решение — интегрировать ли их в свои стабильные ветки и если да, то каким образом.</p>

<h3 id='__'>Проверка удалённых веток</h3>

<p>Если к вам поступили наработки от человека, использующего Git и имеющего свой собственный репозиторий, в который он и отправил свои изменения, а вам он прислал ссылку на свой репозиторий и имя удалённой ветки, в которой находятся изменения, то вы можете добавить его репозиторий в качестве удалённого и выполнить слияния локально.</p>

<p>Например, если Джессика присылает вам письмо, в котором говорится, что у неё есть классная новая функция в ветке <code>ruby-client</code> в её репозитории, вы можете протестировать её, добавив её репозиторий в качестве удалённого для вашего проекта и выгрузив содержимое этой ветки в рабочий каталог:</p>

<pre><code>$ git remote add jessica git://github.com/jessica/myproject.git
$ git fetch jessica
$ git checkout -b rubyclient jessica/ruby-client</code></pre>

<p>Если она снова пришлёт вам письмо с другой веткой и с новой замечательной функцией, вы сможете сразу извлечь эти наработки и переключиться на эту ветку, так как её репозиторий уже прописан в ваших удалённых репозиториях.</p>

<p>Этот метод наиболее удобен, если вы работаете с человеком постоянно. Если кто-то изредка представляет вам по одному патчу, то менее затратно по времени будет принимать их по e-mail, чем заставлять всех иметь свои собственные репозитории и постоянно добавлять и удалять удалённые репозитории, чтобы получить пару патчей. Также вы, скорее всего, не захотите иметь у себя сотни удалённых репозиториев — для всех, кто предоставил вам один или два патча. Хотя сценарии и функции хостингов могут упростить эту ситуацию — всё зависит от того, как ведёте разработку вы и участники вашего проекта.</p>

<p>Другим преимуществом данного подхода является тот факт, что вы получаете не только патчи, но и историю коммитов. Если вы даже обнаружите проблемы со слиянием, то вы, по крайней мере, будете знать, на каком коммите в вашей истории основана их работа. Правильное трёхходовое слияние в этом случае используется по умолчанию, что лучше, чем передать <code>-3</code> и надеяться, что патч был сгенерирован на основе публичного коммита, к которому у вас есть доступ.</p>

<p>Если вы не работаете с человеком постоянно, но всё же хотите принять его изменения таким способом, можете указать URL его удалённого репозитория команде <code>git pull</code>. Так вы получите нужные изменения, а URL не будет сохранён в списке удалённых репозиториев:</p>

<pre><code>$ git pull git://github.com/onetimeguy/project.git
From git://github.com/onetimeguy/project
 * branch            HEAD       -&gt; FETCH_HEAD
Merge made by recursive.</code></pre>

<h3 id='__'>Определение вносимых изменений</h3>

<p>Сейчас у вас есть тематическая ветка, содержащая наработки участников проекта. На этом этапе вы можете определить, что бы вы хотели с ними сделать. В этом разделе мы снова рассмотрим несколько команд, которые, как вы увидите, можно использовать для точного определения того, что вы собираетесь слить в свою основную ветку.</p>

<p>Часто полезно просмотреть все коммиты, которые есть в этой ветке, но нет в вашей ветке <code>master</code>. Исключить коммиты из ветки <code>master</code> можно добавив опцию <code>--not</code> перед именем ветки. Например, если участник вашего проекта прислал вам два патча, и вы создали ветку с именем <code>contrib</code> и применили эти патчи в ней, вы можете выполнить следующее:</p>

<pre><code>$ git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Oct 24 09:53:59 2008 -0700

    seeing if this helps the gem

commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Mon Oct 22 19:38:36 2008 -0700

    updated the gemspec to hopefully work better</code></pre>

<p>Чтобы увидеть какие изменения вносит каждый коммит, если помните, можно передать опцию <code>-p</code> команде <code>git log</code> — к каждому коммиту будет добавлен его diff.</p>

<p>Чтобы посмотреть полный diff того, что добавится при слиянии вашей тематической ветки с другой веткой, вам может понадобиться использовать странный трюк, чтобы получить нужный результат. Вы, возможно, решите выполнить такую команду:</p>

<pre><code>$ git diff master</code></pre>

<p>Эта команда выведет вам diff, но результат может ввести вас в заблуждение. Если ваша ветка <code>master</code> была промотана вперёд с того момента, когда вы создали на её основе тематическую ветку, вы, наверняка, увидите странный результат. Это происходит по той причине, что Git напрямую сравнивает снимок состояния последнего коммита тематической ветки, на которой вы находитесь, и снимок последнего коммита ветки <code>master</code>. Например, если вы добавили строку в файл в ветке <code>master</code>, прямое сравнение снимков покажет, что изменения в тематической ветке собираются эту строку удалить.</p>

<p>Если <code>master</code> является прямым предком вашей тематической ветки, то проблем нет. Но если две линии истории разошлись, то diff будет выглядеть так, будто вы добавляете всё новое из вашей тематической ветки и удаляете всё уникальное в ветке <code>master</code>.</p>

<p>То, что вы действительно хотели бы видеть — это изменения, добавленные в тематической ветке, то есть те наработки, которые вы внесёте при слиянии этой ветки с веткой <code>master</code>. Это выполняется путём сравнения последнего коммита в вашей тематической ветке с первым общим с веткой <code>master</code> предком.</p>

<p>Технически, вы можете сделать это, выделив общего предка явным образом и выполнив затем команду <code>diff</code>:</p>

<pre><code>$ git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
$ git diff 36c7db </code></pre>

<p>Однако это не очень удобно, так что в Git&#8217;е есть отдельное сокращённое обозначение для выполнения того же самого — запись с тремя точками. В контексте команды <code>diff</code>, вы можете поставить три точки после названия одной из веток, чтобы увидеть дельту между последним коммитом ветки, на которой вы находитесь, и их общим предком с другой веткой:</p>

<pre><code>$ git diff master...contrib</code></pre>

<p>Эта команда покажет вам только те наработки в вашей текущей тематической ветке, которые были внесены после её ответвления от ветки <code>master</code>. Это очень удобный синтаксис, и его надо запомнить.</p>

<h3 id='__'>Интегрирование чужих наработок</h3>

<p>Когда все наработки в вашей тематической ветке готовы к интегрированию в более стабильную ветку, встаёт вопрос — как это сделать? Более того — какой рабочий процесс в целом вы хотите использовать, занимаясь поддержкой своего проекта? Есть множество вариантов, так что рассмотрим некоторые из них.</p>

<h4 id='_'>Процессы слияния</h4>

<p>Один из простых рабочих процессов заключается в слиянии наработок в ветку <code>master</code>. В этом случае ваша ветка <code>master</code> содержит основную стабильную версию кода. Если у вас в тематической ветке находится работа, которую вы уже доделали, или полученные от кого-то наработки, которые вы уже проверили, вы сливаете её в свою ветку <code>master</code>, удаляете тематическую ветку, а затем продолжаете работу. Если в вашем репозитории наработки находятся в двух ветках, названия которых <code>ruby_client</code> и <code>php_client</code> (см. рис. 5-19), и вы выполняете слияние сначала для ветки <code>ruby_client</code>, в потом для <code>php_client</code>, то ваша история коммитов в итоге будет выглядеть, как показано на рисунке 5-20.</p>

<p><center><img src="/figures/ch5/18333fig0519-tn.png"></center><br/> Рисунок 5-19. История коммитов с несколькими тематическими ветками.</p>

<p><center><img src="/figures/ch5/18333fig0520-tn.png"></center><br/> Рисунок 5-20. История коммитов после слияния тематических веток.</p>

<p>Это, по всей видимости, наиболее простой рабочий процесс, но при работе с большими проектами здесь возникает ряд проблем.</p>

<p>Если ваш проект более крупный, или вы работаете с большим количеством разработчиков, вы, вероятно, будете применять по крайней мере двухэтапный цикл слияний. При этом сценарии у вас есть две долгоживущие ветки, <code>master</code> и <code>develop</code>, и вы решили, что ветка <code>master</code> обновляется только тогда, когда выходит очень стабильный релиз, а весь новый код включается в ветку <code>develop</code>. Изменения в обеих этих ветках регулярно отправляются в публичный репозиторий. Каждый раз, когда у вас появляется новая тематическая ветка для слияния (рисунок 5-21), вы сначала сливаете её в <code>develop</code> (рисунок 5-22); затем, когда вы выпускаете релиз, вы делаете перемотку (fast-forward) ветки <code>master</code> на нужный стабильный коммит ветки <code>develop</code> (рисунок 5-23).</p>

<p><center><img src="/figures/ch5/18333fig0521-tn.png"></center><br/> Рисунок 5-21. История коммитов до слияния тематической ветки.</p>

<p><center><img src="/figures/ch5/18333fig0522-tn.png"></center><br/> Рисунок 5-22. История коммитов после слияния тематической ветки.</p>

<p><center><img src="/figures/ch5/18333fig0523-tn.png"></center><br/> Рисунок 5-23. История коммитов после появления релиза.</p>

<p>При таком подходе, клонируя ваш репозиторий, люди могут либо выгрузить ветку <code>master</code>, чтобы получить последний стабильный релиз и легко поддерживать этот код обновлённым, либо переключиться на ветку <code>develop</code>, которая включает в себя всё самое свежее. Вы также можете развить данный подход, создав ветку для интегрирования, в которой будет происходить слияние всех наработок. И когда код на этой ветке станет стабилен и пройдёт все тесты, вы сольёте её в ветку <code>develop</code>; и если всё будет работать как надо в течение некоторого времени, вы выполните перемотку ветки <code>master</code>.</p>

<h4 id='____'>Рабочие процессы с крупными слияниями</h4>

<p>В проекте Git имеются четыре долгоживущие ветки: <code>master</code>, <code>next</code>, <code>pu</code> (proposed updates) для новых наработок и <code>maint</code> для ретроподдержки (backports). Когда участники проекта подготавливают свои наработки, они собираются в тематических ветках в репозитории мейнтейнера проекта примерно так, как мы уже описывали (см. рис. 5-24). На этом этапе проводится оценка проделанной работы — всё ли работает как положено, стабилен ли код, или ему требуется доработка. Если всё в порядке, то тематические ветки сливаются в ветку <code>next</code>, которая отправляется на сервер, чтобы у каждого была возможность опробовать интегрированные воедино изменения из тематических веток.</p>

<p><center><img src="/figures/ch5/18333fig0524-tn.png"></center><br/> Рисунок 5-24. Управление группой параллельных тематических веток участников проекта.</p>

<p>Если тематические ветки требуют доработки, они сливаются в ветку <code>pu</code>. Когда будет установлено, что тематические ветки полностью стабильны, они переливаются в <code>master</code>, а ветки <code>pu</code> и <code>next</code> перестраиваются на основе тематических веток, находившихся в <code>next</code>, но ещё не дозревших до <code>master</code>. Это означает, что <code>master</code> практически всегда движется в прямом направлении, ветка <code>next</code> перемещается (rebase) иногда, а ветка <code>pu</code> перемещается чаще всех (см. рис. 5-25).</p>

<p><center><img src="/figures/ch5/18333fig0525-tn.png"></center><br/> Рисунок 5-25. Слияние тематических веток участников проекта в долгоживущие интеграционные ветки.</p>

<p>Когда тематическая ветка была полностью слита в ветку <code>master</code>, она удаляется из репозитория. В проекте Git есть ещё ветка <code>maint</code>, которая ответвлена от последнего релиза и предоставляет backport-патчи, на случай если потребуется выпуск корректировочной версии. Таким образом, когда вы клонируете Git-репозиторий, вы получаете четыре ветки, переключаясь на которые вы можете оценить проект на разных стадиях разработки (в зависимости от того, насколько свежую версию вы хотите получить, или от того, каким образом вы хотите внести в проект свою работу); а мейнтейнер, в свою очередь, имеет структурированный рабочий процесс, который помогает ему изучать новые присланные патчи.</p>

<h4 id='______'>Рабочие процессы с перемещениями и отбором лучшего</h4>

<p>Другие мейнтейнеры вместо слияния предпочитают выполнять перемещение или отбор лучших наработок участников проекта на верхушку своей ветки <code>master</code>, чтобы иметь практически линейную историю разработки. Когда у вас есть наработки в тематической ветке, которые вы хотите интегрировать в проект, вы переходите на эту ветку и запускаете команду <code>rebase</code>, которая перемещает изменения на верхушку вашей текущей ветки <code>master</code> (или <code>develop</code>, и т.п.). Если всё прошло хорошо, то можете выполнить перемотку ветки <code>master</code>, получив тем самым линейную историю работы над проектом.</p>

<p>Другой вариант перемещения сделанных наработок из одной ветки в другую — отбор лучшего (cherry-pick). Отбор лучшего в Git&#8217;е является чем-то наподобие перемещения для отдельных коммитов. Берётся патч, который был представлен в коммите, и делается попытка применить его на ветке, на которой вы сейчас находитесь. Это удобно в том случае, если у вас в тематической ветке находится несколько коммитов, а вы хотите включить в проект только один из них, или если у вас только один коммит в тематической ветке, но вы предпочитаете выполнять отбор лучшего вместо перемещения. Например, предположим, ваш проект выглядит так, как показано на рисунке 5-26.</p>

<p><center><img src="/figures/ch5/18333fig0526-tn.png"></center><br/> Рисунок 5-26. Пример истории коммитов перед отбором лучшего.</p>

<p>Если вы хотите вытащить коммит <code>e43a6</code> в ветку <code>master</code>, выполните:</p>

<pre><code>$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
Finished one cherry-pick.
[master]: created a0a41a9: &quot;More friendly message when locking the index fails.&quot;
 3 files changed, 17 insertions(+), 3 deletions(-)</code></pre>

<p>Эта команда включит в ветку <code>master</code> такие же изменения, которые были добавлены в <code>e43a6</code>, но вы получите новое значение SHA-1 для этого коммита, так как у него будет другая дата применения. Теперь ваша история коммитов выглядит, как показано на рисунке 5-27.</p>

<p><center><img src="/figures/ch5/18333fig0527-tn.png"></center><br/> Рисунок 5-27. История коммитов после отбора лучшего коммита из тематической ветки.</p>

<p>Теперь вы можете удалить свою тематическую ветку и отбросить коммиты, которые вы не захотели включить в проект.</p>

<h3 id='_'>Отметка релизов</h3>

<p>Если вы решили выпустить релиз, вы, вероятно, захотите присвоить ему метку, так чтобы вы потом смогли восстановить этот релиз в любой момент. Процесс создания новой метки обсуждался в главе 2. Если вы решили подписать вашу метку как мейнтейнер, то процедура будет выглядеть примерно следующим образом:</p>

<pre><code>$ git tag -s v1.5 -m &#39;my signed 1.5 tag&#39;
You need a passphrase to unlock the secret key for
user: &quot;Scott Chacon &lt;schacon@gmail.com&gt;&quot;
1024-bit DSA key, ID F721C45A, created 2009-02-09</code></pre>

<p>Если вы подписываете свои метки, у вас может возникнуть проблема с распространением открытого PGP-ключа, используемого для подписи ваших меток. Мейнтейнер проекта Git решил эту проблему, добавив свой публичный ключ в виде блоба (blob) прямо в репозиторий и затем выставив метку, указывающую прямо на содержимое ключа. Чтобы сделать это, определите, какой ключ вам нужен, выполнив <code>gpg --list-keys</code>:</p>

<pre><code>$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon &lt;schacon@gmail.com&gt;
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]</code></pre>

<p>Затем вы можете напрямую импортировать ключ в базу данных Git&#8217;а, экспортировав его и передав по конвейеру команде <code>git hash-object</code>, которая создаст новый блоб с содержимым ключа и вернёт вам SHA-1 этого блоба:</p>

<pre><code>$ gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>

<p>Теперь, когда у вас в Git&#8217;е хранится ваш ключ, вы можете создать метку, напрямую указывающую на него, использовав значение SHA-1, возвращённое командой <code>hash-object</code>:</p>

<pre><code>$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>

<p>Если вы запустите команду <code>git push --tags</code>, то метка <code>maintainer-pgp-pub</code> станет доступна каждому. Если кто-нибудь захочет проверить какую-нибудь метку, он сможет напрямую импортировать ваш PGP-ключ, вытащив блоб прямо из базы данных и импортировав его в GPG:</p>

<pre><code>$ git show maintainer-pgp-pub | gpg --import</code></pre>

<p>Этот ключ может быть использован для проверки любых подписанных вами меток. Кроме того, если вы включите инструкции в сообщение метки, запуск <code>git show &lt;метка&gt;</code> позволит конечному пользователю получить инструкции по проверке меток.</p>

<h3 id='__'>Генерация номера сборки</h3>

<p>Так как коммитам в Git&#8217;е не присваиваются монотонно возрастающие номера наподобие &#8216;v123&#8217; или чего-то аналогичного, то в случае, если вы хотите присвоить коммиту имя, удобное для восприятия, запустите команду <code>git describe</code> для этого коммита. Git вернёт вам имя ближайшей метки с числом коммитов, сделанных поверх этой метки и частичное значения SHA-1 описываемого коммита:</p>

<pre><code>$ git describe master
v1.6.2-rc1-20-g8c5b85c</code></pre>

<p>Таким образом, при экспорте снимка состояния проекта или его сборки вы можете дать им имя, понятное для людей. На самом деле, если вы собираете Git из исходного кода, склонированного из Git-репозитория, <code>git --version</code> вернёт вам что-то подобное. Если вы описываете коммит, которому вы напрямую присвоили метку, команда вернёт вам имя метки.</p>

<p>Команду <code>git describe</code> хорошо использовать с аннотированными метками (метками, созданными при помощи опций <code>-a</code> или <code>-s</code>), так что если вы используете <code>git describe</code>, то метки для релизов должны создаваться этим способом — в этом случае вы сможете удостовериться, что при описании коммиту было дано правильное имя. Вы также можете использовать эту строку в командах <code>checkout</code> и <code>show</code> для указания нужного коммита, однако в будущем она может перестать работать правильно в силу того, что в строке присутствует сокращённое значение SHA-1. Например, в ядре Linux недавно перешли от 8 к 10 символам, необходимым для обеспечения уникальности SHA-1 объектов, и поэтому старые имена, сгенерированные командой <code>git describe</code>, стали недействительными.</p>

<h3 id='_'>Подготовка релиза</h3>

<p>Теперь хотелось бы выпустить релиз сборки. Вероятно, вам захочется сделать архив последнего состояния вашего кода для тех бедолаг, которые не используют Git. Для этого используется команда <code>git archive</code>:</p>

<pre><code>$ git archive master --prefix=&#39;project/&#39; | gzip &gt; `git describe master`.tar.gz
$ ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz</code></pre>

<p>Если кто-нибудь откроет этот tarball, он получит последний снимок состояния вашего проекта внутри каталога <code>project</code>. Таким же способом вы можете создать zip-архив, указав команде <code>git archive</code> опцию <code>--format=zip</code>:</p>

<pre><code>$ git archive master --prefix=&#39;project/&#39; --format=zip &gt; `git describe master`.zip</code></pre>

<p>Теперь у вас есть тарбол и zip-архив с релизом вашего проекта, которые вы можете загрузить на свой сайт или отправить людям по почте.</p>

<h3 id='_shortlog'>Команда shortlog</h3>

<p>Пришло время написать письмо для списка рассылки, чтобы поделиться новостями проекта со всеми, кто им интересуется. При помощи команды <code>git shortlog</code> можно быстро получить что-то наподобие лога изменений (changelog), описывающего, что появилось нового в вашем проекте со времени последнего релиза или последнего письма в список рассылки. Лог изменений включает в себя все коммиты в указанном диапазоне; например, следующая команда вернёт вам сводку по всем коммитам, сделанным со времени прошлого релиза (если последний релиз имел метку v1.0.1):</p>

<pre><code>$ git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (8):
      Add support for annotated tags to Grit::Tag
      Add packed-refs annotated tag support.
      Add Grit::Commit#to_patch
      Update version and History.txt
      Remove stray `puts`
      Make ls_tree ignore nils

Tom Preston-Werner (4):
      fix dates in history
      dynamic version method
      Version bump to 1.0.2
      Regenerated gemspec for version 1.0.2</code></pre>

<p>Мы получили аккуратную сводку по всем коммитам, начиная с метки v1.0.1, сгруппированным по авторам. Вывод этой команды можно послать в свой список рассылки.</p>

<div id='nav'>
<a href='ch5-2.html'>prev</a> | <a href='ch5-4.html'>next</a>
</div>