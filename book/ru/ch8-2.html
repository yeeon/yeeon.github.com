---
layout: translation
title: Pro Git 8.2 Git и другие системы управления версиями Миграция на Git
---
<h2 id='__git'>Миграция на Git</h2>

<p>Если вы решили начать использовать Git, а у вас уже есть база исходного кода в другой СУВ, вам придётся как-то мигрировать свой проект. Этот раздел описывает некоторые из инструментов для импортирования проектов, включённых в состав Git для самых распространённых систем, в конце описывается создание вашего собственного инструмента для импортирования.</p>

<h3 id='id233'>Импортирование</h3>

<p>Вы научитесь импортировать данные из двух самых популярных систем контроля версий — Subversion и Perforce — поскольку они охватывают большинство пользователей, которые переходят на Git, а также потому, что для обеих систем созданы высококлассные инструменты, которые поставляются в составе Git.</p>

<h3 id='subversion'>Subversion</h3>

<p>Если прочли предыдущий раздел об использовании <code>git svn</code>, вы можете с лёгкостью использовать все инструкции, имеющиеся там для клонирования репозитория через <code>git svn clone</code>. Затем можете отказаться от использования сервера Subversion и отправлять изменения на новый Git-сервер, и использовать уже его. Вытащить историю изменений, можно так же быстро, как получить данные с сервера Subversion (что, однако, может занять какое-то время).</p>

<p>Однако, импортирование не будет безупречным. И так как оно занимает много времени, стоит сделать его правильно. Первая проблема это информация об авторах. В Subversion каждый коммитер имеет свою учётную запись в системе, и его имя пользователя отображается в информации о коммите. В примерах из предыдущего раздела выводилось <code>schacon</code> в некоторых местах, например, в выводе команд <code>blame</code> и <code>git svn log</code>. Если вы хотите преобразовать эту информацию для лучшего соответствия данным об авторах в Git, вам потребуется отобразить пользователей Subversion в авторов в Git. Создайте файл <code>users.txt</code>, в котором будут содержаться данные об этом отображении в таком формате:</p>

<pre><code>schacon = Scott Chacon &lt;schacon@geemail.com&gt;
selse = Someo Nelse &lt;selse@geemail.com&gt;</code></pre>

<p>Для того, чтобы получить список авторов, который использует SVN, вы можете выполнить следующее:</p>

<pre><code>$ svn log --xml | grep author | sort -u | perl -pe &#39;s/.&gt;(.?)&lt;./$1 = /&#39;</code></pre>

<p>Это даст вам на выходе журнал в формате XML — в нём вы можете просмотреть информацию об авторах, создать из неё список с уникальными записями и избавиться от XML разметки. (Конечно, эта команда сработает только на машине с установленными <code>grep</code>, <code>sort</code>, и <code>perl</code>). Затем перенаправьте вывод этого скрипта в свой файл users.txt, чтобы потом можно было добавить к каждой записи данные о соответствующих пользователях из Git.</p>

<p>Вы можете передать этот файл как параметр команде <code>git svn</code>, для более точного преобразования данных об авторах. Кроме того, можно дать указание <code>git svn</code> не включать метаданные, обычно импортируемые Subversion, передав параметр <code>--no-metadata</code> команде <code>clone</code> или <code>init</code>. Таким образом, команда для импортирования будет выглядеть так:</p>

<pre><code>$ git-svn clone http://my-project.googlecode.com/svn/ \
      --authors-file=users.txt --no-metadata -s my_project</code></pre>

<p>Теперь в вашем каталоге <code>my_project</code> будут находиться более приятно выглядящие данные после импортирования. Вместо коммитов, которые выглядят так:</p>

<pre><code>commit 37efa680e8473b615de980fa935944215428a35a
Author: schacon &lt;schacon@4c93b258-373f-11de-be05-5f7a86268029&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk

    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-
    be05-5f7a86268029</code></pre>

<p>они будут выглядеть так:</p>

<pre><code>commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2
Author: Scott Chacon &lt;schacon@geemail.com&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk</code></pre>

<p>Теперь не только поле Author выглядит намного лучше, но и строк с <code>git-svn-id</code> больше нет.</p>

<p>Вам потребуется сделать небольшую «уборку» после импорта. Сначала вам нужно убрать странные ссылки, оставленные <code>git svn</code>. Сначала мы переставим все метки так, чтобы они были реальными метками, а не странными удалёнными ветками. А затем мы переместим остальные ветки так, чтобы они стали локальными.</p>

<p>Для приведения меток к корректному виду меток Git выполните:</p>

<pre><code>$ cp -Rf .git/refs/remotes/tags/* .git/refs/tags/
$ rm -Rf .git/refs/remotes/tags</code></pre>

<p>Эти действия переместят ссылки, которые были удалёнными ветками, начинающимися с <code>tag/</code> и сделают их настоящими (легковесными) метками.</p>

<p>Затем, переместите остальные ссылки в <code>refs/remotes</code> так, чтобы они стали локальными ветками:</p>

<pre><code>$ cp -Rf .git/refs/remotes/* .git/refs/heads/
$ rm -Rf .git/refs/remotes</code></pre>

<p>Теперь все старые ветки стали реальными Git-ветками, а все старые метки — реальными метками Git. Последнее, что осталось сделать, это добавить свой Git-сервер в качестве удалённого ресурса и отправить на него данные. Вот пример добавления сервера как удалённого источника:</p>

<pre><code>$ git remote add origin git@my-git-server:myrepository.git</code></pre>

<p>Так как вы хотите, чтобы все ваши ветви и метки были переданы на этот сервер, выполните:</p>

<pre><code>$ git push origin --all</code></pre>

<p>Теперь все ваши ветки и метки должны быть импортированы на новый Git-сервер в чистом и опрятном виде.</p>

<h3 id='perforce'>Perforce</h3>

<p>Следующей системой, для которой мы рассмотрим процедуру импортирования, будет Perforce. Утилита импортирования для Perforce также входит в состав Git, но только в секции <code>contrib</code> исходного кода — она не доступна по умолчанию, как <code>git svn</code>. Для того, чтобы запустить её, вам потребуется получить исходный код Git, располагающийся на git.kernel.org:</p>

<pre><code>$ git clone git://git.kernel.org/pub/scm/git/git.git
$ cd git/contrib/fast-import</code></pre>

<p>В каталоге <code>fast-import</code> вы найдёте исполняемый скрипт Python, с названием <code>git-p4</code>. Вы должны иметь на вашем компьютере установленный Python и утилиту <code>p4</code> для того, чтобы эта утилита смогла работать. Допустим, например, что вы импортируете проект Jam из Perforce Public Depot. Для настройки вашей клиентской машины, вы должны установить переменную окружения P4PORT, указывающую на депо Perforce:</p>

<pre><code>$ export P4PORT=public.perforce.com:1666</code></pre>

<p>Запустите команду <code>git-p4 clone</code> для импортирования проекта Jam с сервера Perforce, передав в качестве параметров депо и путь к проекту, а также путь к месту, куда вы хотите импортировать проект:</p>

<pre><code>$ git-p4 clone //public/jam/src@all /opt/p4import
Importing from //public/jam/src@all into /opt/p4import
Reinitialized existing Git repository in /opt/p4import/.git/
Import destination: refs/remotes/p4/master
Importing revision 4409 (100%)</code></pre>

<p>Если вы теперь перейдёте в каталог <code>/opt/p4import</code> и выполните команду <code>git log</code>, вы увидите импортированную информацию:</p>

<pre><code>$ git log -2
commit 1fd4ec126171790efd2db83548b85b1bbbc07dc2
Author: Perforce staff &lt;support@perforce.com&gt;
Date:   Thu Aug 19 10:18:45 2004 -0800

    Drop &#39;rc3&#39; moniker of jam-2.5.  Folded rc2 and rc3 RELNOTES into
    the main part of the document.  Built new tar/zip balls.

    Only 16 months later.

    [git-p4: depot-paths = &quot;//public/jam/src/&quot;: change = 4409]

commit ca8870db541a23ed867f38847eda65bf4363371d
Author: Richard Geiger &lt;rmg@perforce.com&gt;
Date:   Tue Apr 22 20:51:34 2003 -0800

    Update derived jamgram.c

    [git-p4: depot-paths = &quot;//public/jam/src/&quot;: change = 3108]</code></pre>

<p>Как видите, в каждом коммите есть идентификатор <code>git-p4</code>. Оставить этот идентификатор будет хорошим решением, если позже вам понадобится узнать номер изменения в Perforce. Однако, если вы всё же хотите удалить этот идентификатор — теперь самое время это сделать, до того, как вы начнёте работать в новом репозитории. Можно воспользоваться командой <code>git filter-branch</code> для одновременного удаления всех строк с идентификатором:</p>

<pre><code>$ git filter-branch --msg-filter &#39;
        sed -e &quot;/^\[git-p4:/d&quot;
&#39;
Rewrite 1fd4ec126171790efd2db83548b85b1bbbc07dc2 (123/123)
Ref &#39;refs/heads/master&#39; was rewritten</code></pre>

<p>Если вы теперь выполните <code>git log</code>, то увидите, что все контрольные суммы SHA-1 изменились, и что строки содержащие <code>git-p4</code> больше не появляются в сообщениях коммитов:</p>

<pre><code>$ git log -2
commit 10a16d60cffca14d454a15c6164378f4082bc5b0
Author: Perforce staff &lt;support@perforce.com&gt;
Date:   Thu Aug 19 10:18:45 2004 -0800

    Drop &#39;rc3&#39; moniker of jam-2.5.  Folded rc2 and rc3 RELNOTES into
    the main part of the document.  Built new tar/zip balls.

    Only 16 months later.

commit 2b6c6db311dd76c34c66ec1c40a49405e6b527b2
Author: Richard Geiger &lt;rmg@perforce.com&gt;
Date:   Tue Apr 22 20:51:34 2003 -0800

    Update derived jamgram.c</code></pre>

<p>Ваш импортируемый репозиторий готов к отправке на новый Git-сервер.</p>

<h3 id='___'>Собственная утилита для импорта</h3>

<p>Если вы используете систему отличную от Subversion или Perforce, вы можете поискать утилиту для импорта под свою систему в интернете — для CVS, Clear Case, Visual Source Safe и даже для простого каталога с архивами уже существуют качественные инструменты для импортирования. Если ни один из этих инструментов не подходит для ваших целей, либо если вам нужен больший контроль над процессом импортирования, вам стоит использовать утилиту <code>git fast-import</code>. Эта команда читает простые инструкции со стандартного входа, управляющие процессом записи специфичных данных в Git. Намного проще создать необходимые объекты в Git используя такой подход, чем запуская базовые команды Git, либо пытаясь записать сырые объекты (см. главу 9). При использовании <code>git fast-import</code>, вы можете создать сценарий для импортирования, который считывает всю необходимую информацию из импортируемой системы и выводит прямые инструкции на стандартный вывод. Затем вы просто запускаете этот скрипт и используя конвейер (pipe) передаёте результаты его работы на вход <code>git fast-import</code>.</p>

<p>Чтобы быстро продемонстрировать суть этого подхода, напишем простую утилиту для импорта. Положим, что вы работаете в каталоге <code>current</code>, и время от времени делаете резервную копию этого каталога добавляя к имени дату — <code>back_YYYY_MM_DD</code>, и вы хотите импортировать это всё в Git. Допустим, ваше дерево каталогов выглядит таким образом:</p>

<pre><code>$ ls /opt/import_from
back_2009_01_02
back_2009_01_04
back_2009_01_14
back_2009_02_03
current</code></pre>

<p>Для того, чтобы импортировать всё это в Git, надо вспомнить, как Git хранит данные. Как вы помните, Git в своей основе представляет собой связный список объектов коммитов, указывающих на снимки состояния их содержимого. Всё, что вам требуется, это сообщить команде <code>fast-import</code> что является данными снимков состояния, какие данные коммитов указывают на них и порядок их следования. Стратегией наших действий будет обход всех снимков состояния по очереди и создание соответствующих коммитов с содержимым каждого каталога, с привязкой каждого коммита к предыдущему.</p>

<p>Так же как и в главе 7 в разделе «Пример создания политики в Git», мы напишем сценарий на Ruby, поскольку это то, с чем я обычно работаю, и кроме того он легко читается. Но вы можете создать его на любом другом языке, которым владеете — он просто должен выводить необходимую информацию на стандартный вывод. Если вы работаете под Windows, то должны особым образом позаботиться о том, чтобы в конце строк не содержались символы возврата каретки — <code>git fast-import</code> принимает только символ перевода строки (LF), а не символ перевода строки и возврата каретки (CRLF), который используется в Windows.</p>

<p>Для того, чтобы начать, вы должны перейти в целевой каталог и идентифицировать каждый подкаталог, являющийся снимком состояния, который вы хотите импортировать в виде коммита. Основной цикл будет выглядеть следующим образом:</p>

<pre><code>last_mark = nil

# loop through the directories
Dir.chdir(ARGV[0]) do
  Dir.glob(&quot;*&quot;).each do |dir|
    next if File.file?(dir)

    # move into the target directory
    Dir.chdir(dir) do 
      last_mark = print_export(dir, last_mark)
    end
  end
end</code></pre>

<p>Вы запускаете функцию <code>print_export</code> внутри каждого каталога, она берёт запись и отметку предыдущего снимка состояния и возвращает запись и отметку текущего; таким образом они соединяются нужным образом между собой. «Отметка» — это термин утилиты <code>fast-import</code>, обозначающий идентификатор, который вы даёте коммиту; когда вы создаёте коммиты, вы назначаете каждому из них отметку, которую можно использовать для связывания с другими коммитами. Таким образом, первая операция, которую надо включить в метод <code>print_export</code>, это генерация отметки из имени каталога:</p>

<pre><code>mark = convert_dir_to_mark(dir)</code></pre>

<p>Мы сделаем это путём создания массива каталогов и используя значение порядкового номера каталога в массиве, как его отметку, поскольку отметка должна быть целым числом:</p>

<pre><code>$marks = []
def convert_dir_to_mark(dir)
  if !$marks.include?(dir)
    $marks &lt;&lt; dir
  end
  ($marks.index(dir) + 1).to_s
end</code></pre>

<p>Теперь, когда мы имеем целочисленное представление нашего коммита, нам нужны даты, чтобы указывать их в метаданных коммитов. Поскольку дата записана в имени каталога, мы выделяем её оттуда. Следующей строкой в сценарии <code>print_export</code> будет:</p>

<pre><code>date = convert_dir_to_date(dir)</code></pre>

<p>где метод <code>convert_dir_to_date</code> определён как:</p>

<pre><code>def convert_dir_to_date(dir)
  if dir == &#39;current&#39;
    return Time.now().to_i
  else
    dir = dir.gsub(&#39;back_&#39;, &#39;&#39;)
    (year, month, day) = dir.split(&#39;_&#39;)
    return Time.local(year, month, day).to_i
  end
end</code></pre>

<p>Этот метод возвращает целочисленное значение даты для каждого каталога. Последняя часть метаданных, которая нам нужна для всех коммитов это данные о коммитере, которые мы жёстко задаём в глобальной переменной:</p>

<pre><code>$author = &#39;Scott Chacon &lt;schacon@example.com&gt;&#39;</code></pre>

<p>Теперь мы готовы приступить к выводу данных коммита в своём сценарии импорта. Дадим начальную информацию говорящую, что мы задаём объект коммита, ветку, на которой он находится, затем отметку, которую мы ранее сгенерировали, информацию о коммитере и сообщение коммита, а затем предыдущий коммит, если он есть. Код выглядит следующим образом:</p>

<pre><code># print the import information
puts &#39;commit refs/heads/master&#39;
puts &#39;mark :&#39; + mark
puts &quot;committer #{$author} #{date} -0700&quot;
export_data(&#39;imported from &#39; + dir)
puts &#39;from :&#39; + last_mark if last_mark</code></pre>

<p>Мы жёстко задаём часовой пояс (-0700), поскольку так проще. Если вы импортируете данные из другой системы, вы должны указать часовой пояс в виде смещения. Сообщение коммита должно быть представлено в особом формате:</p>

<pre><code>data (size)\n(contents)</code></pre>

<p>Формат состоит из слова <code>data</code>, размера данных, которые требуется прочесть, символа переноса строки и, наконец, самих данных. Поскольку нам потребуется использовать такой же формат позже, для описания содержимого файла, создадим вспомогательный метод <code>export_data</code>:</p>

<pre><code>def export_data(string)
  print &quot;data #{string.size}\n#{string}&quot;
end</code></pre>

<p>Всё что нам осталось, это описать содержимое файла для каждого снимка состояния. Это просто, поскольку каждый из них содержится в каталоге: мы можем вывести команду <code>deleteall</code>, за которой следует содержимое каждого файла в каталоге. После этого Git соответствующим образом позаботится о регистрации каждого снимка:</p>

<pre><code>puts &#39;deleteall&#39;
Dir.glob(&quot;**/*&quot;).each do |file|
  next if !File.file?(file)
  inline_data(file)
end</code></pre>

<p>Примечание: поскольку многие системы рассматривают свои ревизии как изменения от одного коммита до другого, <code>fast-import</code> также может принимать команды задающие для каждого коммита, какие файлы были добавлены, удалены или модифицированы, а также что является новым содержимым файлов. В нашем примере вы могли бы вычислить разность между снимками состояния и предоставить только эти данные, но это сложнее. С таким же успехом можно предоставить Git все данные для того, чтобы он сам вычислил разницу. Если с вашими данными проще предоставлять разницу между снимками состояния, обратитесь к странице руководства <code>fast-import</code> для получения подробностей о том как предоставлять данные таким способом.</p>

<p>Формат для задания содержимого нового файла, либо указания нового содержимого изменённого файла следующий:</p>

<pre><code>M 644 inline path/to/file
data (size)
(file contents)</code></pre>

<p>Здесь, 644 — это права доступа (если в проекте есть исполняемые файлы, вам надо выявить их и назначить им права доступа 755), а параметр <code>inline</code> говорит о том, что содержимое будет выводиться непосредственно после этой строки. Метод <code>inline_data</code> выглядит следующим образом:</p>

<pre><code>def inline_data(file, code = &#39;M&#39;, mode = &#39;644&#39;)
  content = File.read(file)
  puts &quot;#{code} #{mode} inline #{file}&quot;
  export_data(content)
end</code></pre>

<p>Мы повторно используем метод <code>export_data</code>, определённый ранее, поскольку он работает тут так же, как и при задании сообщений коммитов.</p>

<p>Последнее, что вам осталось сделать, это вернуть текущую отметку, чтобы её можно было передать для использования в следующую итерацию:</p>

<pre><code>return mark</code></pre>

<p>ПРИМЕЧАНИЕ: Если вы работаете под Windows, то должны убедиться, что добавили ещё один дополнительный шаг. Мы уже упоминали, что Windows использует CRLF для перехода на новую строку, тогда как <code>git fast-import</code> ожидает только LF. Для того, чтобы избежать этой проблемы и сделать процесс импорта безошибочным, вам нужно сказать Ruby использовать LF вместо CRLF:</p>

<pre><code>$stdout.binmode</code></pre>

<p>Это всё. Если вы теперь запустите этот сценарий, то получите примерно следующее содержимое:</p>

<pre><code>$ ruby import.rb /opt/import_from 
commit refs/heads/master
mark :1
committer Scott Chacon &lt;schacon@geemail.com&gt; 1230883200 -0700
data 29
imported from back_2009_01_02deleteall
M 644 inline file.rb
data 12
version two
commit refs/heads/master
mark :2
committer Scott Chacon &lt;schacon@geemail.com&gt; 1231056000 -0700
data 29
imported from back_2009_01_04from :1
deleteall
M 644 inline file.rb
data 14
version three
M 644 inline new.rb
data 16
new version one
(...)</code></pre>

<p>Для того, чтобы запустить утилиту импорта, перенаправьте этот вывод на вход <code>git fast-import</code>, находясь в каталоге Git, в который хотите совершить импортирование. Вы можете создать новый каталог, а затем выполнить в нём <code>git init</code> и потом запустить свой сценарий:</p>

<pre><code>$ git init
Initialized empty Git repository in /opt/import_to/.git/
$ ruby import.rb /opt/import_from | git fast-import
git-fast-import statistics:
---------------------------------------------------------------------
Alloc&#39;d objects:       5000
Total objects:           18 (         1 duplicates                  )
      blobs  :            7 (         1 duplicates          0 deltas)
      trees  :            6 (         0 duplicates          1 deltas)
      commits:            5 (         0 duplicates          0 deltas)
      tags   :            0 (         0 duplicates          0 deltas)
Total branches:           1 (         1 loads     )
      marks:           1024 (         5 unique    )
      atoms:              3
Memory total:          2255 KiB
       pools:          2098 KiB
     objects:           156 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize =   33554432
pack_report: core.packedGitLimit      =  268435456
pack_report: pack_used_ctr            =          9
pack_report: pack_mmap_calls          =          5
pack_report: pack_open_windows        =          1 /          1
pack_report: pack_mapped              =       1356 /       1356
---------------------------------------------------------------------</code></pre>

<p>Как видите, после успешного завершения, Git выдаёт большое количество информации о проделанной работе. В нашем случае мы на итог импортировали 18 объектов для 5 коммитов в одну ветку. Теперь выполните <code>git log</code>, чтобы увидеть свою новую историю изменений:</p>

<pre><code>$ git log -2
commit 10bfe7d22ce15ee25b60a824c8982157ca593d41
Author: Scott Chacon &lt;schacon@example.com&gt;
Date:   Sun May 3 12:57:39 2009 -0700

    imported from current

commit 7e519590de754d079dd73b44d695a42c9d2df452
Author: Scott Chacon &lt;schacon@example.com&gt;
Date:   Tue Feb 3 01:00:00 2009 -0700

    imported from back_2009_02_03</code></pre>

<p>Ну вот, вы получили чистый и красивый Git-репозиторий. Важно отметить, что пока у вас нет никаких файлов в рабочем каталоге — вы должны сбросить свою ветку на ветку <code>master</code>:</p>

<pre><code>$ ls
$ git reset --hard master
HEAD is now at 10bfe7d imported from current
$ ls
file.rb  lib</code></pre>

<p>С помощью утилиты <code>fast-import</code> можно делать намного больше — манипулировать разными правами доступа, двоичными данными, несколькими ветками, совершать слияния, назначать метки, отображать индикаторы прогресса и многое другое. Некоторое количество примеров более сложных сценариев содержится в каталоге <code>contrib/fast-import</code> исходного кода Git; один из самых лучших из них — сценарий <code>git-p4</code>, о котором я уже рассказывал.</p>

<div id='nav'>
<a href='ch8-1.html'>prev</a> | <a href='ch8-3.html'>next</a>
</div>