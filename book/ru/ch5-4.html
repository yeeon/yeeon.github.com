---
layout: translation
title: Pro Git 5.4 Распределённый Git Contributing to a Project
---
<h2 id='contributing_to_a_project'>Contributing to a Project</h2>

<p>Вы знаете различные рабочие процессы, также у вас должно быть достаточно хорошее понимание основ использования Git. В этом разделе вы узнаете о нескольких типичных способах содействия проекту.</p>

<p>You know what the different workflows are, and you should have a pretty good grasp of fundamental Git usage. In this section, you’ll learn about a few common patterns for contributing to a project.</p>

<p>Главная трудность в описании этого процесса в том, что существует огромное количество вариаций того, как это устроено. Поскольку Git очень гибок, люди могут делать совместную работу многими способами, и проблематично описать, как вы должны содействовать проекту - каждый проект немного отличается. Некоторые из вовлечённых переменных это количество активных участников, выбранный рабочий процесс, ваш доступ к внесению изменений, и, возможно, внешний способ сотрудничества.</p>

<p>The main difficulty with describing this process is that there are a huge number of variations on how it’s done. Because Git is very flexible, people can and do work together many ways, and it’s problematic to describe how you should contribute to a project — every project is a bit different. Some of the variables involved are active contributor size, chosen workflow, your commit access, and possibly the external contribution method.</p>

<p>Первая переменная это количество активных участников. Как много пользователей активно вносят свой вклад в проект и как часто? Во многих случаях это два-три разработчика с несколькими коммитами в день, возможно, меньше, для вялотекущих проектов. В по-настоящему больших компаниях или проектах число разработчиков может измеряться тысячами, с десятками или даже сотнями ежедневно поступающих патчей. Это важно, поскольку с увеличением числа разработчиков вам становится труднее убедиться, что ваш код ляжет чисто или может быть легко влит. Изменения, которые вы отправляете, могут оказаться устаревшими или частично сломанными той работой, которая была влита пока вы работали или пока ваши изменения ожидали утверждения или применения. Как вы можете сохранять ваш код согласованным и ваши патчи верными?</p>

<p>The first variable is active contributor size. How many users are actively contributing code to this project, and how often? In many instances, you’ll have two or three developers with a few commits a day, or possibly less for somewhat dormant projects. For really large companies or projects, the number of developers could be in the thousands, with dozens or even hundreds of patches coming in each day. This is important because with more and more developers, you run into more issues with making sure your code applies cleanly or can be easily merged. Changes you submit may be rendered obsolete or severely broken by work that is merged in while you were working or while your changes were waiting to be approved or applied. How can you keep your code consistently up to date and your patches valid?</p>

<p>Следующая переменная это рабочий процесс, используемый в проекте. Он централизован, и каждый разработчик имеет равные права на запись в главное хранилище? Есть у проекта хранитель или менеджер по интеграции кто проверяет патчи? Проверяются ли все патчи другими и утверждаются ли? Вы вовлечены в этот процесс? Присутствует ли система помощников и должны ли вы сначала отправлять свою работу им?</p>

<p>The next variable is the workflow in use for the project. Is it centralized, with each developer having equal write access to the main codeline? Does the project have a maintainer or integration manager who checks all the patches? Are all the patches peer-reviewed and approved? Are you involved in that process? Is a lieutenant system in place, and do you have to submit your work to them first?</p>

<p>Следующая проблема это доступ на отправку изменений. Рабочий процесс, требуемый для внесения вклада в проект сильно отличается в зависимости от того, имеете ли вы доступ на запись или нет. Если у вас нету доступа на запись, как в проекте принято принимать вклад в работу? Вообще, существует ли какая-либо политика? Как много работы вы вкладываете за раз? Как часто вы это делаете?</p>

<p>The next issue is your commit access. The workflow required in order to contribute to a project is much different if you have write access to the project than if you don’t. If you don’t have write access, how does the project prefer to accept contributed work? Does it even have a policy? How much work are you contributing at a time? How often do you contribute?</p>

<p>Все эти вопросы могу повлиять на то, как эффективно вы будете вносить вклад в проект и какой рабочий процесс предпочтителен или доступен вам. Я расскажу об аспектах каждого из них в серии примеров использования, продвигаясь от простых к более сложным; вы сможете создать специфический рабочий процесс, нужный вам, из этих примеров.</p>

<p>All these questions can affect how you contribute effectively to a project and what workflows are preferred or available to you. I’ll cover aspects of each of these in a series of use cases, moving from simple to more complex; you should be able to construct the specific workflows you need in practice from these examples.</p>

<h3 id='___'>Руководства по созданию коммитов</h3>

<h3 id='commit_guidelines'>Commit Guidelines</h3>

<p>Прежде чем рассматривать специфичные примеры использования, вот короткая заметка о сообщениях к коммиту. Обладание хорошим руководством по созданию коммитов и следование ему делает работу с Git&#8217;ом и сотрудничество с другими намного проще. Проект Git предоставляет документ с хорошими советами по созданию коммитов, из которых можно делать патчи — вы можете прочитать его в исходном коде Git в файле <code>Documentation/SubmittingPatches</code>.</p>

<p>Before you start looking at the specific use cases, here’s a quick note about commit messages. Having a good guideline for creating commits and sticking to it makes working with Git and collaborating with others a lot easier. The Git project provides a document that lays out a number of good tips for creating commits from which to submit patches — you can read it in the Git source code in the <code>Documentation/SubmittingPatches</code> file.</p>

<p>Во-первых, не отсылайте никаких ошибочных пробелов. Git предоставляет простой способ проверки — перед коммитом, запустите <code>git diff --check</code>, это определит возможные проблемы и перечислит их вам. Вот пример, в котором я заменил красный цвет терминала символами <code>X</code>:</p>

<p>First, you don’t want to submit any whitespace errors. Git provides an easy way to check for this — before you commit, run <code>git diff --check</code>, which identifies possible whitespace errors and lists them for you. Here is an example, where I’ve replaced a red terminal color with <code>X</code>s:</p>

<pre><code>$ git diff --check
lib/simplegit.rb:5: trailing whitespace.
+    @git_dir = File.expand_path(git_dir)XX
lib/simplegit.rb:7: trailing whitespace.
+ XXXXXXXXXXX
lib/simplegit.rb:26: trailing whitespace.
+    def command(git_cmd)XXXX</code></pre>

<p>Если вы запустите эту команду перед коммитом, вы сможете сказать, собираетесь ли вы отправить коммит с проблемными пробелами, что может раздражать других разработчиков.</p>

<p>If you run that command before committing, you can tell if you’re about to commit whitespace issues that may annoy other developers.</p>

<p>Затем, старайтесь делать каждый коммит логически отдельным набором изменений. Если можете, старайтесь делать ваши изменения обозримыми — не надо программировать все выходные или работать над пятью проблемами и затем отправлять их все массивным коммитом в понедельник. Даже если вы не коммитили в течение выходных, используйте индекс для разбиения вашей работы как минимум на один коммит для каждой проблемы, с полезным сообщением к каждому. Если некоторые из изменений затрагивают один и тот же файл, попробуйте использовать <code>git add --patch</code> чтобы частично проиндексировать файлы (рассмотрено в деталях в Главе 6). Слепок проекта на кончике ветки будет идентичным, сделаете ли вы пять коммитов или один, покуда все ваши изменения будут добавлены в какой-то момент, так что попытайтесь облегчить жизнь вашим коллегам разработчикам, когда они должны будут сделать ревю вашим изменениям.</p>

<p>Next, try to make each commit a logically separate changeset. If you can, try to make your changes digestible — don’t code for a whole weekend on five different issues and then submit them all as one massive commit on Monday. Even if you don’t commit during the weekend, use the staging area on Monday to split your work into at least one commit per issue, with a useful message per commit. If some of the changes modify the same file, try to use <code>git add --patch</code> to partially stage files (covered in detail in Chapter 6). The project snapshot at the tip of the branch is identical whether you do one commit or five, as long as all the changes are added at some point, so try to make things easier on your fellow developers when they have to review your changes. This approach also makes it easier to pull out or revert one of the changesets if you need to later. Chapter 6 describes a number of useful Git tricks for rewriting history and interactively staging files — use these tools to help craft a clean and understandable history.</p>

<p>Последняя вещь, которую стоит иметь в виду это сообщение коммита. Хорошая привычка создания качественных сообщений коммита делает использование и сотрудничество посредством Git гораздо проще. По общему правилу, ваши сообщения должны начинаться с единственной строки не длиннее 50 символов, лаконично описывающей набор изменений, затем пустая строка, затем более детальное описание. Проект Git требует, чтобы более детально объяснение включало вашу мотивацию на изменения и противопоставляло эту реализацию с предыдущим поведением — хорошее руководство к действию. Также хорошая идея использование ???</p>

<p>The last thing to keep in mind is the commit message. Getting in the habit of creating quality commit messages makes using and collaborating with Git a lot easier. As a general rule, your messages should start with a single line that’s no more than about 50 characters and that describes the changeset concisely, followed by a blank line, followed by a more detailed explanation. The Git project requires that the more detailed explanation include your motivation for the change and contrast its implementation with previous behavior — this is a good guideline to follow. It’s also a good idea to use the imperative present tense in these messages. In other words, use commands. Instead of &#8220;I added tests for&#8221; or &#8220;Adding tests for,&#8221; use &#8220;Add tests for.&#8221;</p>

<p>Вот шаблон, изначально написанный Tim Pope на tpope.net:</p>

<pre><code>Краткое (50 символов и менее) описание изменений

Более детальное объяснение, если необходимо. Перенос на 72 символе
или около того. В некоторых контекстах, первая строка считается
как тема письма, а остальное телом. Пустая строка, отделяющая сводку
от тела важна (если вы не опустили тело целиком); инструменты, такие
как rebase, могут воспринять неправильно, если вы оставите их вместе.

Дальнейшие параграфы идут после пустых строк

 - также можно применять маркеры списков

 - обычно дефис или звёздочка используются как маркер списка, с
   одним пробелом перед и пустой строкой после каждого пункта, но
   соглашения могут разниться</code></pre>

<p>Here is a template originally written by Tim Pope at tpope.net:</p>

<pre><code>Short (50 chars or less) summary of changes

More detailed explanatory text, if necessary.  Wrap it to about 72
characters or so.  In some contexts, the first line is treated as the
subject of an email and the rest of the text as the body.  The blank
line separating the summary from the body is critical (unless you omit
the body entirely); tools like rebase can get confused if you run the
two together.

Further paragraphs come after blank lines.

 - Bullet points are okay, too

 - Typically a hyphen or asterisk is used for the bullet, preceded by a
   single space, with blank lines in between, but conventions vary here</code></pre>

<p>Если все ваши сообщения о коммитах будут выглядеть как это, всё будет намного проще для вас и для разработчиков с которыми вы работаете. Проект Git содержит хорошо отформатированные сообщения о коммитах - я советую вам запустить <code>git log --no-merges</code> там, чтобы вы увидели, как красиво может выглядеть хорошо отформатированная история коммитов проекта.</p>

<p>If all your commit messages look like this, things will be a lot easier for you and the developers you work with. The Git project has well-formatted commit messages — I encourage you to run <code>git log --no-merges</code> there to see what a nicely formatted project-commit history looks like.</p>

<p>В последующих примерах и в большей части книги для краткости я не форматирую сообщения так красиво, как это; вместо этого я использую опцию <code>-m</code> команды <code>git commit</code>. Делайте как я говорю, а не как я делаю.</p>

<p>In the following examples, and throughout most of this book, for the sake of brevity I don’t format messages nicely like this; instead, I use the <code>-m</code> option to <code>git commit</code>. Do as I say, not as I do.</p>

<h3 id='__'>Отдельная маленькая команда</h3>

<h3 id='private_small_team'>Private Small Team</h3>

<p>Наиболее простая задача, с которой вы легко можете столкнуться — отдельный проект с одним или двумя другими разработчиками. Под термином отдельный я подразумеваю закрытый код, недоступный для чтения остальному миру. Вы, вместе с другими разработчиками, имеете право записи в репозиторий.</p>

<p>The simplest setup you’re likely to encounter is a private project with one or two other developers. By private, I mean closed source — not read-accessible to the outside world. You and the other developers all have push access to the repository.</p>

<p>В этом окружении вы можете последовать рабочему процессу, похожему на тот, который вы использовали бы в Subversion или другой централизованной системе. Вы по-прежнему получаете такие преимущества, как локальные коммиты (коммиты в offline) и возможность гораздо более простого ветвления и слияния, но сам рабочий процесс может оставаться очень похожим; главное отличие — во время выполнения коммита слияние происходит на стороне клиента, а не на сервере. Давайте посмотрим, как это может выглядеть, когда два разработчика начинают работать вместе с общим репозиторием. Первый разработчик, Джон, клонирует репозиторий, делает изменения, выполняет локальный коммит. (Я заменяю служебные сообщения знаком <code>...</code> в этих примерах, чтобы немного их сократить.)</p>

<p>In this environment, you can follow a workflow similar to what you might do when using Subversion or another centralized system. You still get the advantages of things like offline committing and vastly simpler branching and merging, but the workflow can be very similar; the main difference is that merges happen client-side rather than on the server at commit time. Let’s see what it might look like when two developers start to work together with a shared repository. The first developer, John, clones the repository, makes a change, and commits locally. (I’m replacing the protocol messages with <code>...</code> in these examples to shorten them somewhat.)</p>

<pre><code># John&#39;s Machine
$ git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/
...
$ cd simplegit/
$ vim lib/simplegit.rb 
$ git commit -am &#39;removed invalid default value&#39;
[master 738ee87] removed invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>

<p>Второй разработчик, Джессика, выполняет тоже самое — клонирует репозиторий и делает коммит с изменениями:</p>

<p>The second developer, Jessica, does the same thing — clones the repository and commits a change:</p>

<pre><code># Jessica&#39;s Machine
$ git clone jessica@githost:simplegit.git
Initialized empty Git repository in /home/jessica/simplegit/.git/
...
$ cd simplegit/
$ vim TODO 
$ git commit -am &#39;add reset task&#39;
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>

<p>Теперь Джессика выкладывает свою работу на сервер:</p>

<p>Now, Jessica pushes her work up to the server:</p>

<pre><code># Jessica&#39;s Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -&gt; master</code></pre>

<p>Джон также пытается выложить свои изменения:</p>

<p>John tries to push his change up, too:</p>

<pre><code># John&#39;s Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -&gt; master (non-fast forward)
error: failed to push some refs to &#39;john@githost:simplegit.git&#39;</code></pre>

<p>Джон не может выполнить отправку изменений, так как за это время Джессика уже отправила свои. Очень важно это понимать, если вы использовали Subversion, так как вы видите, что два разработчика не редактировали один и тот же файл. Хотя Subversion и выполняет автоматическое слияние на сервере, если были отредактированы разные файлы, используя Git вы должны слить коммиты локально. Прежде чем Джон сможет отправить свои изменения на сервер, он должен извлечь наработки Джессики и выполнить слияние:</p>

<p>John isn’t allowed to push because Jessica has pushed in the meantime. This is especially important to understand if you’re used to Subversion, because you’ll notice that the two developers didn’t edit the same file. Although Subversion automatically does such a merge on the server if different files are edited, in Git you must merge the commits locally. John has to fetch Jessica’s changes and merge them in before he will be allowed to push:</p>

<pre><code>$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -&gt; origin/master</code></pre>

<p>На этот момент, локальный репозиторий Джона выглядит так, как показано на Рисунке 5-4.</p>

<p>At this point, John’s local repository looks something like Figure 5-4.</p>

<p><center><img src="/figures/ch5/18333fig0504-tn.png"></center><br/> Рисунок 5-4. Начальный репозиторий Джона.</p>

<p>Figure 5-4. John’s initial repository.</p>

<p>Джон имеет ссылку на изменения, выложенные Джессикой, и он должен слить их вместе со своей работой до того, как сможет отправить ее на сервер:</p>

<p>John has a reference to the changes Jessica pushed up, but he has to merge them into his own work before he is allowed to push:</p>

<pre><code>$ git merge origin/master
Merge made by recursive.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>

<p>Слияние происходит без проблем — история коммитов Джона теперь выглядит как на Рисунке 5-5.</p>

<p>The merge goes smoothly — John’s commit history now looks like Figure 5-5.</p>

<p><center><img src="/figures/ch5/18333fig0505-tn.png"></center><br/> Рисунок 5-5. Репозиторий Джона после слияния с версией origin/master.</p>

<p>Figure 5-5. John’s repository after merging origin/master.</p>

<p>Теперь Джон может протестировать его код, дабы удостовериться, что он по-прежнему работает нормально, а затем выложить свою работу, уже объединенную с работой Джессики, на сервер:</p>

<p>Now, John can test his code to make sure it still works properly, and then he can push his new merged work up to the server:</p>

<pre><code>$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -&gt; master</code></pre>

<p>В результате, история коммитов Джона выглядит как на Рисунке 5-6.</p>

<p>Finally, John’s commit history looks like Figure 5-6.</p>

<p><center><img src="/figures/ch5/18333fig0506-tn.png"></center><br/> Рисунок 5-6. История коммитов Джона после отправки изменений на сервер.</p>

<p>Figure 5-6. John’s history after pushing to the origin server.</p>

<p>Тем временем, Джессика работала над тематической веткой. Она создала тематическую ветку с названием <code>issue54</code> и сделала три коммита в этой ветке. Она еще не извлекала изменения Джонна, так что ее история коммитов выглядит как на Рисунке 5-7.</p>

<p>In the meantime, Jessica has been working on a topic branch. She’s created a topic branch called <code>issue54</code> and done three commits on that branch. She hasn’t fetched John’s changes yet, so her commit history looks like Figure 5-7.</p>

<p><center><img src="/figures/ch5/18333fig0507-tn.png"></center><br/> Рисунок 5-7. Начальная история коммитов Джессики.</p>

<p>Figure 5-7. Jessica’s initial commit history.</p>

<p>Джессика хочет синхронизировать свою работу с Джоном, так что она извлекает изменения с сервера:</p>

<p>Jessica wants to sync up with John, so she fetches:</p>

<pre><code># Jessica&#39;s Machine
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -&gt; origin/master</code></pre>

<p>Эта команда извлекает наработки Джона, которые он успел выложить. История коммитов Джессики теперь выглядит как на Рисунке 5-8.</p>

<p>That pulls down the work John has pushed up in the meantime. Jessica’s history now looks like Figure 5-8.</p>

<p><center><img src="/figures/ch5/18333fig0508-tn.png"></center><br/> Рисунок 5-8. История коммитов Джессики после извлечения изменений Джона.</p>

<p>Figure 5-8. Jessica’s history after fetching John’s changes.</p>

<p>Джессика полагает, что ее тематическая ветка закончена, но она хочет узнать, как выполнить слияние своей работы, чтобы она могла выложить ее на сервер. Она выполняет команду <code>git log</code> чтобы выяснить это:</p>

<p>Jessica thinks her topic branch is ready, but she wants to know what she has to merge her work into so that she can push. She runs <code>git log</code> to find out:</p>

<pre><code>$ git log --no-merges origin/master ^issue54
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 16:01:27 2009 -0700

    removed invalid default value</code></pre>

<p>Теперь Джессика может слить свою тематическую ветку с ее основной веткой, слить работу Джона (<code>origin/master</code>) с ее веткой <code>master</code> и, затем, отправить изменения на сервер. Сначала она переключается на свою основную ветку, чтобы объединить всю эту работу:</p>

<p>Now, Jessica can merge her topic work into her master branch, merge John’s work (<code>origin/master</code>) into her <code>master</code> branch, and then push back to the server again. First, she switches back to her master branch to integrate all this work:</p>

<pre><code>$ git checkout master
Switched to branch &quot;master&quot;
Your branch is behind &#39;origin/master&#39; by 2 commits, and can be fast-forwarded.</code></pre>

<p>Сначала она может слить ветку <code>origin/master</code> или <code>issue54</code> — обе они находятся выше в истории коммитов, так что не важно какой порядок слияния она выберет. Конечное состояние репозитория должно быть идентично независимо от того, какой порядок слияния она выбрала; только история коммитов будет немного разная. Сначала она выполняет слияние для ветки <code>issue54</code>:</p>

<p>She can merge either <code>origin/master</code> or <code>issue54</code> first — they’re both upstream, so the order doesn’t matter. The end snapshot should be identical no matter which order she chooses; only the history will be slightly different. She chooses to merge in <code>issue54</code> first:</p>

<pre><code>$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)</code></pre>

<p>Никаких проблем не возникает; как вы видите, это был обычный fast-forward. Теперь Джессика выполняет слияние с работой Джона (<code>origin/master</code>):</p>

<p>No problems occur; as you can see it, was a simple fast-forward. Now Jessica merges in John’s work (<code>origin/master</code>):</p>

<pre><code>$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>

<p>Слияние проходит нормально, и теперь история коммитов Джессики выглядит как на Рисунке 5-9.</p>

<p>Everything merges cleanly, and Jessica’s history looks like Figure 5-9.</p>

<p><center><img src="/figures/ch5/18333fig0509-tn.png"></center><br/> Рисунок 5-9. История коммитов Джессики после слияния с изменениями Джона.</p>

<p>Figure 5-9. Jessica’s history after merging John’s changes.</p>

<p>Теперь указатель <code>origin/master</code> доступен из ветки <code>master</code> Джессики, так что она может спокойно выкладывать свои изменения (полагая, что Джон не выкладывал свои изменения в это время):</p>

<p>Now <code>origin/master</code> is reachable from Jessica’s <code>master</code> branch, so she should be able to successfully push (assuming John hasn’t pushed again in the meantime):</p>

<pre><code>$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -&gt; master</code></pre>

<p>Каждый разработчик несколько раз выполнял коммиты и успешно сливал свою работу с работой другого; смотри Рисунок 5-10.</p>

<p>Each developer has committed a few times and merged each other’s work successfully; see Figure 5-10.</p>

<p><center><img src="/figures/ch5/18333fig0510-tn.png"></center><br/> Рисунок 5-10. История коммитов Джессики после отправки всех изменений обратно на сервер.</p>

<p>Figure 5-10. Jessica’s history after pushing all changes back to the server.</p>

<p>Это один из простейших рабочих процессов. Вы работаете некоторое время, преимущественно в тематической ветке, и, когда приходит время, сливаете ее в вашу ветку master. Когда вы готовы поделиться этой работой с другими, вы сливаете ее в вашу ветку master, извлекаете изменения из <code>origin/master</code> и выполняете слияние (если за это время произошли изменения), и, наконец, отправляете изменения в ветку <code>master</code> на сервер. Общая последовательность действий выглядит так, как показано на Рисунке 5-11.</p>

<p>That is one of the simplest workflows. You work for a while, generally in a topic branch, and merge into your master branch when it’s ready to be integrated. When you want to share that work, you merge it into your own master branch, then fetch and merge <code>origin/master</code> if it has changed, and finally push to the <code>master</code> branch on the server. The general sequence is something like that shown in Figure 5-11.</p>

<p><center><img src="/figures/ch5/18333fig0511-tn.png"></center><br/> Рисунок 5-11. Общая последовательность событий для простого рабочего процесса в Git&#8217;е с несколькими разработчиками.</p>

<p>Figure 5-11. General sequence of events for a simple multiple-developer Git workflow.</p>

<h3 id='___'>Отдельная команда с менеджером</h3>

<h3 id='private_managed_team'>Private Managed Team</h3>

<p>В этом сценарии мы рассмотрим роли участников проекта, являющихся членами больших отдельных групп. Вы научитесь работе в окружении, где маленькие группы совместно работают над задачами, результаты деятельности которых, впоследствии, объединяется отдельной группой лиц.</p>

<p>In this next scenario, you’ll look at contributor roles in a larger private group. You’ll learn how to work in an environment where small groups collaborate on features and then those team-based contributions are integrated by another party.</p>

<p>Давайте представим, что Джон и Джессика работают вместе над одной задачей, в то время как Джессика и Джози работают над другой. В этом случае компания использует рабочий процесс с менеджером по интеграции, когда работа частных групп объединяется только определенными инженерами (обновление ветки <code>master</code> главного репозитория может осуществляться только этими инженерами). В этом случае вся работа выполняется в ветках отдельных команд разработчиков и, впоследствии, объединяется вместе менеджерами по интеграции.</p>

<p>Let’s say that John and Jessica are working together on one feature, while Jessica and Josie are working on a second. In this case, the company is using a type of integration-manager workflow where the work of the individual groups is integrated only by certain engineers, and the <code>master</code> branch of the main repo can be updated only by those engineers. In this scenario, all work is done in team-based branches and pulled together by the integrators later.</p>

<p>Давайте рассмотрим рабочий процесс Джессики, которая работает над двумя задачами и, таким образом, одновременно принимает участие в работе с двумя другими разработчиками. Полагая, что она уже имеет ее собственную копию репозитория, Джессика решает сначала взяться за задачу <code>featureA</code>. Для этого она создает новую ветку и выполняет на ней некоторую работу:</p>

<p>Let’s follow Jessica’s workflow as she works on her two features, collaborating in parallel with two different developers in this environment. Assuming she already has her repository cloned, she decides to work on <code>featureA</code> first. She creates a new branch for the feature and does some work on it there:</p>

<pre><code># Jessica&#39;s Machine
$ git checkout -b featureA
Switched to a new branch &quot;featureA&quot;
$ vim lib/simplegit.rb
$ git commit -am &#39;add limit to log function&#39;
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>

<p>На этом этапе ей требуется поделиться своей работой с Джоном, так что она отправляет коммиты, выполненные на ветке <code>featureA</code>, на сервер. Так как Джессика не имеет право на изменения ветки <code>master</code> на сервере — только менеджеры по интеграции могут делать это — она вынуждена отправлять изменения в другую ветку, чтобы иметь возможность работать вместе с Джоном:</p>

<p>At this point, she needs to share her work with John, so she pushes her <code>featureA</code> branch commits up to the server. Jessica doesn’t have push access to the <code>master</code> branch — only the integrators do — so she has to push to another branch in order to collaborate with John:</p>

<pre><code>$ git push origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -&gt; featureA</code></pre>

<p>Джессика сообщает по электронной почте Джону, что она выложила некоторые наработки в ветку <code>featureA</code>, и что он может проверить их. Пока Джессика ждет ответа от Джона, она решает начать работу над веткой <code>featureB</code> вместе с Джози. Для начала она создает новую ветку для этой задачи, используя в качестве основы ветку <code>master</code> на сервере:</p>

<p>Jessica e-mails John to tell him that she’s pushed some work into a branch named <code>featureA</code> and he can look at it now. While she waits for feedback from John, Jessica decides to start working on <code>featureB</code> with Josie. To begin, she starts a new feature branch, basing it off the server’s <code>master</code> branch:</p>

<pre><code># Jessica&#39;s Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch &quot;featureB&quot;</code></pre>

<p>Теперь Джессика выполняет пару коммитов в ветке <code>featureB</code>:</p>

<p>Now, Jessica makes a couple of commits on the <code>featureB</code> branch:</p>

<pre><code>$ vim lib/simplegit.rb
$ git commit -am &#39;made the ls-tree function recursive&#39;
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am &#39;add ls-files&#39;
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)</code></pre>

<p>Репозиторий Джессики выглядит как на Рисунке 5-12.</p>

<p>Jessica’s repository looks like Figure 5-12.</p>

<p><center><img src="/figures/ch5/18333fig0512-tn.png"></center><br/> Рисунок 5-12. Начальная история коммитов Джессики.</p>

<p>Figure 5-12. Jessica’s initial commit history.</p>

<p>Джессика уже готова выложить на сервер свою работу, но получает сообщение от Джози, говорящее о том, что некоторые наработки уже были выложены на сервер в ветку <code>featureBee</code>. Поэтому Джессика должна сначала слить эти изменения со своими, прежде чем она сможет отправить свою работу на сервер. Она может извлечь изменения Джози командой <code>git fetch</code>:</p>

<p>She’s ready to push up her work, but gets an e-mail from Josie that a branch with some initial work on it was already pushed to the server as <code>featureBee</code>. Jessica first needs to merge those changes in with her own before she can push to the server. She can then fetch Josie’s changes down with <code>git fetch</code>:</p>

<pre><code>$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -&gt; origin/featureBee</code></pre>

<p>Теперь Джессика может слить эти изменения со своими наработками командой <code>git merge</code>:</p>

<p>Jessica can now merge this into the work she did with <code>git merge</code>:</p>

<pre><code>$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)</code></pre>

<p>Есть небольшая проблема — ей нужно выложить изменения из ее ветки <code>featureB</code> в ветку <code>featureBee</code> на сервере. Она может сделать это при помощи команды <code>git push</code>, последовательно указывая название локальной и удаленной веток, разделенные знаком двоеточия:</p>

<p>There is a bit of a problem — she needs to push the merged work in her <code>featureB</code> branch to the <code>featureBee</code> branch on the server. She can do so by specifying the local branch followed by a colon (:) followed by the remote branch to the <code>git push</code> command:</p>

<pre><code>$ git push origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -&gt; featureBee</code></pre>

<p>Это называется <em>refspec</em>. Смотри Главу 9, где более детально обсуждаются спецификации ссылок и различные вещи, которые вы можете делать с ними.</p>

<p>This is called a <em>refspec</em>. See Chapter 9 for a more detailed discussion of Git refspecs and different things you can do with them.</p>

<p>Далее, Джон сообщает Джессике по почте, что он добавил некоторые изменения в ветку <code>featureA</code> и просит ее проверить их. Она выполняет <code>git fetch</code> чтобы получить внесенные Джоном изменения:</p>

<p>Next, John e-mails Jessica to say he’s pushed some changes to the <code>featureA</code> branch and ask her to verify them. She runs a <code>git fetch</code> to pull down those changes:</p>

<pre><code>$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -&gt; origin/featureA</code></pre>

<p>Затем, применяя команду <code>git log</code> она смотрит, что же было изменено:</p>

<p>Then, she can see what has been changed with <code>git log</code>:</p>

<pre><code>$ git log origin/featureA ^featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25</code></pre>

<p>Наконец, она сливает работу Джона в свою собственную ветку <code>featureA</code>:</p>

<p>Finally, she merges John’s work into her own <code>featureA</code> branch:</p>

<pre><code>$ git checkout featureA
Switched to branch &quot;featureA&quot;
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)</code></pre>

<p>Джессика хочет кое-что подправить, так что она опять делает коммит и затем выкладывает изменения на сервер:</p>

<p>Jessica wants to tweak something, so she commits again and then pushes this back up to the server:</p>

<pre><code>$ git commit -am &#39;small tweak&#39;
[featureA ed774b3] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push origin featureA
...
To jessica@githost:simplegit.git
   3300904..ed774b3  featureA -&gt; featureA</code></pre>

<p>История коммитов Джессики теперь выглядит так, как показано на Рисунке 5-13.</p>

<p>Jessica’s commit history now looks something like Figure 5-13.</p>

<p><center><img src="/figures/ch5/18333fig0513-tn.png"></center><br/> Рисунок 5-13. История Джессики после внесения коммитов в ветку с решаемой задачей.</p>

<p>Figure 5-13. Jessica’s history after committing on a feature branch.</p>

<p>Джессика, Джози и Джон информируют менеджеров по интеграции, что ветки <code>featureA</code> и <code>featureBee</code> на сервере готовы к внесению в основную версию разработки. После того, как они внесут эти ветки в основную версию, извлечение данных с сервера (fetch) приведет к появлению новых коммитов слияния. Таким образом, история коммитов станет выглядеть как на Рисунке 5-14.</p>

<p>Jessica, Josie, and John inform the integrators that the <code>featureA</code> and <code>featureBee</code> branches on the server are ready for integration into the mainline. After they integrate these branches into the mainline, a fetch will bring down the new merge commits, making the commit history look like Figure 5-14.</p>

<p><center><img src="/figures/ch5/18333fig0514-tn.png"></center><br/> Рисунок 5-14. История коммитов Джессики после слияния двух тематических веток.</p>

<p>Figure 5-14. Jessica’s history after merging both her topic branches.</p>

<p>Множество групп переходят на Git именно из-за возможности работы нескольких команд в параллели с последующим объединением разных линий разработки. Огромное преимущество Git&#8217;а — возможность маленьких подгрупп большой команды работать вместе через удаленные ветки, не мешая при этом всей команде. Последовательность событий в рассмотренном здесь рабочем процессе представлена на Рисунке 5-15.</p>

<p>Many groups switch to Git because of this ability to have multiple teams working in parallel, merging the different lines of work late in the process. The ability of smaller subgroups of a team to collaborate via remote branches without necessarily having to involve or impede the entire team is a huge benefit of Git. The sequence for the workflow you saw here is something like Figure 5-15.</p>

<p><center><img src="/figures/ch5/18333fig0515-tn.png"></center><br/> Рисунок 5-15. Основная последовательность действий для рабочего процесса в команде с менеджером по интеграции.</p>

<p>Figure 5-15. Basic sequence of this managed-team workflow.</p>

<h3 id='__'>Небольшой открытый проект</h3>

<h3 id='public_small_project'>Public Small Project</h3>

<p>Работа в открытом проекте является несколько иной задачей. Так как вы не имеете права на прямое изменение веток проекта, требуется некоторый другой путь для обмена наработками с мейнтейнерами. Первый пример описывает участие в проекте через разветвление (fork) на хосте Git&#8217;а, выполнять которое достаточно просто. Оба сайта, repo.or.cz и Github, поддерживают такую возможность, и большая часть мейнтейнеров проектов придерживаются такого способа содействия. В следующем разделе рассматриваются проекты, в которых патчи принимаются по e-mail.</p>

<p>Contributing to public projects is a bit different. Because you don’t have the permissions to directly update branches on the project, you have to get the work to the maintainers some other way. This first example describes contributing via forking on Git hosts that support easy forking. The repo.or.cz and GitHub hosting sites both support this, and many project maintainers expect this style of contribution. The next section deals with projects that prefer to accept contributed patches via e-mail.</p>

<p>Сначала вы скорее всего захотите клонировать основной репозиторий, создать тематическую ветку одного или нескольких патчей, которые вы собираетесь внести в проект, и выполнить здесь некоторую работу. Последовательность действий выглядит следующим образом:</p>

<p>First, you’ll probably want to clone the main repository, create a topic branch for the patch or patch series you’re planning to contribute, and do your work there. The sequence looks basically like this:</p>

<pre><code>$ git clone (url)
$ cd project
$ git checkout -b featureA
$ (work)
$ git commit
$ (work)
$ git commit</code></pre>

<p>Возможно вы захотите использовать <code>rebase -i</code>, чтобы сжать ваши наработки в единый коммит, или таким образом реорганизовать наработки в коммитах, чтобы их было проще воспринимать мейнтейнерам проекта. Смотри Главу 6 для более детальной информации об интерактивном перемещении.</p>

<p>You may want to use <code>rebase -i</code> to squash your work down to a single commit, or rearrange the work in the commits to make the patch easier for the maintainer to review — see Chapter 6 for more information about interactive rebasing.</p>

<p>Когда вы закончили работу с веткой и готовы поделиться наработками с мейнтейнерами, перейдите на страницу исходного проекта и нажмите кнопку &#8220;Fork&#8221;, создав таким образом вашу собственную ветвь проекта с правами записи в нее. Далее вы должны добавить URL этого нового репозитория в список удаленных репозиториев, назвав его, например как в этом случае, <code>myfork</code>:</p>

<p>When your branch work is finished and you’re ready to contribute it back to the maintainers, go to the original project page and click the &#8220;Fork&#8221; button, creating your own writable fork of the project. You then need to add in this new repository URL as a second remote, in this case named <code>myfork</code>:</p>

<pre><code>$ git remote add myfork (url)</code></pre>

<p>Свои наработки вы должны выкладывать в этот репозиторий. Гораздо проще добавить в ваш репозиторий ветку, над которой вы работаете, как удаленную, чем сливать ее в вашу ветку master и выкладывать. Это объясняется тем следующим образом — если ваша работа не принята или частично отобрана вы не должны перематывать вашу ветку master. Если мейнтейнеры выполняют слияние, перемещение или частично отбирают вашу работу, вы, в конечном счете, можете получить ее обратно скачивая (pulling) из их репозитория:</p>

<p>You need to push your work up to it. It’s easiest to push the remote branch you’re working on up to your repository, rather than merging into your master branch and pushing that up. The reason is that if the work isn’t accepted or is cherry picked, you don’t have to rewind your master branch. If the maintainers merge, rebase, or cherry-pick your work, you’ll eventually get it back via pulling from their repository anyhow:</p>

<pre><code>$ git push myfork featureA</code></pre>

<p>Когда ваши наработки были отправлены в ваш репозиторий, вы должны уведомить мейнтейнера. Часто это называется запросом на включение (pull request) и вы можете либо сгенерировать его через сайт — на GitHub&#8217;е есть кнопка &#8220;pull request&#8221;, автоматически уведомляющая мейнтейнера — либо выполнить команду <code>git request-pull</code> и вручную отправить ее вывод по почте мейнтейнеру.</p>

<p>When your work has been pushed up to your fork, you need to notify the maintainer. This is often called a pull request, and you can either generate it via the website — GitHub has a &#8220;pull request&#8221; button that automatically messages the maintainer — or run the <code>git request-pull</code> command and e-mail the output to the project maintainer manually.</p>

<p>Команда <code>request-pull</code> принимает в качестве аргумента название базовой ветки, в которую вы хотите включить вашу работу, и URL репозитория, из которого эти наработки могут быть получены. Команда выводит в список всех изменений, которые вы просите включить в проект. Например, если Джессика хочет послать Джону pull request когда она сделала пару коммитов в тематической ветке, которую она только что выложила, ей следует выполнить:</p>

<p>The <code>request-pull</code> command takes the base branch into which you want your topic branch pulled and the Git repository URL you want them to pull from, and outputs a summary of all the changes you’re asking to be pulled in. For instance, if Jessica wants to send John a pull request, and she’s done two commits on the topic branch she just pushed up, she can run this:</p>

<pre><code>$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
  John Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)</code></pre>

<p>Вывод может быть отправлен мейнтейнеру — он содержит список коммитов, информацию о том, где начинается ветка с изменениями, указывает, откуда забрать эти изменения.</p>

<p>The output can be sent to the maintainer—it tells them where the work was branched from, summarizes the commits, and tells where to pull this work from.</p>

<p>Для проекта, мейнтейнером которого вы не являетесь, проще иметь ветку <code>master</code>, которая отслеживает ветку <code>origin/master</code>, и выполнять работу в тематических ветках, которые вы легко можете удалить, если они были отклонены. Если вы распределяете свои наработки по различным темам внутри тематических веток, вам проще выполнить перемещение своей работы, в случае если верхушка главного репозитория была передвинута за это время и ваши коммиты уже не получается применить без конфликтов. Например, если вы хотите выполнить работу по второй теме, не продолжайте работу внутри тематической ветки, которую вы только что отправили - начните снова с ветки <code>master</code> главного репозитория:</p>

<p>On a project for which you’re not the maintainer, it’s generally easier to have a branch like <code>master</code> always track <code>origin/master</code> and to do your work in topic branches that you can easily discard if they’re rejected. Having work themes isolated into topic branches also makes it easier for you to rebase your work if the tip of the main repository has moved in the meantime and your commits no longer apply cleanly. For example, if you want to submit a second topic of work to the project, don’t continue working on the topic branch you just pushed up — start over from the main repository’s <code>master</code> branch:</p>

<pre><code>$ git checkout -b featureB origin/master
$ (work)
$ git commit
$ git push myfork featureB
$ (email maintainer)
$ git fetch origin</code></pre>

<p>Теперь каждая из ваших тем представляет собой нечто похожее на очередь из патчей, которую вы можете перезаписывать, перемещать, модифицировать без взаимного влияния одной на другую, как показано на Рисунке 5-16.</p>

<p>Now, each of your topics is contained within a silo — similar to a patch queue — that you can rewrite, rebase, and modify without the topics interfering or interdepending on each other as in Figure 5-16.</p>

<p><center><img src="/figures/ch5/18333fig0516-tn.png"></center><br/> Рисунок 5-16. Начальная история коммитов при работе в featureB.</p>

<p>Figure 5-16. Initial commit history with featureB work.</p>

<p>Давайте представим, что мейнтейнер проекта включил в основную версию группу патчей. Далее он попытается включить вашу первую ветку, но слияние уже не проходит гладко. В этом случае вы можете попробовать переместить эту ветку на верхушку ветки <code>origin/master</code>, разрешить конфликты для мейнтейнера и, затем, заново предложить ваши изменения:</p>

<p>Let’s say the project maintainer has pulled in a bunch of other patches and tried your first branch, but it no longer cleanly merges. In this case, you can try to rebase that branch on top of <code>origin/master</code>, resolve the conflicts for the maintainer, and then resubmit your changes:</p>

<pre><code>$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA</code></pre>

<p>Это изменит вашу историю коммитов, и она станет выглядеть как на Рисунке 5-17.</p>

<p>This rewrites your history to now look like Figure 5-17.</p>

<p><center><img src="/figures/ch5/18333fig0517-tn.png"></center><br/> Рисунок 5-17. История коммитов после работы в featureA.</p>

<p>Figure 5-17. Commit history after featureA work.</p>

<p>Так как вы переместили ветку, в команде push вы должны указать опцию <code>-f</code>, чтобы иметь возможность заменить ветку <code>featureA</code> на сервере. Есть альтернатива — выложить новую работу в другую ветку на сервере (возможно, назвав ее <code>featureAv2</code>).</p>

<p>Because you rebased the branch, you have to specify the <code>-f</code> to your push command in order to be able to replace the <code>featureA</code> branch on the server with a commit that isn’t a descendant of it. An alternative would be to push this new work to a different branch on the server (perhaps called <code>featureAv2</code>).</p>

<p>Давайте рассмотрим более возможный сценарий: мейнтейнер просмотрел на вашу работу во второй ветке и ему понравилась идея, но он хотел бы, чтобы вы изменили некоторые детали реализации. Также вы используете эту возможность для того, чтобы переместить вашу работу так, чтобы она базировалась на текущей версии ветки <code>master</code> проекта. Вы создадите новую ветку, базирующуюся на текущей ветке <code>origin/master</code>, сожмете изменения из ветки <code>featureB</code>, решите все конфликты, которые могут возникнуть, выполните требуемые изменения в реализации вашей идеи и, затем, выложите все это в виде новой ветки:</p>

<p>Let’s look at one more possible scenario: the maintainer has looked at work in your second branch and likes the concept but would like you to change an implementation detail. You’ll also take this opportunity to move the work to be based off the project’s current <code>master</code> branch. You start a new branch based off the current <code>origin/master</code> branch, squash the <code>featureB</code> changes there, resolve any conflicts, make the implementation change, and then push that up as a new branch:</p>

<pre><code>$ git checkout -b featureBv2 origin/master
$ git merge --no-commit --squash featureB
$ (change implementation)
$ git commit
$ git push myfork featureBv2</code></pre>

<p>Опция <code>--squash</code> берет все работу на сливаемой ветке (featureB) и сжимает ее в non-merge коммит (коммит без слияния) на верхушку ветки, на которой вы сейчас находитесь. Опция <code>--no-commit</code> сообщает Git&#8217;у, что не нужно автоматически записывать коммит в историю. Это позволяет вам внести все изменения с другой ветки и, затем, сделать еще ряд изменений перед записыванием нового коммита.</p>

<p>The <code>--squash</code> option takes all the work on the merged branch and squashes it into one non-merge commit on top of the branch you’re on. The <code>--no-commit</code> option tells Git not to automatically record a commit. This allows you to introduce all the changes from another branch and then make more changes before recording the new commit.</p>

<p>Теперь вы можете отправить мейнтейнеру сообщение о том, что вы сделали требуемые изменения и они могут быть найдены в вашей ветке <code>featureBv2</code> (смотри Рисунок 5-18).</p>

<p>Now you can send the maintainer a message that you’ve made the requested changes and they can find those changes in your <code>featureBv2</code> branch (see Figure 5-18).</p>

<p><center><img src="/figures/ch5/18333fig0518-tn.png"></center><br/> Рисунок 5-18. История коммитов после работы на featureBv2.</p>

<p>Figure 5-18. Commit history after featureBv2 work.</p>

<h3 id='__'>Большой открытый проект</h3>

<h3 id='public_large_project'>Public Large Project</h3>

<p>Много более крупных проектов уже установили некоторый алгоритм принятия патчей — вам потребуется выяснять точные правила для каждого проекта, так как они будут отличаться. Однако, много крупных открытых проектов принимают патчи через список адресов разработчиков, так что сейчас мы рассмотрим пример такого приема.</p>

<p>Many larger projects have established procedures for accepting patches — you’ll need to check the specific rules for each project, because they will differ. However, many larger public projects accept patches via a developer mailing list, so I’ll go over an example of that now.</p>

<p>Рабочий процесс похож на описанный ранее — вы создаете тематическую ветку для каждой серии патчей, над которой вы работаете. Отличие состоит в процессе внесения этих изменений в проект. Вместо того, чтобы создавать ответвление от проекта (forking) и отправлять наработки в ваш собственный репозиторий (для которого вы имеете право записи), вы генерируете e-mail версию каждой серии коммитов и отправляете ее по списку адресов разработчиков:</p>

<p>The workflow is similar to the previous use case — you create topic branches for each patch series you work on. The difference is how you submit them to the project. Instead of forking the project and pushing to your own writable version, you generate e-mail versions of each commit series and e-mail them to the developer mailing list:</p>

<pre><code>$ git checkout -b topicA
$ (work)
$ git commit
$ (work)
$ git commit</code></pre>

<p>Теперь у вас есть два коммита, которые вы хотите отправить по списку адресов. Вы используете команду <code>git format-patch</code>, чтобы сгенерировать файлы в формате mbox, которые вы можете отправить по почте по списку адресов. Эта команда превращает каждый коммит в электронное сообщение, темой которого является первая строка сообщения коммита, а оставшаяся часть сообщения коммита и патч, который он представляет, являются телом электронного сообщения. Хорошей особенностью является то, что применение патча из сгенерированного командой <code>format-patch</code> электронного сообщения сохраняет всю информацию о коммите. Вы увидите это в следующей части, когда будете применять эти коммиты:</p>

<p>Now you have two commits that you want to send to the mailing list. You use <code>git format-patch</code> to generate the mbox-formatted files that you can e-mail to the list — it turns each commit into an e-mail message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body. The nice thing about this is that applying a patch from an e-mail generated with <code>format-patch</code> preserves all the commit information properly, as you’ll see more of in the next section when you apply these commits:</p>

<pre><code>$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch</code></pre>

<p>Команда <code>format-patch</code> создает файлы с патчами и выводит их названия. Опция <code>-M</code> сообщает Git&#8217;у, что переименования нужно отслеживать. В итоге файлы выглядят так:</p>

<p>The <code>format-patch</code> command prints out the names of the patch files it creates. The <code>-M</code> switch tells Git to look for renames. The files end up looking like this:</p>

<pre><code>$ cat 0001-add-limit-to-log-function.patch 
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = &#39;master&#39;)
-    command(&quot;git log #{treeish}&quot;)
+    command(&quot;git log -n 20 #{treeish}&quot;)
   end

   def ls_tree(treeish = &#39;master&#39;)
-- 
1.6.2.rc1.20.g8c5b.dirty</code></pre>

<p>Вы также можете отредактировать эти файлы патчей, чтобы добавить в электронное сообщение некую информацию, которую вы не хотите показывать в сообщении коммита. Если вы добавляете текст между строкой <code>--</code> и началом патча (строка <code>lib/simplegit.rb</code>), то разработчик сможет ее прочитать, но в применении патча она участвовать не будет.</p>

<p>You can also edit these patch files to add more information for the e-mail list that you don’t want to show up in the commit message. If you add text between the <code>--</code> line and the beginning of the patch (the <code>lib/simplegit.rb</code> line), then developers can read it; but applying the patch excludes it.</p>

<p>Чтобы отправить эти файлы по списку адресов вы можете вставить файл в сообщение в вашем почтовом клиенте или отправить его через программу в командной строке. Вставка текста часто приводит к ошибкам форматирования, особенно в &#8220;умных&#8221; клиентах, которые не защищают символы перевода строки и пробельные символы. К счастью, Git предоставляет инструмент, позволяющий вам передавать через IMAP правильно отформатированные патчи. Для вас, применение этого инструмента может быть легче. Я покажу как отсылать патчи через Gmail, так как именно этот агент я и использую; вы можете прочесть подробные инструкции для большого числа почтовых программ в вышеупомянутом файле <code>Documentation/SubmittingPatches</code>, находящемся в исходном коде Git&#8217;а.</p>

<p>To e-mail this to a mailing list, you can either paste the file into your e-mail program or send it via a command-line program. Pasting the text often causes formatting issues, especially with &#8220;smarter&#8221; clients that don’t preserve newlines and other whitespace appropriately. Luckily, Git provides a tool to help you send properly formatted patches via IMAP, which may be easier for you. I’ll demonstrate how to send a patch via Gmail, which happens to be the e-mail agent I use; you can read detailed instructions for a number of mail programs at the end of the aforementioned <code>Documentation/SubmittingPatches</code> file in the Git source code.</p>

<p>Для начала вам следует внести секцию imap в файл <code>~/.gitconfig</code>. Вы можете добавлять каждое значение отдельно серией команд <code>git config</code>, или же добавить их все сразу вручную; но, в итоге, ваш файл конфигурации должен выглядеть примерно так:</p>

<p>First, you need to set up the imap section in your <code>~/.gitconfig</code> file. You can set each value separately with a series of <code>git config</code> commands, or you can add them manually; but in the end, your config file should look something like this:</p>

<pre><code>[imap]
  folder = &quot;[Gmail]/Drafts&quot;
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = p4ssw0rd
  port = 993
  sslverify = false</code></pre>

<p>Если ваш IMAP сервер не использует SSL, две последние строки могут отсутствовать, а параметр host примет значение <code>imap://</code> вместо <code>imaps://</code>. Когда необходимые параметры внесены в ваш файл конфигурации, вы можете использовать команду <code>git send-email</code> для перемещение серии патчей в папку Drafts на указанном IMAP сервере:</p>

<p>If your IMAP server doesn’t use SSL, the last two lines probably aren’t necessary, and the host value will be <code>imap://</code> instead of <code>imaps://</code>. When that is set up, you can use <code>git send-email</code> to place the patch series in the Drafts folder of the specified IMAP server:</p>

<pre><code>$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith &lt;jessica@example.com&gt;] 
Emails will be sent from: Jessica Smith &lt;jessica@example.com&gt;
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y</code></pre>

<p>Затем Git выдает группу служебных сообщений, выглядящую примерно следующим образом, для каждого патча, который вы отсылаете:</p>

<p>Then, Git spits out a bunch of log information looking something like this for each patch you’re sending:</p>

<pre><code>(mbox) Adding cc: Jessica Smith &lt;jessica@example.com&gt; from 
  \line &#39;From: Jessica Smith &lt;jessica@example.com&gt;&#39;
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith &lt;jessica@example.com&gt;
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: &lt;1243715356-61726-1-git-send-email-jessica@example.com&gt;
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: &lt;y&gt;
References: &lt;y&gt;

Result: OK</code></pre>

<p>Теперь вы должны иметь возможности перейти в вашу папку Drafts, заполнить поле &#8216;To&#8217; в соответствии со списком адресов, по которым вы рассылаете патчи, указать, если нужно, адрес мейнтейнера или ответственного за эту секцию лица в поле &#8216;CC&#8217;, и отправить сообщение.</p>

<p>At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you’re sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.</p>

<h3 id='id224'>Итоги</h3>

<h3 id='summary'>Summary</h3>

<p>В этом разделе был рассмотрен ряд общепринятых рабочих процессов, применяемых в нескольких непохожих друг на друга типах проектов (использующих Git), c которыми вы вероятно столкнетесь. Также здесь были представлены два новых инструмента, призванных помочь вам в организации этих процессов. Далее вы увидите рабочий процесс совсем с другой стороны: управление проектом в Git. Вы научитесь роли благосклонного диктатора или роли менеджера по интеграции.</p>

<p>This section has covered a number of common workflows for dealing with several very different types of Git projects you’re likely to encounter and introduced a couple of new tools to help you manage this process. Next, you’ll see how to work the other side of the coin: maintaining a Git project. You’ll learn how to be a benevolent dictator or integration manager.</p>

<div id='nav'>
<a href='ch5-3.html'>prev</a> | <a href='ch5-5.html'>next</a>
</div>