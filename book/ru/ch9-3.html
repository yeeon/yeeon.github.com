---
layout: translation
title: Pro Git 9.3 Git изнутри Ссылки в Git
---
<h2 id='__git'>Ссылки в Git</h2>

<p>Для просмотра всей истории можно выполнить команду вроде <code>git log 1a410e</code>, но, опять же, требуется помнить, что именно коммит <code>1a410e</code> является последним, чтобы иметь возможность найти все наши объекты. Нам нужен файл-указатель с простым именем, который бы содержал это значение хеша SHA-1, чтобы можно было пользоваться этим файлом вместо хеша.</p>

<p>В Git такие файлы, содержащие SHA-1, называются ссылками (&#8220;refs&#8221;) и располагаются в каталоге <code>.git/refs</code>. В нашем проекте этот каталог пока пуст, но в нём уже существует некоторая структура каталогов:</p>

<pre><code>$ find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
$ find .git/refs -type f
$</code></pre>

<p>Чтобы создать новую ссылку, которая поможет вам вспомнить, какой коммит последний, по сути, необходимо сделать всего лишь следующее:</p>

<pre><code>$ echo &quot;1a410efbd13591db07496601ebc7a059dd55cfe9&quot; &gt; .git/refs/heads/master</code></pre>

<p>Теперь можно использовать только что созданную ссылку из каталога heads вместо хеша в командах Git:</p>

<pre><code>$ git log --pretty=oneline  master
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>

<p>Тем не менее, редактировать данные файлы напрямую не рекомендуется. Git предоставляет безопасную команду <code>update-ref</code> для изменения ссылок:</p>

<pre><code>$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>

<p>Вот что такое по сути ветка в Git — простой указатель или ссылка на последнюю версию в работе. Для создания ветки, соответствующей состоянию второго коммита, можно выполнить следующее:</p>

<pre><code>$ git update-ref refs/heads/test cac0ca</code></pre>

<p>Данная ветка будет содержать только коммиты, предшествующие выбранному:</p>

<pre><code>$ git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>

<p>Теперь наша база данных Git схематично выглядит так, как показано на рисунке 9.4.</p>

<p><center><img src="/figures/ch9/18333fig0904-tn.png"></center><br/> Рисунок 9-4. Объекты в каталоге .git, а также указатели на вершины веток.</p>

<p>Когда выполняется команда <code>git branch (имя ветки)</code>, Git, по сути, выполняет <code>update-ref</code> для добавления хеша последнего коммита текущей ветки под указанным именем в виде новой ссылки.</p>

<h3 id='head'>HEAD</h3>

<p>Вопрос в том, как же Git получает хеш последнего коммита при выполнении <code>git branch (имя ветки)</code>? Ответ содержится в файле HEAD. Данный файл является символической ссылкой на текущую ветку. Символическая ссылка отличается от обычной тем, что она содержит не сам хеш SHA-1, а указатель на другую ссылку. Если вы загляните в этот файл, то увидите что-то такое:</p>

<pre><code>$ cat .git/HEAD 
ref: refs/heads/master</code></pre>

<p>Если выполнить <code>git checkout test</code>, то содержимое файла изменится:</p>

<pre><code>$ cat .git/HEAD 
ref: refs/heads/test</code></pre>

<p>При выполнении <code>git commit</code>, Git создаёт объект-коммит, указывая его родителем тот объект, SHA-1 которого содержится в файле, на который ссылается HEAD.</p>

<p>Данный файл, конечно, можно редактировать вручную, но безопаснее использовать команду <code>symbolic-ref</code>. Получить значение HEAD данной командой можно так:</p>

<pre><code>$ git symbolic-ref HEAD
refs/heads/master</code></pre>

<p>Изменить значение HEAD можно так:</p>

<pre><code>$ git symbolic-ref HEAD refs/heads/test
$ cat .git/HEAD 
ref: refs/heads/test</code></pre>

<p>Символическую ссылку на файл вне refs поставить нельзя:</p>

<pre><code>$ git symbolic-ref HEAD test
fatal: Refusing to point HEAD outside of refs/</code></pre>

<h3 id='id237'>Метки</h3>

<p>Мы рассмотрели три основных типа объектов в Git, но есть и четвёртый. Объект-метка очень похож на объект-коммит: он содержит имя поставившего метку, дату, сообщение и указатель. Разница же в том, что метка указывает на коммит, а не на дерево. Она похожа на ветку, которая никогда не перемещается — она всегда указывает на один и тот же коммит, она просто даёт ему понятное имя.</p>

<p>Как было сказано в главе 2, метки бывают двух типов: аннотированные и легковесные. Легковесную метку можно сделать следующей командой:</p>

<pre><code>$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</code></pre>

<p>Вот и всё! Легковесная метка — это ветка, которая никогда не перемещается. Аннотированная метка имеет более сложную структуру. При создании аннотированной метки, Git создаёт специальный объект, на который будет указывать ссылка, а не просто указатель на коммит. Мы можем увидеть это создав аннотированную метку (<code>-a</code> задаёт аннотированные метки):</p>

<pre><code>$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m &#39;test tag&#39;</code></pre>

<p>Вот значение SHA-1 созданного объекта:</p>

<pre><code>$ cat .git/refs/tags/v1.1 
9585191f37f7b0fb9444f35a9bf50de191beadc2</code></pre>

<p>Теперь выполним <code>cat-file</code> для этого хеша:</p>

<pre><code>$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700

test tag</code></pre>

<p>Заметьте, в поле object записан SHA-1 коммита, для которого мы делали метку. Также стоит отметить, что это поле не обязательно указывает на коммит, но на любой объект в Git. Например, в исходный код Git мейнтейнер добавил свой публичный GPG-ключ в качестве блоба и поставил для него метку. Увидеть этот ключ можно, выполнив команду</p>

<pre><code>$ git cat-file blob junio-gpg-pub</code></pre>

<p>в репозитории с исходным кодом Git. В репозитории ядра Linux также есть метка, указывающая не на коммит — первая метка указывает на дерево первичного импорта.</p>

<h3 id='___'>Ссылки на удалённые ветки</h3>

<p>Третий тип ссылок, который мы рассмотрим — ссылка на удалённую ветку. Если вы добавили удалённый репозиторий и отправили (push) на него изменения, Git сохранит последнее отправленное значение SHA-1 в каталоге <code>refs/remotes</code> для всех отправленных веток. Например, можно добавить удалённый репозиторий <code>origin</code> и отправить туда ветку <code>master</code>:</p>

<pre><code>$ git remote add origin git@github.com:schacon/simplegit-progit.git
$ git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
   a11bef0..ca82a6d  master -&gt; master</code></pre>

<p>Позже, вы сможете посмотреть где находилась ветка <code>master</code> с сервера <code>origin</code> во время последнего соединения с сервером заглянув в файл <code>refs/remotes/origin/master</code>:</p>

<pre><code>$ cat .git/refs/remotes/origin/master 
ca82a6dff817ec66f44342007202690a93763949</code></pre>

<p>Ссылки на удалённые ветки отличаются от обычных веток (ссылки в <code>refs/heads</code>) тем, что на них нельзя переключиться с помощью <code>git checkout</code>. Git работает с ними как с закладками, указывающими на последнее состояние соответствующих веток на ваших серверах.</p>

<div id='nav'>
<a href='ch9-2.html'>prev</a> | <a href='ch9-4.html'>next</a>
</div>