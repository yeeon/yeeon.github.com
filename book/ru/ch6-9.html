---
layout: translation
title: Pro Git 6.9 Инструменты Git Submodules
---
<h2 id='submodules'>Submodules</h2>

<p>Часто бывает так, что во время работы над одним проектом, вам необходимо использовать другой изнутри первого. Возможно, это библиотека сторонних разработчиков или разрабатываемая вами обособленно и используемая в нескольких родительских проектах. Обычной задачей появляющейся в этих сценариях является то, что вы желаете иметь возможность рассматривать эти два проекта как независимые, тем не менее, по-прежнему имея возможность использовать один проект внутри другого.</p>

<p>It often happens that while working on one project, you need to use another project from within it. Perhaps it’s a library that a third party developed or that you’re developing separately and using in multiple parent projects. A common issue arises in these scenarios: you want to be able to treat the two projects as separate yet still be able to use one from within the other.</p>

<p>Вот пример. Предположим, вы разрабатываете вебсайт и создаете ленты (каналы) Atom. И вместо того, чтобы писать собственный Atom-генерирующий код, вы решили использовать библиотеку. Вы вероятно должны либо подключить код разделяемой библиотеки, такой как устанавливаемый модуль CPAN или пакет RubyGem, либо скопировать исходный код в дерево собственного проекта. Проблема подключения библиотеки в том, что в общем случае сложно настраивать библиотеку, и, зачастую, более сложно ее распространять. Ведь вы вынуждены удостоверится в том, что эта библиотека доступна каждому клиенту. Проблема с включением кода в ваш собственный проект в том, что любые изменения, произведенные вами, сложно слить, когда становятся доступными дальнейшие изменения основного проекта.</p>

<p>Here’s an example. Suppose you’re developing a web site and creating Atom feeds. Instead of writing your own Atom-generating code, you decide to use a library. You’re likely to have to either include this code from a shared library like a CPAN install or Ruby gem, or copy the source code into your own project tree. The issue with including the library is that it’s difficult to customize the library in any way and often more difficult to deploy it, because you need to make sure every client has that library available. The issue with vendoring the code into your own project is that any custom changes you make are difficult to merge when upstream changes become available.</p>

<p>Git решает эту задачу используя подмодули (submodules). Подмодули позволяют вам держать репозиторий Git как подкаталог другого репозитория Git. Это дает возможность клонировать другой репозиторий в ваш проект и держать ваши коммиты отдельно.</p>

<p>Git addresses this issue using submodules. Submodules allow you to keep a Git repository as a subdirectory of another Git repository. This lets you clone another repository into your project and keep your commits separate.</p>

<h3 id='__'>Начало использования подмодулей</h3>

<h3 id='starting_with_submodules'>Starting with Submodules</h3>

<p>Предположим, вы хотите добавить библиотеку Rack (интерфейс шлюза веб-сервера Ruby) в ваш проект, возможно внося ваши собственные изменения в него, но продолжая сливать их с изменениями основного проекта. Первое что вам требуется сделать, это клонировать внешний репозиторий в ваш подкаталог. Вы добавляете внешние проекты как подмодули командой <code>git submodule add</code>:</p>

<p>Suppose you want to add the Rack library (a Ruby web server gateway interface) to your project, possibly maintain your own changes to it, but continue to merge in upstream changes. The first thing you should do is clone the external repository into your subdirectory. You add external projects as submodules with the <code>git submodule add</code> command:</p>

<pre><code>$ git submodule add git://github.com/chneukirchen/rack.git rack
Initialized empty Git repository in /opt/subtest/rack/.git/
remote: Counting objects: 3181, done.
remote: Compressing objects: 100% (1534/1534), done.
remote: Total 3181 (delta 1951), reused 2623 (delta 1603)
Receiving objects: 100% (3181/3181), 675.42 KiB | 422 KiB/s, done.
Resolving deltas: 100% (1951/1951), done.</code></pre>

<p>Теперь у вас есть проект Rack в подкаталоге названом <code>rack</code> внутри вашего проекта. Вы можете перейти в этот репозиторий, внести изменения, добавить ваш собственный доступный для записи внешний репозиторий для отправки ваших изменений в него, извлекать и сливать из исходного репозитория, и многое другое. Если вы выполните <code>git status</code> сразу после добавления подмодуля, то увидите две вещи:</p>

<p>Now you have the Rack project under a subdirectory named rack within your project. You can go into that subdirectory, make changes, add your own writable remote repository to push your changes into, fetch and merge from the original repository, and more. If you run git status right after you add the submodule, you see two things:</p>

<pre><code>$ git status
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#      new file:   .gitmodules
#      new file:   rack
#</code></pre>

<p>Вначале вы заметите файл <code>.gitmodules</code>. Это - конфигурационный файл, который содержит соответствие между адресом (URL) проекта и локальным подкаталогом в который вы его получили:</p>

<p>First you notice the <code>.gitmodules</code> file. This is a configuration file that stores the mapping between the project’s URL and the local subdirectory you’ve pulled it into:</p>

<pre><code>$ cat .gitmodules 
[submodule &quot;rack&quot;]
      path = rack
      url = git://github.com/chneukirchen/rack.git</code></pre>

<p>Если у вас несколько подмодулей, то в этом файле будет несколько записей. Важно обратить внимание на то, что этот файл версионирован вместе с другими вашими файлами, так же как и ваш файл <code>.gitignore</code>. Он отправляется и получается вместе с остальным вашим проектом. Так другие люди, которые клонируют этот проект, узнают где взять проект подмодуля.</p>

<p>If you have multiple submodules, you’ll have multiple entries in this file. It’s important to note that this file is version-controlled with your other files, like your <code>.gitignore</code> file. It’s pushed and pulled with the rest of your project. This is how other people who clone this project know where to get the submodule projects from.</p>

<p>В следующем листинге вывода <code>git status</code> присутствует элемент <code>rack</code>. Если вы запустите <code>git diff</code> для него, то увидите что-то интересное:</p>

<p>The other listing in the <code>git status</code> output is the rack entry. If you run <code>git diff</code> on that, you see something interesting:</p>

<pre><code>$ git diff --cached rack
diff --git a/rack b/rack
new file mode 160000
index 0000000..08d709f
--- /dev/null
+++ b/rack
@@ -0,0 +1 @@
+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433</code></pre>

<p>Хотя <code>rack</code> является подкаталогом в вашем рабочем каталоге, Git видит ее как подмодуль и не отслеживает его содержимое когда вы не в нем. Вместо этого, Git записывает его как одиночный специфический коммит этого репозитория. Когда вы делаете изменения и фиксацию (создаете коммит - прим. переводчика) в этом подкаталоге, основной проект отмечает что HEAD в подмодуле был изменен, и регистрирует только SHA-1 хеш коммита над которым вы в данный момент завершили работу в подмодуле. Таким образом, когда другие клонируют этот проект, они могут воссоздать окружение точно.</p>

<p>Although <code>rack</code> is a subdirectory in your working directory, Git sees it as a submodule and doesn’t track its contents when you’re not in that directory. Instead, Git records it as a particular commit from that repository. When you make changes and commit in that subdirectory, the superproject notices that the HEAD there has changed and records the exact commit you’re currently working off of; that way, when others clone this project, they can re-create the environment exactly.</p>

<p>Это важная особенность подмодулей – вы запоминаете их как определенный коммит (состояние) в котором они находятся. Вы не можете записать подмодуль как <code>master</code> или какую-либо другую символическую ссылку.</p>

<p>This is an important point with submodules: you record them as the exact commit they’re at. You can’t record a submodule at <code>master</code> or some other symbolic reference.</p>

<p>Когда вы фиксируете изменения (создаете коммит), то увидите что-то вроде этого:</p>

<p>When you commit, you see something like this:</p>

<pre><code>$ git commit -m &#39;first commit with submodule rack&#39;
[master 0550271] first commit with submodule rack
 2 files changed, 4 insertions(+), 0 deletions(-)
 create mode 100644 .gitmodules
 create mode 160000 rack</code></pre>

<p>Обратите внимание на режим 160000 для элемента rack. Это специальный режим в Git который, по существу, означает, что коммит сохраняется как запись о каталоге, а не подкаталоге или файле.</p>

<p>Notice the 160000 mode for the rack entry. That is a special mode in Git that basically means you’re recording a commit as a directory entry rather than a subdirectory or a file.</p>

<p>Вы можете расценивать каталог <code>rack</code> как отдельный проект и обновлять ваш основной проект время от времени с указателем на самый последний коммит в данном подпроекте. Все команды Git работают независимо в двух каталогах.</p>

<p>You can treat the <code>rack</code> directory as a separate project and then update your superproject from time to time with a pointer to the latest commit in that subproject. All the Git commands work independently in the two directories:</p>

<pre><code>$ git log -1
commit 0550271328a0038865aad6331e620cd7238601bb
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Apr 9 09:03:56 2009 -0700

    first commit with submodule rack
$ cd rack/
$ git log -1
commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433
Author: Christian Neukirchen &lt;chneukirchen@gmail.com&gt;
Date:   Wed Mar 25 14:49:04 2009 +0100

    Document version change</code></pre>

<h3 id='___'>Клонирование проекта с подмодулями</h3>

<h3 id='cloning_a_project_with_submodules'>Cloning a Project with Submodules</h3>

<p>Клонируем проект содержащий подмодуль. Когда вы получаете такой проект, то получаете каталоги содержащие подмодули, но, все же, не получаете ни одного файла из подмодулей.</p>

<p>Here you’ll clone a project with a submodule in it. When you receive such a project, you get the directories that contain submodules, but none of the files yet:</p>

<pre><code>$ git clone git://github.com/schacon/myproject.git
Initialized empty Git repository in /opt/myproject/.git/
remote: Counting objects: 6, done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 6 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (6/6), done.
$ cd myproject
$ ls -l
total 8
-rw-r--r--  1 schacon  admin   3 Apr  9 09:11 README
drwxr-xr-x  2 schacon  admin  68 Apr  9 09:11 rack
$ ls rack/
$</code></pre>

<p>Каталог <code>rack</code> присутствует, но он пустой. Необходимо выполнить две команды: <code>git submodule init</code> для инициализации вашего локального файла конфигурации, и <code>git submodule update</code> для получения всех данных их этого проекта (подмодуля) и перехода к соответствующему коммиту, указанному в вашем основном проекте.</p>

<p>The <code>rack</code> directory is there, but empty. You must run two commands: <code>git submodule init</code> to initialize your local configuration file, and <code>git submodule update</code> to fetch all the data from that project and check out the appropriate commit listed in your superproject:</p>

<pre><code>$ git submodule init
Submodule &#39;rack&#39; (git://github.com/chneukirchen/rack.git) registered for path &#39;rack&#39;
$ git submodule update
Initialized empty Git repository in /opt/myproject/rack/.git/
remote: Counting objects: 3181, done.
remote: Compressing objects: 100% (1534/1534), done.
remote: Total 3181 (delta 1951), reused 2623 (delta 1603)
Receiving objects: 100% (3181/3181), 675.42 KiB | 173 KiB/s, done.
Resolving deltas: 100% (1951/1951), done.
Submodule path &#39;rack&#39;: checked out &#39;08d709f78b8c5b0fbeb7821e37fa53e69afcf433&#39;</code></pre>

<p>Теперь ваш подкаталог <code>rack</code> точно в том состоянии, в котором он был ранее, когда вы его фиксировали. Если другой разработчик сделает изменения в коде rack и зафиксирует их, а вы затяните ссылку на них и сольете, то получите нечто немного странное:</p>

<p>Now your <code>rack</code> subdirectory is at the exact state it was in when you committed earlier. If another developer makes changes to the rack code and commits, and you pull that reference down and merge it in, you get something a bit odd:</p>

<pre><code>$ git merge origin/master
Updating 0550271..85a3eee
Fast forward
 rack |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)
[master*]$ git status
# On branch master
# Changed but not updated:
#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#      modified:   rack
#</code></pre>

<p>По существу, вы слили то, изменения в указателе на ваш подмодуль, но это не обновило код в каталоге подмодуля, так что он выглядит так, как будто вы имеете грязное состояние в вашем рабочем каталоге:</p>

<p>You merged in what is basically a change to the pointer for your submodule; but it doesn’t update the code in the submodule directory, so it looks like you have a dirty state in your working directory:</p>

<pre><code>$ git diff
diff --git a/rack b/rack
index 6c5e70b..08d709f 160000
--- a/rack
+++ b/rack
@@ -1 +1 @@
-Subproject commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433</code></pre>

<p>Это так потому, что ваш указатель для подмодуля не соответствует тому, что фактически находится в каталоге подмодуля. (Причина в том, что указатель на подмодуль не является каталогом. - прим. переводчика) Для исправления этого, вы должны выполнить <code>git submodule update</code> заново:</p>

<p>This is the case because the pointer you have for the submodule isn’t what is actually in the submodule directory. To fix this, you must run <code>git submodule update</code> again:</p>

<pre><code>$ git submodule update
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 1), reused 2 (delta 0)
Unpacking objects: 100% (3/3), done.
From git@github.com:schacon/rack
   08d709f..6c5e70b  master     -&gt; origin/master
Submodule path &#39;rack&#39;: checked out &#39;6c5e70b984a60b3cecd395edd5b48a7575bf58e0&#39;</code></pre>

<p>Вы должны делать это каждый раз, когда вы получаете изменения подмодуля в главный проект. Это странно, но работает.</p>

<p>You have to do this every time you pull down a submodule change in the main project. It’s strange, but it works.</p>

<p>Распространенная проблема возникает когда разработчик делает изменения в подмодуле (имеется в виду его локальная копия - прим. переводчика), но не отправляет их на общественный сервер. Затем он фиксирует указатель на это непубличное состояние и отправляет его в основной проект. Когда другие разработчики пытаются выполнить <code>git submodule update</code>, система работы с подмодулями не может найти указанный коммит потому. что он существует только в системе первого разработчика. Если это случается, вы увидите ошибку вроде этой:</p>

<p>One common problem happens when a developer makes a change locally in a submodule but doesn’t push it to a public server. Then, they commit a pointer to that non-public state and push up the superproject. When other developers try to run <code>git submodule update</code>, the submodule system can’t find the commit that is referenced, because it exists only on the first developer’s system. If that happens, you see an error like this:</p>

<pre><code>$ git submodule update
fatal: reference isn’t a tree: 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Unable to checkout &#39;6c5e70b984a60b3cecd395edd5ba7575bf58e0&#39; in submodule path &#39;rack&#39;</code></pre>

<p>Вы вынуждены посмотреть кто последним менял подмодуль:</p>

<p>You have to see who last changed the submodule:</p>

<pre><code>$ git log -1 rack
commit 85a3eee996800fcfa91e2119372dd4172bf76678
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Apr 9 09:19:14 2009 -0700

    added a submodule reference I will never make public. hahahahaha!</code></pre>

<p>Затем вы отправляете этому человеку имейл со своими возмущениями.</p>

<p>Then, you e-mail that guy and yell at him.</p>

<h3 id='id200'>Суперпроекты</h3>

<h3 id='superprojects'>Superprojects</h3>

<p>Иногда, разработчики хотят получить комбинацию подкаталогов крупного проекта, в зависимости от того, в какой они команде. Это привычно если вы пришли из CVS или Subversion, где вы определили модуль или набор подкаталогов, и вы хотите сохранить данный тип рабочего процесса.</p>

<p>Sometimes, developers want to get a combination of a large project’s subdirectories, depending on what team they’re on. This is common if you’re coming from CVS or Subversion, where you’ve defined a module or collection of subdirectories, and you want to keep this type of workflow.</p>

<p>Хорошим способом выполнить это в Git является сделать каждый из подкаталогов отдельным Git репозиторием, и создать репозиторий Git для суперпроекта который содержал бы несколько подмодулей. Преимущество такого подхода в том, что вы можете более гибко определять отношения между проектами при помощи тегов (ярлыков) и ветвей в суперпроектах.</p>

<p>A good way to do this in Git is to make each of the subfolders a separate Git repository and then create superproject Git repositories that contain multiple submodules. A benefit of this approach is that you can more specifically define the relationships between the projects with tags and branches in the superprojects.</p>

<h3 id='__'>Проблемы с подмодулями</h3>

<h3 id='issues_with_submodules'>Issues with Submodules</h3>

<p>Однако, использование подмодулей не обходится без загвоздок. Во-первых, вы должны быть относительно осторожны работая в каталоге подмодуля. Когда вы выполняете команду <code>git submodule update</code> она возвращает определенную версию проекта, но не внутри ветви. Это называется получением изолированной головы - это означает, что файл HEAD указывает на конкретный коммит, а не на символическую ссылку. Проблема в том, что вы, как правило, не хотите работать в окружении с &#8220;изолированной головой&#8221;, потому что так легко потерять изменения. Если вы сделаете первоначальный <code>submodule update</code>, произведете фиксацию в каталоге этого подмодуля без создания ветви для работы в ней, и затем, вновь выполните <code>git submodule update</code> из основного проекта, без создания коммита в суперпроекте, Git перетрет ваши изменения без предупреждения. Технически вы не потеряете проделанную работу, но у вас не будет ветки указывающей на нее, так что будет несколько сложно ее восстановить.</p>

<p>Using submodules isn’t without hiccups, however. First, you must be relatively careful when working in the submodule directory. When you run <code>git submodule update</code>, it checks out the specific version of the project, but not within a branch. This is called having a detached head — it means the HEAD file points directly to a commit, not to a symbolic reference. The issue is that you generally don’t want to work in a detached head environment, because it’s easy to lose changes. If you do an initial <code>submodule update</code>, commit in that submodule directory without creating a branch to work in, and then run <code>git submodule update</code> again from the superproject without committing in the meantime, Git will overwrite your changes without telling you. Technically you won’t lose the work, but you won’t have a branch pointing to it, so it will be somewhat difficult to retrieive.</p>

<p>Для предотвращения этой проблемы, создавайте ветвь, когда работаете в каталоге подмодуля с использованием команды <code>git checkout -b</code> или какой-нибудь аналогичной. Когда вы сделаете обновление подмодуля командой <code>submodule update</code> в следующий раз, она все же откатит вашу работу, но, по крайней мере, у вас будет указатель для возврата назад.</p>

<p>To avoid this issue, create a branch when you work in a submodule directory with <code>git checkout -b</code> work or something equivalent. When you do the submodule update a second time, it will still revert your work, but at least you have a pointer to get back to.</p>

<p>Переключение ветвей с подмодулями в них так же может быть мудреным. Если вы создадите новую ветвь, добавите туда подмодуль и, затем, переключитесь обратно, туда где не было этого подмодуля, вы все еще будите иметь каталог подмодуля в виде неверсионированного каталога:</p>

<p>Switching branches with submodules in them can also be tricky. If you create a new branch, add a submodule there, and then switch back to a branch without that submodule, you still have the submodule directory as an untracked directory:</p>

<pre><code>$ git checkout -b rack
Switched to a new branch &quot;rack&quot;
$ git submodule add git@github.com:schacon/rack.git rack
Initialized empty Git repository in /opt/myproj/rack/.git/
...
Receiving objects: 100% (3184/3184), 677.42 KiB | 34 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
$ git commit -am &#39;added rack submodule&#39;
[rack cc49a69] added rack submodule
 2 files changed, 4 insertions(+), 0 deletions(-)
 create mode 100644 .gitmodules
 create mode 160000 rack
$ git checkout master
Switched to branch &quot;master&quot;
$ git status
# On branch master
# Untracked files:
#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
#
#      rack/</code></pre>

<p>Вы будете вынуждены либо переместить каталог подмодуля в другое место, либо удалить его. В этом случае вам потребуется клонировать его опять когда переключитесь обратно, и вы можете потерять локальные изменения или ветви, которые вы не отправили в оригинальное хранилище.</p>

<p>You have to either move it out of the way or remove it, in which case you have to clone it again when you switch back—and you may lose local changes or branches that you didn’t push up.</p>

<p>Последним главным предостережением является то, что многие люди запутываются с переключениями из подкаталогов к подмодулям. Если вы отслеживали файлы в подкаталоге вашего проекта, и хотите перенести их в подмодуль, вы должны быть осторожны или Git разозлится на вас. Допустим, что вы держите rack файлы в подкаталоге вашего проекта, и вы хотите переключить его на подмодуль. Если вы удалите подкаталог и затем выполните <code>submodule add</code>, Git наорет на вас:</p>

<p>The last main caveat that many people run into involves switching from subdirectories to submodules. If you’ve been tracking files in your project and you want to move them out into a submodule, you must be careful or Git will get angry at you. Assume that you have the rack files in a subdirectory of your project, and you want to switch it to a submodule. If you delete the subdirectory and then run <code>submodule add</code>, Git yells at you:</p>

<pre><code>$ rm -Rf rack/
$ git submodule add git@github.com:schacon/rack.git rack
&#39;rack&#39; already exists in the index</code></pre>

<p>Вначале вам следует убрать каталог <code>rack</code> из индекса (деверсионировать). Затем вы сможете добавить подмодуль.</p>

<p>You have to unstage the <code>rack</code> directory first. Then you can add the submodule:</p>

<pre><code>$ git rm -r rack
$ git submodule add git@github.com:schacon/rack.git rack
Initialized empty Git repository in /opt/testsub/rack/.git/
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 88 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.</code></pre>

<p>Теперь, предположим, вы сделали это в ветви. Если вы попытаетесь переключиться обратно в ветвь, где эти файлы все еще в актуальном дереве, а не в подмодуле – вы получите такую ошибку:</p>

<p>Now suppose you did that in a branch. If you try to switch back to a branch where those files are still in the actual tree rather than a submodule — you get this error:</p>

<pre><code>$ git checkout master
error: Untracked working tree file &#39;rack/AUTHORS&#39; would be overwritten by merge.</code></pre>

<p>Вам следует переместить каталог подмодуля <code>rack</code>, перед тем, как вы сможете переключиться на ветвь, которая не содержит его.</p>

<p>You have to move the <code>rack</code> submodule directory out of the way before you can switch to a branch that doesn’t have it:</p>

<pre><code>$ mv rack /tmp/
$ git checkout master
Switched to branch &quot;master&quot;
$ ls
README	rack</code></pre>

<p>Затем, когда вы переключитесь обратно, вы получите пустой каталог <code>rack</code>. Вы сможете либо выполнить <code>git submodule update</code> для повторного клонирования, или вернуть содержимое вашего каталога <code>/tmp/rack</code> обратно в пустой каталог.</p>

<p>Then, when you switch back, you get an empty <code>rack</code> directory. You can either run <code>git submodule update</code> to reclone, or you can move your <code>/tmp/rack</code> directory back into the empty directory.</p>

<div id='nav'>
<a href='ch6-8.html'>prev</a> | <a href='ch6-10.html'>next</a>
</div>