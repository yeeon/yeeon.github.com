---
layout: translation
title: Pro Git 4.1 Ветвление в Git Что такое ветка?
---
<h2 id='__'>Что такое ветка?</h2>

<p>Чтобы на самом деле разобраться в том, как Git работает с ветками, мы должны сделать шаг назад и рассмотреть, как Git хранит свои данные. Как вы, наверное, помните из главы 1, Git хранит данные не как последовательность изменений или дельт, а как последовательность снимков состояния (snapshot).</p>

<p>Когда вы создаёте коммит в Git&#8217;е, Git записывает в базу объект-коммит, который содержит указатель на снимок состояния, записанный ранее в индекс, метаданные автора и комментария и ноль и более указателей на коммиты, являющиеся прямыми предками этого коммита: ноль предков для первого коммита, один — для обычного коммита и несколько — для коммита, полученного в результате слияния двух или более веток.</p>

<p>Для наглядности давайте предположим, что у вас есть каталог, содержащий три файла, и вы хотите добавить их все в индекс и сделать коммит. При добавлении файлов в индекс для каждого из них вычислится контрольная сумма (SHA-1 хеш, о котором мы упоминали в главе 1), затем эти версии файлов будут сохранены в Git-репозиторий (Git обращается к ним как к двоичным данным), а их контрольные суммы добавятся в индекс:</p>

<pre><code>$ git add README test.rb LICENSE
$ git commit -m &#39;initial commit of my project&#39;</code></pre>

<p>Когда вы создаёте коммит, выполняя <code>git commit</code>, Git вычисляет контрольную сумму каждого подкаталога (в нашем случае только корневого каталога) и сохраняет эти объекты-деревья в Git-репозиторий. Затем Git создаёт объект для коммита, в котором есть метаданные и указатель на объект-дерево для корня проекта. Таким образом, Git сможет воссоздать текущее состояние, когда будет нужно.</p>

<p>Ваш Git-репозиторий теперь содержит пять объектов: по одному блобу для содержимого каждого из трёх файлов, одно дерево, в котором перечислено содержимое каталога и определено соответствие имён файлов и блобов, и один коммит с указателем на тот самый объект-дерево для корня и со всеми метаданными коммита. Схематично данные в этом Git-репозитории выглядят так, как показано на рисунке 3-1.</p>

<p><center><img src="/figures/ch4/18333fig0301-tn.png"></center><br/> Рисунок 3-1. Данные репозитория с единственным коммитом.</p>

<p>Если вы сделаете некоторые изменения и создадите новый коммит, то следующий коммит сохранит указатель на коммит, который шёл непосредственно перед ним. После следующих двух коммитов история может выглядеть, как на рисунке 3-2.</p>

<p><center><img src="/figures/ch4/18333fig0302-tn.png"></center><br/> Рисунок 3-2. Данные объектов Git&#8217;а для нескольких коммитов.</p>

<p>Ветка в Git&#8217;е — это просто легковесный подвижный указатель на один из этих коммитов. Ветка по умолчанию в Git&#8217;е называется <code>master</code>. Когда вы создаёте коммиты на начальном этапе, вам дана ветка <code>master</code>, указывающая на последний сделанный коммит. При каждом новом коммите она сдвигается вперёд автоматически.</p>

<p><center><img src="/figures/ch4/18333fig0303-tn.png"></center><br/> Рисунок 3-3. Ветка указывает на историю коммитов.</p>

<p>Что произойдёт, если вы создадите новую ветку? Итак, этим вы создадите новый указатель, который можно будет перемещать. Скажем, создадим новую ветку под названием <code>testing</code>. Это делается командой <code>git branch</code>:</p>

<pre><code>$ git branch testing</code></pre>

<p>Эта команда создаст новый указатель на тот самый коммит, на котором вы сейчас находитесь (см. рис. 3-4).</p>

<p><center><img src="/figures/ch4/18333fig0304-tn.png"></center><br/> Рисунок 3-4. Несколько веток, указывающих на историю коммитов.</p>

<p>Откуда Git узнает, на какой ветке вы находитесь в данный момент? Он хранит специальный указатель, который называется HEAD (верхушка). Учтите, что это сильно отличается от концепции HEAD в других СКВ, таких как Subversion или CVS, к которым вы, возможно, привыкли. В Git&#8217;е это указатель на локальную ветку, на которой вы находитесь. В данный момент вы всё ещё на ветке <code>master</code>. Команда <code>git branch</code> только создала новую ветку, она не переключила вас на неё (см. рис. 3-5).</p>

<p><center><img src="/figures/ch4/18333fig0305-tn.png"></center><br/> Рисунок 3-5. Файл HEAD указывает на текущую ветку.</p>

<p>Чтобы перейти на существующую ветку, вам надо выполнить команду <code>git checkout</code>. Давайте перейдём на новую ветку <code>testing</code>:</p>

<pre><code>$ git checkout testing</code></pre>

<p>Это действие передвинет HEAD так, чтобы тот указывал на ветку <code>testing</code> (см. рис. 3-6).</p>

<p><center><img src="/figures/ch4/18333fig0306-tn.png"></center><br/> Рисунок 3-6. HEAD указывает на другую ветку после переключения веток.</p>

<p>В чём же важность этого? Давайте сделаем ещё один коммит:</p>

<pre><code>$ vim test.rb
$ git commit -a -m &#39;made a change&#39;</code></pre>

<p>На рисунке 3-7 показан результат.</p>

<p><center><img src="/figures/ch4/18333fig0307-tn.png"></center><br/> Рисунок 3-7. Ветка, на которую указывает HEAD, движется вперёд с каждым коммитом.</p>

<p>Это интересно, потому что теперь ваша ветка <code>testing</code> передвинулась вперёд, но ветка <code>master</code> всё ещё указывает на коммит, на котором вы были, когда выполняли <code>git checkout</code>, чтобы переключить ветки. Давайте перейдём обратно на ветку <code>master</code>:</p>

<pre><code>$ git checkout master</code></pre>

<p>На рисунке 3-8 можно увидеть результат.</p>

<p><center><img src="/figures/ch4/18333fig0308-tn.png"></center><br/> Рисунок 3-8. HEAD перемещается на другую ветку при checkout&#8217;е.</p>

<p>Эта команда выполнила два действия. Она передвинула указатель HEAD назад на ветку <code>master</code> и вернула файлы в вашем рабочем каталоге назад, в соответствие со снимком состояния, на который указывает <code>master</code>. Это также означает, что изменения, которые вы делаете, начиная с этого момента, будут ответвляться от старой версии проекта. Это, по сути, откатывает изменения, которые вы временно делали на ветке <code>testing</code>, так что дальше вы можете двигаться в другом направлении.</p>

<p>Давайте снова внесём немного изменений и сделаем коммит:</p>

<pre><code>$ vim test.rb
$ git commit -a -m &#39;made other changes&#39;</code></pre>

<p>Теперь история вашего проекта разветвилась (см. рис. 3-9). Вы создали новую ветку, перешли на неё, поработали на ней немного, переключились обратно на основную ветку и выполнили другую работу. Оба эти изменения изолированы в отдельных ветках: вы можете переключаться туда и обратно между ветками и слить их, когда будете готовы. И всё это было сделано простыми командами <code>branch</code> и <code>checkout</code>.</p>

<p><center><img src="/figures/ch4/18333fig0309-tn.png"></center><br/> Рисунок 3-9. История с разошедшимися ветками.</p>

<p>Из-за того, что ветка в Git&#8217;е на самом деле является простым файлом, который содержит 40 символов контрольной суммы SHA-1 коммита, на который он указывает, создание и удаление веток практически беззатратно. Создание новой ветки настолько же быстрое и простое, как запись 41 байта в файл (40 символов + символ новой строки).</p>

<p>Это разительно отличается от того, как в большинстве СКВ делается ветвление. Там это приводит к копированию всех файлов проекта в другой каталог. Это может занять несколько секунд или даже минут, в зависимости от размера проекта, тогда как в Git&#8217;е это всегда происходит моментально. Также благодаря тому, что мы запоминаем предков для каждого коммита, поиск нужной базовой версии для слияния уже автоматически выполнен за нас, и в общем случае слияние делается легко. Эти особенности помогают поощрять разработчиков к частому созданию и использованию веток.</p>

<p>Давайте поймём, почему и вам стоит так делать.</p>

<div id='nav'>
<a href='ch4-0.html'>prev</a> | <a href='ch4-2.html'>next</a>
</div>