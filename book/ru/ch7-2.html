---
layout: translation
title: Pro Git 7.2 Настройка Git Git-атрибуты
---
<h2 id='git'>Git-атрибуты</h2>

<p>Некоторые настройки могут быть заданы для отдельных путей, и тогда Git будет применять их только для некоторых подкаталогов или набора файлов. Такие настройки, специфичные по отношению к путям, называются атрибутами и задаются либо в файле <code>.gitattributes</code> в одном из каталогов проекта (обычно в корне), либо в файле <code>.git/info/attributes</code>, если вы не хотите, чтобы файл с атрибутами попал в коммит вместе с остальными файлами проекта.</p>

<p>Использование атрибутов позволяет, например, задать разные стратегии слияния для отдельных файлов или каталогов проекта, или объяснить Git&#8217;у, как сравнивать нетекстовые файлы, или сделать так, чтобы Git пропускал данные через фильтр перед тем, как выгрузить или записать данные в репозиторий. В этом разделе мы рассмотрим некоторые из доступных в Git&#8217;е атрибутов и рассмотрим несколько практических примеров их использования.</p>

<h3 id='_'>Бинарные файлы</h3>

<p>Есть один клёвый трюк, для которого можно использовать атрибуты — можно указать Git&#8217;у, какие файлы являются бинарными (в случае если по-другому определить это не получается), и дать ему специальные инструкции о том, как с этими файлами работать. Например, некоторые текстовые файлы могут быть машинными — генерируемыми программой — для них нет смысла вычислять дельты, в то время как для некоторых бинарных файлов получение дельт может быть полезным. Дальше мы увидим, как сказать Git&#8217;у, какие файлы какие.</p>

<h4 id='__'>Определение бинарных файлов</h4>

<p>Некоторые файлы выглядят как текстовые, но по существу должны рассматриваться как бинарные данные. Например, проекты Xcode на Mac&#8217;ах содержат файл, оканчивающийся на <code>.pbxproj</code>, который, по сути, является набором JSON-данных (текстовый формат данных для javascript), записываемым IDE, в котором сохраняются ваши настройки сборки и прочее. Хоть технически это и текстовый файл, потому что содержит только ASCII-символы, но нет смысла рассматривать его как таковой, потому что на самом деле это легковесная база данных — вы не сможете слить её содержимое, если два человека внесут в неё изменение, получение дельт тоже, как правило, ничем вам не поможет. Этот файл предназначается для обработки программой. По сути, лучше рассматривать этот файл как бинарный.</p>

<p>Чтобы заставить Git обращаться со всеми <code>pbxproj</code>-файлами как с бинарными, добавьте следующую строку в файл <code>.gitattributes</code>:</p>

<pre><code>*.pbxproj -crlf -diff</code></pre>

<p>Теперь Git не будет пытаться конвертировать CRLF-концы строк или исправлять проблемы с ними. Также он не будет пытаться получить дельту для изменений в этом файле при запуске <code>git show</code> или <code>git diff</code> в вашем проекте. Начиная с версии 1.6, в Git&#8217;е есть макрос, который означает то же, что и <code>-crlf -diff</code>:</p>

<pre><code>*.pbxproj binary</code></pre>

<h4 id='____'>Получение дельты для бинарных файлов</h4>

<p>В Git&#8217;е версии 1.6.x функциональность атрибутов может быть использована для эффективного получения дельт для бинарных файлов. Чтобы сделать это, нужно объяснить Git&#8217;у, как сконвертировать ваши бинарные данные в текстовый формат, для которого можно выполнить сравнение с помощью обычного diff.</p>

<h5 id='_ms_word'>Документы MS Word</h5>

<p>Так как эта довольно клёвая функция не особо широко известна, мы рассмотрим несколько примеров её использования. Для начала мы используем этот подход, чтобы решить одну из самых раздражающих проблем, известных человечеству: версионный контроль документов Word. Всем известно, что Word — это самый ужасающий из всех существующих редакторов, но, как ни странно, все им пользуются. Если вы хотите поместить документы Word под версионный контроль, вы можете запихнуть их в Git-репозиторий и время от времени делать коммиты. Но что в этом хорошего? Если вы запустите <code>git diff</code> как обычно, то увидите только что-то наподобие этого:</p>

<pre><code>$ git diff 
diff --git a/chapter1.doc b/chapter1.doc
index 88839c4..4afcb7c 100644
Binary files a/chapter1.doc and b/chapter1.doc differ</code></pre>

<p>У вас не получится сравнить две версии между собой, только если вы не выгрузите их обе и просмотрите их вручную, так? Оказывается, можно сделать это достаточно успешно, используя атрибуты Git&#8217;а. Поместите следующую строку в свой файл <code>.gitattributes</code>:</p>

<pre><code>*.doc diff=word</code></pre>

<p>Она говорит Git&#8217;у, что все файлы, соответствующие указанному шаблону (.doc) должны использовать фильтр &#8220;word&#8221; при попытке посмотреть дельту с изменениями. Что такое фильтр &#8220;word&#8221;? Нам нужно его изготовить. Сейчас мы настроим Git на использование программы <code>strings</code> для конвертирования документов Word в читаемые текстовые файлы, которые Git затем правильно сравнит:</p>

<pre><code>$ git config diff.word.textconv strings</code></pre>

<p>Этой командой в свой <code>.git/config</code> вы добавите следующую секцию:</p>

<pre><code>[diff &quot;word&quot;]
	textconv = strings</code></pre>

<p>Замечание: Существуют разные виды <code>.doc</code> файлов. Некоторые из них могут использовать кодировку UTF-16 или могут быть написаны не в латинице, в таких файлах <code>strings</code> не найдёт ничего хорошего. Полезность <code>strings</code> может сильно варьироваться.</p>

<p>Теперь Git знает, что если ему надо найти дельту между двумя снимками состояния, и какие-то их файлы заканчиваются на <code>.doc</code>, он должен прогнать эти файлы через фильтр &#8220;word&#8221;, который определён как программа <code>strings</code>. Так вы фактически сделаете текстовые версии своих Word-файлов перед тем, как получить для них дельту.</p>

<p>Рассмотрим пример. Я поместил главу 1 настоящей книги в Git, добавил немного текста в один параграф и сохранил документ. Затем я выполнил <code>git diff</code>, чтобы увидеть, что изменилось:</p>

<pre><code>$ git diff
diff --git a/chapter1.doc b/chapter1.doc
index c1c8a0a..b93c9e4 100644
--- a/chapter1.doc
+++ b/chapter1.doc
@@ -8,7 +8,8 @@ re going to cover Version Control Systems (VCS) and Git basics
 re going to cover how to get it and set it up for the first time if you don
 t already have it on your system.
 In Chapter Two we will go over basic Git usage - how to use Git for the 80% 
-s going on, modify stuff and contribute changes. If the book spontaneously 
+s going on, modify stuff and contribute changes. If the book spontaneously 
+Let&#39;s see if this works.</code></pre>

<p>Git коротко и ясно дал мне знать, что я добавил строку &#8220;Let’s see if this works&#8221;, так оно и есть. Работает не идеально, так как добавляет немного лишнего в конце, но определённо работает. Если вы сможете найти или написать хорошо работающую программу для конвертации документов Word в обычный текст, то такое решение, скорее всего, будет невероятно эффективно. Тем не менее, <code>strings</code> доступен на большинстве Mac- и Linux-систем, так что он может быть хорошим первым вариантом для того, чтобы сделать подобное со многими бинарными форматами.</p>

<h5 id='____opendocument'>Текстовые файлы в формате OpenDocument</h5>

<p>Тот же подход, который мы использовали для файлов MS Word (<code>*.doc</code>), может быть использован и для текстовых файлов в формате OpenDocument, созданных в OpenOffice.org.</p>

<p>Добавим следующую строку в файл <code>.gitattributes</code>:</p>

<pre><code>*.odt diff=odt</code></pre>

<p>Теперь настроим фильтр <code>odt</code> в <code>.git/config</code>:</p>

<pre><code>[diff &quot;odt&quot;]
	binary = true
	textconv = /usr/local/bin/odt-to-txt</code></pre>

<p>Файлы в формате OpenDocument на самом деле являются запакованными zip&#8217;ом каталогами с множеством файлов (содержимое в XML-формате, таблицы стилей, изображения и т.д.). Мы напишем сценарий для извлечения содержимого и вывода его в виде обычного текста. Создайте файл <code>/usr/local/bin/odt-to-txt</code> (можете создать его в любом другом каталоге) со следующим содержимым:</p>

<pre><code>#! /usr/bin/env perl
# Сценарий для конвертации OpenDocument Text (.odt) в обычный текст.
# Автор: Philipp Kempgen

if (! defined($ARGV[0])) {
	print STDERR &quot;Не задано имя файла!\n&quot;;
	print STDERR &quot;Использование: $0 имя файла\n&quot;;
	exit 1;
}

my $content = &#39;&#39;;
open my $fh, &#39;-|&#39;, &#39;unzip&#39;, &#39;-qq&#39;, &#39;-p&#39;, $ARGV[0], &#39;content.xml&#39; or die $!;
{
	local $/ = undef;  # считываем файл целиком
	$content = &lt;$fh&gt;;
}
close $fh;
$_ = $content;
s/&lt;text:span\b[^&gt;]*&gt;//g;           # удаляем span&#39;ы
s/&lt;text:h\b[^&gt;]*&gt;/\n\n*****  /g;   # заголовки
s/&lt;text:list-item\b[^&gt;]*&gt;\s*&lt;text:p\b[^&gt;]*&gt;/\n    --  /g;  # элементы списков
s/&lt;text:list\b[^&gt;]*&gt;/\n\n/g;       # списки
s/&lt;text:p\b[^&gt;]*&gt;/\n  /g;          # параграфы
s/&lt;[^&gt;]+&gt;//g;                      # удаляем все XML-теги
s/\n{2,}/\n\n/g;                   # удаляем подряд идущие пустые строки
s/\A\n+//;                         # удаляем пустые строки в начале
print &quot;\n&quot;, $_, &quot;\n\n&quot;;</code></pre>

<p>Сделайте его исполняемым</p>

<pre><code>chmod +x /usr/local/bin/odt-to-txt</code></pre>

<p>Теперь <code>git diff</code> сможет сказать вам, что изменилось в <code>.odt</code> файлах.</p>

<h5 id='id266'>Изображения</h5>

<p>Ещё одна интересная проблема, которую можно решить таким способом, это сравнение файлов изображений. Один из способов сделать это — прогнать PNG-файлы через фильтр, извлекающий их EXIF-информацию — метаданные, которые дописываются в большинство форматов изображений. Если скачаете и установите программу <code>exiftool</code>, то сможете воспользоваться ею, чтобы извлечь из изображений текстовую информацию о метаданных, так чтобы diff хоть как-то показал вам текстовое представление произошедших изменений:</p>

<pre><code>$ echo &#39;*.png diff=exif&#39; &gt;&gt; .gitattributes
$ git config diff.exif.textconv exiftool</code></pre>

<p>Если вы замените в проекте изображение и запустите <code>git diff</code>, то получите что-то вроде такого:</p>

<pre><code>diff --git a/image.png b/image.png
index 88839c4..4afcb7c 100644
--- a/image.png
+++ b/image.png
@@ -1,12 +1,12 @@
 ExifTool Version Number         : 7.74
-File Size                       : 70 kB
-File Modification Date/Time     : 2009:04:17 10:12:35-07:00
+File Size                       : 94 kB
+File Modification Date/Time     : 2009:04:21 07:02:43-07:00
 File Type                       : PNG
 MIME Type                       : image/png
-Image Width                     : 1058
-Image Height                    : 889
+Image Width                     : 1056
+Image Height                    : 827
 Bit Depth                       : 8
 Color Type                      : RGB with Alpha</code></pre>

<p>Легко можно заметить, что размер файла, а также высота и ширина изображения поменялись.</p>

<h3 id='_'>Развёртывание ключа</h3>

<p>Разработчики, привыкшие к SVN или CVS, часто хотят получить в Git&#8217;е возможность развёртывания ключа в стиле этих систем. Основная проблема с реализацией этой функциональности в Git&#8217;е это то, что нельзя записать в файл информацию о коммите после того, как коммит был сделан, так как Git сначала считает контрольную сумму для файла. Несмотря на это, вы можете вставлять текст в файл во время его выгрузки и удалять его перед добавлением в коммит. Атрибуты Git&#8217;а предлагают два варианта сделать это.</p>

<p>Во-первых, вы можете внедрять SHA-1-сумму блоба в поле <code>$Id$</code> в файл автоматически. Если установить соответствующий атрибут для одного или нескольких файлов, то в следующий раз, когда вы будете выгружать данные из этой ветки, Git будет заменять это поле SHA-суммой блоба. Обратите внимание, что это SHA-1 не коммита, а самого блоба.</p>

<pre><code>$ echo &#39;*.txt ident&#39; &gt;&gt; .gitattributes
$ echo &#39;$Id$&#39; &gt; test.txt
$ git add test.txt</code></pre>

<p>В следующий раз, когда вы будете выгружать этот файл, Git автоматически вставит в него SHA его блоба:</p>

<pre><code>$ rm test.txt
$ git checkout -- test.txt
$ cat test.txt 
$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $</code></pre>

<p>Однако, такой результат мало применим. Если вы раньше пользовались развёртыванием ключа в CVS или Subversion, можете добавлять метку даты — SHA не особенно полезен, так как он довольно случаен, и к тому же, глядя на две SHA-суммы, никак не определить какая из них новее.</p>

<p>Как оказывается, можно написать свои собственные фильтры, которые будут делать подстановки в файлах при коммитах и выгрузке файлов. Для этого надо задать фильтры &#8220;clean&#8221; и &#8220;smudge&#8221;. В файле <code>.gitattributes</code> можно задать фильтр для определённых путей и затем установить сценарии, которые будут обрабатывать файлы непосредственно перед выгрузкой (&#8220;smudge&#8221;, см. рис. 7-2) и прямо перед коммитом (&#8220;clean&#8221;, см. рис. 7-3). Эти фильтры можно настроить на совершение абсолютно любых действий.</p>

<p><center><img src="/figures/ch7/18333fig0702-tn.png"></center><br/> Рисунок 7-2. Фильтр “smudge” выполняется при checkout.</p>

<p><center><img src="/figures/ch7/18333fig0703-tn.png"></center><br/> Рисунок 7-3. Фильтр “clean” выполняется при помещении файлов в индекс.</p>

<p>В сообщении первоначального коммита, добавляющего эту функциональность, дан простой пример того, как можно пропустить весь свой исходный код на C через программу <code>indent</code> перед коммитом. Сделать это можно, задав атрибут filter в файле <code>.gitattributes</code> так, чтобы он пропускал файлы <code>*.c</code> через фильтр &#8220;indent&#8221;:</p>

<pre><code>*.c     filter=indent</code></pre>

<p>Затем укажите Git&#8217;у, что должен делать фильтр &#8220;indent&#8221; при smudge и clean:</p>

<pre><code>$ git config --global filter.indent.clean indent
$ git config --global filter.indent.smudge cat</code></pre>

<p>В нашем случае, когда вы будете делать коммит, содержащий файлы, соответствующие шаблону <code>*.c</code>, Git прогонит их через программу <code>indent</code> перед коммитом, а потом через программу <code>cat</code> перед тем как выгрузить их на диск. Программа <code>cat</code>, по сути, является холостой — она выдаёт те же данные, которые получила. Фактически эта комбинация профильтровывает все файлы с исходным кодом на C через <code>indent</code> перед тем, как сделать коммит.</p>

<p>Ещё один интересный пример — это развёртывание ключа <code>$Date$</code> в стиле RCS. Чтобы сделать его правильно, нам понадобится небольшой сценарий, который принимает на вход имя файла, определяет дату последнего коммита в проекте и вставляет эту дату в наш файл. Вот небольшой сценарий на Ruby, который делает именно это:</p>

<pre><code>#! /usr/bin/env ruby
data = STDIN.read
last_date = `git log --pretty=format:&quot;%ad&quot; -1`
puts data.gsub(&#39;$Date$&#39;, &#39;$Date: &#39; + last_date.to_s + &#39;$&#39;)</code></pre>

<p>Всё, что делает этот сценарий, это получает дату последнего коммита с помощью команды <code>git log</code>, засовывает её во все строки <code>$Date$</code>, которые видит в stdin, и выводит результат — такое должно быть несложно реализовать на любом удобном вам языке. Давайте назовём этот файл <code>expand_date</code> и поместим в путь. Теперь в Git&#8217;е необходимо настроить фильтр (назовём его <code>dater</code>) и указать, что надо использовать фильтр <code>expand_date</code> при выполнении smudge во время выгрузки файлов. Воспользуемся регулярным выражением Perl, чтобы убрать изменения при коммите:</p>

<pre><code>$ git config filter.dater.smudge expand_date
$ git config filter.dater.clean &#39;perl -pe &quot;s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/&quot;&#39;</code></pre>

<p>Этот фрагмент кода на Perl&#8217;е вырезает всё, что находит в строке <code>$Date$</code> так, чтобы вернуть всё в начальное состояние. Теперь, когда наш фильтр готов, можете протестировать его, создав файл с ключом <code>$Date$</code> и установив для этого файла Git-атрибут, который задействует для него новый фильтр:</p>

<pre><code>$ echo &#39;# $Date$&#39; &gt; date_test.txt
$ echo &#39;date*.txt filter=dater&#39; &gt;&gt; .gitattributes</code></pre>

<p>Если мы сейчас добавим эти изменения в коммит и снова выгрузим файл, то мы увидим, что ключевое слово было заменено правильно:</p>

<pre><code>$ git add date_test.txt .gitattributes
$ git commit -m &quot;Testing date expansion in Git&quot;
$ rm date_test.txt
$ git checkout date_test.txt
$ cat date_test.txt
# $Date: Tue Apr 21 07:26:52 2009 -0700$</code></pre>

<p>Как видите, такая техника может быть весьма мощной для настройки проекта под свои нужды. Но вы должны быть осторожны, ибо файл <code>.gitattributes</code> вы добавите в коммит и будете его распространять вместе с проектом, а драйвер (в нашем случае <code>dater</code>) — нет. Так что не везде оно будет работать. Когда будете проектировать свои фильтры, постарайтесь сделать так, чтобы при возникновении в них ошибки проект не переставал работать правильно.</p>

<h3 id='_'>Экспорт репозитория</h3>

<p>Ещё атрибуты в Git&#8217;е позволяют делать некоторые интересные вещи при экспортировании архива с проектом.</p>

<h4 id='exportignore'>export-ignore</h4>

<p>Вы можете попросить Git не экспортировать определённые файлы и каталоги при создании архива. Если у вас есть подкаталог или файл, который вы не желаете включать в архив, но хотите, чтобы в проекте он был, можете установить для такого файла атрибут <code>export-ignore</code>.</p>

<p>Например, скажем, у вас в подкаталоге <code>test/</code> имеются некоторые тестовые файлы, и нет никакого смысла добавлять их в тарбол при экспорте проекта. Тогда добавим следующую строку в файл с Git-атрибутами:</p>

<pre><code>test/ export-ignore</code></pre>

<p>Теперь, если вы запустите <code>git archive</code>, чтобы создать тарбол с проектом, этот каталог в архив включён не будет.</p>

<h4 id='exportsubst'>export-subst</h4>

<p>Ещё одна вещь, которую можно сделать с архивами, — это сделать какую-нибудь простую подстановку ключевых слов. Git позволяет добавить в любой файл строку вида <code>$Format:$</code> с любыми кодами форматирования, доступными в <code>--pretty=format</code> (многие из этих кодов мы рассматривали в главе 2). Например, если вам захотелось добавить в проект файл с именем <code>LAST_COMMIT</code>, в который при запуске <code>git archive</code> будет автоматически помещаться дата последнего коммита, то такой файл вы можете сделать следующим образом:</p>

<pre><code>$ echo &#39;Last commit date: $Format:%cd$&#39; &gt; LAST_COMMIT
$ echo &quot;LAST_COMMIT export-subst&quot; &gt;&gt; .gitattributes
$ git add LAST_COMMIT .gitattributes
$ git commit -am &#39;adding LAST_COMMIT file for archives&#39;</code></pre>

<p>После запуска <code>git archive</code> этот файл у вас в архиве будет иметь содержимое следующего вида:</p>

<pre><code>$ cat LAST_COMMIT
Last commit date: $Format:Tue Apr 21 08:38:48 2009 -0700$</code></pre>

<h3 id='_'>Стратегии слияния</h3>

<p>Атрибуты Git&#8217;а могут также быть использованы для того, чтобы попросить Git использовать другие стратегии слияния для определённых файлов в проекте. Одна очень полезная возможность — это сказать Git&#8217;у, чтобы он не пытался слить некоторые файлы, если для них есть конфликт, а просто выбрал ваш вариант, предпочтя его чужому.</p>

<p>Это полезно в том случае, если ветка в вашем проекте разошлась с исходной, но вам всё же хотелось бы иметь возможность слить изменения из неё обратно, проигнорировав некоторые файлы. Скажем, у вас есть файл с настройками базы данных, который называется database.xml, и в двух ветках он разный, и вы хотите влить другую свою ветку, не трогая файл с настройками базы данных. Задайте атрибут следующим образом:</p>

<pre><code>database.xml merge=ours</code></pre>

<p>При вливании другой ветки, вместо конфликтов слияния для файла database.xml, вы увидите следующее:</p>

<pre><code>$ git merge topic
Auto-merging database.xml
Merge made by recursive.</code></pre>

<p>В данном случае database.xml остался в том варианте, в каком и был изначально.</p>

<div id='nav'>
<a href='ch7-1.html'>prev</a> | <a href='ch7-3.html'>next</a>
</div>