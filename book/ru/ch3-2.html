---
layout: translation
title: Pro Git 3.2 Ветвление в Git Основы ветвления и слияния
---
<h2 id='___'>Основы ветвления и слияния</h2>

<p>Давайте рассмотрим простой пример ветвления и слияния с таким процессом работы, который вы могли бы использовать в настоящей разработке. Вы будете делать следующее:</p>

<p>1. Работать над веб-сайтом. 2. Создадите ветку для новой истории, над которой вы работаете. 3. Выполните некоторую работу на этой ветке.</p>

<p>На этом этапе вы получите звонок о том, что сейчас критична другая проблема, и её надо срочно решить. Вы сделаете следующее:</p>

<p>1. Вернётесь на производственную ветку. 2. Создадите ветку для исправления ошибки. 3. После его тестирования, сольёте ветку с исправлением и отправите в продакшн. 4. Переключитесь к прерванной истории и продолжите работу.</p>

<h3 id='_'>Основы ветвления</h3>

<p>Для начала представим, что вы работаете над своим проектом и уже имеете пару коммитов (см. Рисунок 3-10).</p>

<p><center><img src="/figures/ch3/18333fig0310-tn.png"></center><br/> Рисунок 3-10. Короткая и простая история коммитов.</p>

<p>Вы решили, что вы будете работать над проблемой №53 из системы отслеживания ошибок, используемой вашей компанией. Разумеется, Git не привязан к какой-то определенной системе отслеживания ошибок. Просто из-за того, что проблема №53 является основной задачей, над которой вы хотите работать, вы создадите новую ветку для работы в ней. Чтобы создать ветку и сразу же перейти на неё, вы можете выполнить команду <code>git checkout</code> с ключом <code>-b</code>:</p>

<pre><code>$ git checkout -b iss53
Switched to a new branch &quot;iss53&quot;</code></pre>

<p>Это сокращение для:</p>

<pre><code>$ git branch iss53
$ git checkout iss53</code></pre>

<p>Рисунок 3-11 показывает результат.</p>

<p><center><img src="/figures/ch3/18333fig0311-tn.png"></center><br/> Рисунок 3-11. Создание новой ветки / указателя.</p>

<p>Во время работы над вашим веб-сайтом, вы делаете несколько коммитов. Эти действия сдвигают ветку <code>iss53</code> вперёд потому, что вы на неё перешли (то есть ваш HEAD указывает на неё; см. Рисунок 3-12):</p>

<pre><code>$ vim index.html
$ git commit -a -m &#39;added a new footer [issue 53]&#39;</code></pre>

<p><center><img src="/figures/ch3/18333fig0312-tn.png"></center><br/> Рисунок 3-12. Ветка iss53 передвинулась вперёд во время работы.</p>

<p>Теперь вы получаете звонок о том, что есть проблема с веб-сайтом, которую необходимо немедленно устранить. С Git, вам нет нужды создавать заплатку вместе с теми изменениями, которые вы уже сделали для <code>iss53</code>. А также не надо прикладывать много усилий, чтобы отменить эти изменения перед тем, как вы сможете начать работать над решением срочной проблемы. Всё, что вам нужно сделать, это перейти на ветку master.</p>

<p>Однако, прежде чем сделать это, учтите, что если в вашем рабочем каталоге или индексе имеются незафиксированные изменения, которые конфликтуют с веткой, на которую вы переходите, Git не позволит переключить ветки. Лучше всего при переключении веток иметь чистое рабочее состояния. Существует несколько способов добиться этого (а именно, прятанье (stash) работы и правка (amend) коммита), которые мы рассмотрим позже. А на данный момент представим, что вы зафиксировали все изменения, и можете переключиться обратно на ветку master:</p>

<pre><code>$ git checkout master
Switched to branch &quot;master&quot;</code></pre>

<p>Теперь рабочий каталог проекта находится точно в таком же состоянии, что и в момент начала работы над проблемой №53, так что вы можете сконцентрироваться на срочном изменении. Очень важно запомнить: Git возвращает ваш рабочий каталог к снимку состояния того коммита, на который указывает ветка, на которую вы переходите. Он добавляет, удаляет и изменяет файлы автоматически, чтобы гарантировать, что состояние вашей рабочей копии идентично последнему коммиту на ветке.</p>

<p>Итак, вам надо срочно исправить ошибку. Давайте создадим для этого ветку, на которой вы будете работать (см. Рисунок 3-13):</p>

<pre><code>$ git checkout -b &#39;hotfix&#39;
Switched to a new branch &quot;hotfix&quot;
$ vim index.html
$ git commit -a -m &#39;fixed the broken email address&#39;
[hotfix]: created 3a0874c: &quot;fixed the broken email address&quot;
 1 files changed, 0 insertions(+), 1 deletions(-)</code></pre>

<p><center><img src="/figures/ch3/18333fig0313-tn.png"></center><br/> Рисунок 3-13. Ветка для решения срочной проблемы базируется на ветке master.</p>

<p>Вы можете запустить тесты, убедиться, что решение работает, и слить (merge) изменения назад в ветку master, чтобы включить его в продукт. Это делается с помощью команды <code>git merge</code>:</p>

<pre><code>$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c
Fast forward
 README |    1 -
 1 files changed, 0 insertions(+), 1 deletions(-)</code></pre>

<p>Наверное, вы заметили фразу &#8220;Fast forward&#8221; в этом слиянии. Так как ветка, которую вы сливали, указывала на коммит, являющийся прямым потомком коммита, на котором вы находитесь, Git передвигает указатель вперёд. Иными словами, когда вы пытаетесь слить один коммит с другим, который может быть достигнут идя по истории первого коммита, Git упрощает вещи, перемещая указатель вперёд, так как нету расходящихся изменений для слияния их воедино. Это называется &#8220;fast forward&#8221; (перемотка).</p>

<p>Ваши изменения теперь в снимке состояния коммита, на который указывает ветка master, и вы можете включить изменения в продукт (см. Рисунок 3-14).</p>

<p><center><img src="/figures/ch3/18333fig0314-tn.png"></center><br/> Рисунок 3-14. После слияния ветка master указывает туда же, куда и ветка hotfix.</p>

<p>После того, как очень важная проблема решена, вы готовы вернуться обратно к работе, которую делали, прежде чем были прерваны. Однако, сначала удалите ветку <code>hotfix</code>, так как она больше не нужна — ветка <code>master</code> уже указывает на то же место. Вы можете удалить ветку с помощью опции <code>-d</code> к <code>git branch</code>:</p>

<pre><code>$ git branch -d hotfix
Deleted branch hotfix (3a0874c).</code></pre>

<p>Теперь вы можете вернуться обратно к рабочей ветке для проблемы №53 и продолжить работать над ней (см. Рисунок 3-15):</p>

<pre><code>$ git checkout iss53
Switched to branch &quot;iss53&quot;
$ vim index.html
$ git commit -a -m &#39;finished the new footer [issue 53]&#39;
[iss53]: created ad82d7a: &quot;finished the new footer [issue 53]&quot;
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>

<p><center><img src="/figures/ch3/18333fig0315-tn.png"></center><br/> Рисунок 3-15. Ветка iss53 может двигаться вперёд независимо.</p>

<p>Стоит напомнить, что работа, сделанная на ветке <code>hotfix</code>, не включена в файлы на ветке <code>iss53</code>. Если вам это необходимо, вы можете выполнить слияние ветки <code>master</code> в ветку <code>iss53</code> посредством команды <code>git merge master</code>. Или же вы можете подождать с интеграцией изменений до тех пор, пока не решите включить изменения на <code>iss53</code> в продуктовую ветку <code>master</code>.</p>

<h3 id='_'>Основы слияния</h3>

<p>Представьте себе, что вы разобрались с проблемой №53 и готовы объединить эту ветку и свой <code>master</code>. Чтобы сделать это, вы выполните слияние вашей ветки <code>iss53</code> в ветку <code>master</code> точно так же, как делали ранее с веткой <code>hotfix</code>. Все что вы должны сделать ― перейти на ту ветку, в которую вы хотите внести свои изменения и выполнить команду <code>git merge</code>:</p>

<pre><code>$ git checkout master
$ git merge iss53
Merge made by recursive.
 README |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>

<p>Сейчас слияние выглядит немного не так, как для ветки <code>hotfix</code>, которое вы делали ранее. В данном случае ваша история разработки разделилась в некоторой точке. Так как коммит на той ветке, на которой вы находитесь, не является прямым предком для ветки, которую вы сливаете, Git-у придётся проделать кое-какую работу. В этом случае Git делает простое трехходовое слияние, используя при этом два снимка состояния репозитория, на которые указывают вершины веток, и общий снимок-прародитель для этих двух веток. На рисунке 3-16 выделены три снимка, которые Git будет использовать для слияния в этом случае.</p>

<p><center><img src="/figures/ch3/18333fig0316-tn.png"></center><br/> Рисунок 3-16. Git автоматически определяет наилучшего общего предка для слияния веток.</p>

<p>Вместо того, чтобы просто передвинуть указатель ветки вперёд, Git создаёт новый снимок состояния, который является результатом трехходового слияния, и автоматически создает новый коммит, который указывает на этот новый снимок состояния (смотри Рисунок 3-17). Такой коммит называют коммит-слияние, так как он является особенным из-за того, что имеет больше одного предка.</p>

<p>Стоит отметить, что Git определяет наилучшего общего предка для слияния веток; в CVS или Subversion (версии ранее 1.5) этого не происходит. Разработчик должен сам указать основу для слияния. Это делает слияние в Git гораздо более простым занятием, чем в других системах.</p>

<p><center><img src="/figures/ch3/18333fig0317-tn.png"></center><br/> Рисунок 3-17. Git автоматически создает новый коммит, содержащий результаты слияния.</p>

<p>Теперь, когда вы осуществили слияние ваших наработок, ветка <code>iss53</code> вам больше не нужна. Можете удалить ее и затем вручную закрыть карточку (ticket) в вашей системе:</p>

<pre><code>$ git branch -d iss53</code></pre>

<h3 id='___'>Основы конфликтов при слиянии</h3>

<p>Иногда процесс слияния не идет гладко. Если вы изменили одну и ту же часть файла по-разному в двух ветках, которые собираетесь объединить, Git не сможет сделать это чисто. Если ваше решение проблемы №53 изменяет ту же часть файла, что и <code>hotfix</code>, вы получите конфликт слияния, и выглядеть он будет примерно следующим образом:</p>

<pre><code>$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.</code></pre>

<p>Git не создал новый коммит для слияния. Он приостановил этот процесс до тех пор, пока вы не разрешите конфликт. Если вы хотите посмотреть, какие файлы не прошли слияние (на любом этапе после возникновения конфликта), можете выполнить команду <code>git status</code>:</p>

<pre><code>[master*]$ git status
index.html: needs merge
# On branch master
# Changed but not updated:
#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#	unmerged:   index.html
#</code></pre>

<p>Всё, что имеет отношение к конфликту слияния и что не было разрешено, отмечено как unmerged. Git добавляет стандартные маркеры к файлам, которые имеют конфликт, так что вы можете открыть их вручную и разрешить эти конфликты. Ваш файл содержит секцию, которая выглядит примерно так:</p>

<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html
&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;
=======
&lt;div id=&quot;footer&quot;&gt;
  please contact us at support@github.com
&lt;/div&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</code></pre>

<p>В верхней части блока (всё что выше <code>=======</code>) это версия из HEAD (вашей ветки master, так как именно на неё вы перешли перед выполнением команды merge), всё что находится в нижней части ― версия в <code>iss53</code>. Чтобы разрешить конфликт вы должны либо выбрать одну из этих частей, либо как-то объединить содержимое по своему усмотрению. Например, вы можете разрешить этот конфликт заменой всего блока, показанного выше, следующим блоком:</p>

<pre><code>&lt;div id=&quot;footer&quot;&gt;
please contact us at email.support@github.com
&lt;/div&gt;</code></pre>

<p>Это решение содержит понемногу из каждой части, и я полностью удалил строки <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code> и <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>. После того, как вы разрешили каждую из таких секций с каждым из конфликтных файлов, выполните <code>git add</code> для каждого конфликтного файла. Индексирование будет означать для Git, что все конфликты в файле теперь разрешены. Если вы хотите использовать графические инструменты для разрешения конфликтов, можете выполнить команду <code>git mergetool</code>, которая запустит соответствующий графический инструмент и покажет конфликтные ситуации:</p>

<pre><code>$ git mergetool
merge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge vimdiff
Merging the files: index.html

Normal merge conflict for &#39;index.html&#39;:
  {local}: modified
  {remote}: modified
Hit return to start merge resolution tool (opendiff):</code></pre>

<p>Если вы хотите использовать другой инструмент для слияния, нежели выбираемый по умолчанию (Git выбрал <code>opendiff</code> для меня, так как я выполнил команду на Mac). Вы можете увидеть все поддерживаемые инструменты, указанные выше после “merge tool candidates”. Укажите название предпочтительного для вас инструмента. В Главе 7 мы обсудим, как изменить это значение по умолчанию для вашего окружения.</p>

<p>После того, как вы выйдете из инструмента для выполнения слияния, Git спросит вас, было ли оно успешным. Если вы отвечаете, что да ― файл индексируется (добавляется в область для коммита), чтобы дать вам понять, что конфликт разрешен.</p>

<p>Можете выполнить <code>git status</code> ещё раз, чтобы убедиться, что все конфликты были разрешены:</p>

<pre><code>$ git status
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#	modified:   index.html
#</code></pre>

<p>Если вы довольны тем, что получили, и удостоверились, что всё, имевшее конфликты, было проиндексировано, можете выполнить <code>git commit</code> для завершения слияния. По умолчанию сообщение коммита будет выглядеть примерно так:</p>

<pre><code>Merge branch &#39;iss53&#39;

Conflicts:
  index.html
#
# It looks like you may be committing a MERGE.
# If this is not correct, please remove the file
# .git/MERGE_HEAD
# and try again.
#</code></pre>

<p>Вы можете дополнить это сообщение информацией о том, как вы разрешили конфликт, если считаете, что это может быть полезно для других в будущем. Например, можете указать почему вы сделали то, что сделали, если это не очевидно конечно.</p>

<div id='nav'>
<a href='ch3-1.html'>prev</a> | <a href='ch3-3.html'>next</a>
</div>