---
layout: translation
title: Pro Git 3.4 Branchen in Git Branch Werkwijzen
---
<h2 id='branch_werkwijzen'>Branch Werkwijzen</h2>

<p>Nu dat je de basis van het branchen en samenvoegen onder de knie hebt, wat kan of zou je met ze kunnen doen? In dit gedeelte gaan we over een aantal veel voorkomende werkwijzen die deze lichtgewicht branches mogelijk maken, zodat je kunt beslissen of dat je ze wilt integreren in je ontwikkel cyclus.</p>

<h3 id='langlopende_branches'>Lang-Lopende Branches</h3>

<p>Omdat Git gebruik maakt van een eenvoudige drieweg samenvoeging, is het meerdere keren samenvoegen vanuit een branch met een andere over een langere periode over het algemeen eenvoudig om te doen. Dit betekent dat je meerdere branches kunt hebben, die altijd open staan en die je voor verschillende delen van je ontwikkel cyclus gebruikt; je kunt regelmatig samenvoegen van een aantal ervan in de anderen.</p>

<p>Veel Git ontwikkelaars hebben een werkwijze die deze aanpak omarmd, zoals het hebben van alleen volledig stabiele code in hun <code>master</code> branch – waarschijnlijk alleen code die is of zal worden vrijgegeven. Ze hebben een andere parallelle branch genaamd develop of next waarop ze werken of die ze gebruiken om stabiliteit te testen – het is niet noodzakelijk altijd stabiel, maar zodra het naar een stabiele status gaat, kan het worden samengevoegd in <code>master</code>. Het wordt gebruikt om onderwerp branches (branches met een korte levensduur, zoals jou eerdere <code>iss53</code> branch) binnen te halen, zodra die klaar zijn, om er zeker van te zijn dat ze voor alle testen slagen en geen fouten introduceren.</p>

<p>In werkelijkheid praten we over verwijzingen die zich verplaatsen over de lijn van de commits die je maakt. De stabiele branches zijn verder naar achter in je commit historie, en de splinternieuwe branches zijn verder naar voren in de historie (zie Figuur 3-18).</p>

<p><center><img src="/figures/ch3/18333fig0318-tn.png"></center><br/> Figuur 3-18. Meer stabiele branches zijn vaak verder naar achter in de commit historie.</p>

<p>Ze zijn over het algemeen makkelijker voor te stellen als werk silo&#8217;s, waar sets van commits slagen naar een meer stabiele silo als ze volledig getest zijn (zie Figuur 3-19).</p>

<p><center><img src="/figures/ch3/18333fig0319-tn.png"></center><br/> Figuur 3-19. Het kan handig zijn om je branches voor te stellen als silo&#8217;s.</p>

<p>Je kunt dit doen voor meerdere nivo&#8217;s van stabiliteit. Sommige grotere projecten hebben ook een <code>proposed</code> of <code>pu</code> (proposed updates) branch die branches geïntegreerd heeft die wellicht nog niet klaar zijn om in de <code>next</code> of <code>master</code> branch te gaan. Het idee is dat je branches op verschillende nivo&#8217;s van stabiliteit zitten; zodra ze een stabiel nivo bereiken, worden ze in de branch boven hun samengevoegd. Nogmaals, het hebben van langlopende branches is niet noodzakelijk, maar het helpt vaak wel, in het bijzonder als je moet omgaan met zeer grote of complexe projecten.</p>

<h3 id='onderwerp_branches'>Onderwerp Branches</h3>

<p>Maar, onderwerp branches zijn bruikbaar in projecten van iedere grootte. Een onderwerp branch is een kortlopende branch die je maakt en gebruikt om een enkele eigenschap of gerelateerd werk in te doen. Dit is iets wat je waarschijnlijk nooit vantevoren met een VCS gedaan hebt, omdat het over het algemeen te duur is om branches aan te maken en samen te voegen. Maar in Git komt het vaak voor om branches aan te maken, op te werken, en te verwijderen meerdere keren per dag.</p>

<p>Je zag dit in het laatste gedeelte met de <code>iss53</code> en <code>hotfix</code> branches die je gemaakt had. Je hebt een aantal commits op ze gedaan en ze meteen verwijderd zodra je ze samengevoegd had in je hoofd branch. Deze techniek staat je toe om snel en volledig van context te veranderen – omdat je werk is gescheiden in silo&#8217;s waar alle wijzigingen in die branch met dat onderwerp te maken hebben, is het makkelijker te zien wat er is gebeurd tijdens een code review en dergelijke. Je kunt de wijzigingen daar minuten, dagen of maanden bewaren, en ze samenvoegen als je er klaar voor bent, ongeacht in de volgorde waarin ze gemaakt of aan gewerkt zijn.</p>

<p>Neem als voorbeeld een situatie waarbij wat werk gedaan wordt (op <code>master</code>), gebranched wordt voor een probleem (<code>iss91</code>), waar een beetje aan gewerkt wordt, gebranched wordt vanaf de tweede branch om op een andere manier te proberen hetzelfde op te lossen (<code>iss91v2</code>) terug te gaan naar je master branch en daar een tijdje te werken, en dan vanaf daar branchen om wat werk te doen waarvan je niet zeker weet of het wel een goed idee is (<code>dumbidea</code> branch). Je commit historie zal er uit zien als Figuur 3-20.</p>

<p><center><img src="/figures/ch3/18333fig0320-tn.png"></center><br/> Figuur 3-20. Je commit geschiedenis met meerdere onderwerp branches.</p>

<p>Nu, laten we zeggen dat je beslist dat je de tweede oplossing voor je probleem het beste vindt (<code>iss91v2</code>); en je hebt de <code>dumbidea</code> branch aan je collega&#8217;s laten zien, en het blijkt geniaal te zijn. Je kunt dan de originel <code>iss91</code> weggooien (waarbij je commits C5 en C6 verliest), en de andere twee samenvoegen. Je historie ziet er dan uit als Figuur 3-21).</p>

<p><center><img src="/figures/ch3/18333fig0321-tn.png"></center><br/> Figuur 3-21. Je historie na het samenvoegen van dumbidea en iss91v2.</p>

<p>Het is belangrijk om te onthouden dat wanneer je dit alles doet, deze branches volledig lokaal zijn. Als je aan het branchen of samenvoegen bent, dan wordt alles gedaan in jouw Git repository – dus er gebeurt geen server communicatie.</p>

<div id='nav'>
<a href='ch3-3.html'>prev</a> | <a href='ch3-5.html'>next</a>
</div>